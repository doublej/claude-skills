{
  "title": "Full API Reference",
  "content": "* interface EventTypes {\n\t *   'event-with-parameters': any[]\n\t *   'event-with-example-handler': (...args: any[]) => void\n\t * }\n\t * ts\n * // Full white (opaque)\n * const white: RgbaArray = [1, 1, 1, 1];\n *\n * // Semi-transparent red\n * const transparentRed: RgbaArray = [1, 0, 0, 0.5];\n * ts\n * // CSS Color Names\n * new Color('red');\n * new Color('blue');\n * new Color('green');\n *\n * // Hex Values\n * new Color(0xff0000);     // RGB integer\n * new Color('#ff0000');    // 6-digit hex\n * new Color('#f00');       // 3-digit hex\n * new Color('#ff0000ff');  // 8-digit hex (with alpha)\n * new Color('#f00f');      // 4-digit hex (with alpha)\n *\n * // RGB/RGBA Objects\n * new Color({ r: 255, g: 0, b: 0 });\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 });\n *\n * // RGB/RGBA Strings\n * new Color('rgb(255, 0, 0)');\n * new Color('rgba(255, 0, 0, 0.5)');\n * new Color('rgb(100% 0% 0%)');\n * new Color('rgba(100% 0% 0% / 50%)');\n *\n * // Arrays (normalized 0-1)\n * new Color([1, 0, 0]);           // RGB\n * new Color([1, 0, 0, 0.5]);      // RGBA\n * new Color(new Float32Array([1, 0, 0, 0.5]));\n *\n * // Arrays (0-255)\n * new Color(new Uint8Array([255, 0, 0]));\n * new Color(new Uint8ClampedArray([255, 0, 0, 128]));\n *\n * // HSL/HSLA\n * new Color({ h: 0, s: 100, l: 50 });\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 });\n * new Color('hsl(0, 100%, 50%)');\n * new Color('hsla(0deg 100% 50% / 50%)');\n *\n * // HSV/HSVA\n * new Color({ h: 0, s: 100, v: 100 });\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 });\n * js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n *\n * // Convert between formats\n * const color = new Color('red');\n * color.toHex();        // \"#ff0000\"\n * color.toRgbString();  // \"rgb(255,0,0,1)\"\n * color.toNumber();     // 0xff0000\n *\n * // Access components\n * color.red;    // 1\n * color.green;  // 0\n * color.blue;   // 0\n * color.alpha;  // 1\n *\n * // Chain operations\n * color\n *   .setAlpha(0.5)\n *   .multiply([0.5, 0.5, 0.5])\n *   .premultiply(0.8);\n * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Use shared instance for one-off color operations\n\t * Color.shared.setValue(0xff0000);\n\t * const redHex = Color.shared.toHex();     // \"#ff0000\"\n\t * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]\n\t *\n\t * // Temporary color transformations\n\t * const colorNumber = Color.shared\n\t *     .setValue('#ff0000')     // Set to red\n\t *     .setAlpha(0.5)          // Make semi-transparent\n\t *     .premultiply(0.8)       // Apply premultiplication\n\t *     .toNumber();            // Convert to number\n\t *\n\t * // Chain multiple operations\n\t * const result = Color.shared\n\t *     .setValue(someColor)\n\t *     .multiply(tintColor)\n\t *     .toPremultiplied(alpha);\n\t * ts\n\t * const color = new Color('red');\n\t * console.log(color.red); // 1\n\t *\n\t * const green = new Color('#00ff00');\n\t * console.log(green.red); // 0\n\t * ts\n\t * const color = new Color('lime');\n\t * console.log(color.green); // 1\n\t *\n\t * const red = new Color('#ff0000');\n\t * console.log(red.green); // 0\n\t * ts\n\t * const color = new Color('blue');\n\t * console.log(color.blue); // 1\n\t *\n\t * const yellow = new Color('#ffff00');\n\t * console.log(yellow.blue); // 0\n\t * ts\n\t * const color = new Color('red');\n\t * console.log(color.alpha); // 1 (fully opaque)\n\t *\n\t * const transparent = new Color('rgba(255, 0, 0, 0.5)');\n\t * console.log(transparent.alpha); // 0.5 (semi-transparent)\n\t * ts\n\t * // Basic usage\n\t * const color = new Color();\n\t * color.setValue('#ff0000')\n\t *     .setAlpha(0.5)\n\t *     .premultiply(0.8);\n\t *\n\t * // Different formats\n\t * color.setValue(0xff0000);          // Hex number\n\t * color.setValue('#ff0000');         // Hex string\n\t * color.setValue([1, 0, 0]);         // RGB array\n\t * color.setValue([1, 0, 0, 0.5]);    // RGBA array\n\t * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object\n\t *\n\t * // Copy from another color\n\t * const red = new Color('red');\n\t * color.setValue(red);\n\t * ts\n\t * // Setting different color formats\n\t * const color = new Color();\n\t *\n\t * color.value = 0xff0000;         // Hex number\n\t * color.value = '#ff0000';        // Hex string\n\t * color.value = [1, 0, 0];        // RGB array\n\t * color.value = [1, 0, 0, 0.5];   // RGBA array\n\t * color.value = { r: 1, g: 0, b: 0 }; // RGB object\n\t *\n\t * // Copying from another color\n\t * const red = new Color('red');\n\t * color.value = red;  // Copies red's components\n\t *\n\t * // Getting the value\n\t * console.log(color.value);  // Returns original format\n\t *\n\t * // After modifications\n\t * color.multiply([0.5, 0.5, 0.5]);\n\t * console.log(color.value);  // Returns null\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGBA objects\n\t * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }\n\t * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }\n\t *\n\t * // With transparency\n\t * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGB objects\n\t * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }\n\t * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }\n\t *\n\t * // Alpha is ignored\n\t * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert colors to RGBA strings\n\t * new Color('white').toRgbaString();     // returns \"rgba(255,255,255,1)\"\n\t * new Color('#ff0000').toRgbaString();   // returns \"rgba(255,0,0,1)\"\n\t *\n\t * // With transparency\n\t * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns \"rgba(255,0,0,0.5)\"\n\t * ts\n\t * // Basic usage\n\t * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n\t * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]\n\t *\n\t * // Using custom output array\n\t * const rgb = new Uint8Array(3);\n\t * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]\n\t *\n\t * // Using different array types\n\t * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]\n\t * new Color('red').toUint8RgbArray([]); // [255, 0, 0]\n\t * ts\n\t * // Basic usage\n\t * new Color('white').toArray();  // returns [1, 1, 1, 1]\n\t * new Color('red').toArray();    // returns [1, 0, 0, 1]\n\t *\n\t * // With alpha\n\t * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]\n\t *\n\t * // Using custom output array\n\t * const rgba = new Float32Array(4);\n\t * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]\n\t * ts\n\t * // Basic usage\n\t * new Color('white').toRgbArray(); // returns [1, 1, 1]\n\t * new Color('red').toRgbArray();   // returns [1, 0, 0]\n\t *\n\t * // Using custom output array\n\t * const rgb = new Float32Array(3);\n\t * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]\n\t * ts\n\t * // Basic usage\n\t * new Color('white').toNumber(); // returns 0xffffff\n\t * new Color('red').toNumber();   // returns 0xff0000\n\t *\n\t * // Store as hex\n\t * const color = new Color('blue');\n\t * const hex = color.toNumber(); // 0x0000ff\n\t * ts\n\t * // Convert RGB to BGR\n\t * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n\t *\n\t * // Common use case: platform-specific color format\n\t * const color = new Color('orange');\n\t * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Convert RGB color to little endian format\n\t * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n\t *\n\t * // Common use cases:\n\t * const color = new Color('orange');\n\t * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems\n\t *\n\t * // Multiple conversions\n\t * const colors = {\n\t *     normal: 0xffcc99,\n\t *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff\n\t *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99\n\t * };\n\t * ts\n\t * // Basic multiplication\n\t * const color = new Color('#ff0000');\n\t * color.multiply(0x808080); // 50% darker red\n\t *\n\t * // With transparency\n\t * color.multiply([1, 1, 1, 0.5]); // 50% transparent\n\t *\n\t * // Chain operations\n\t * color\n\t *     .multiply('#808080')\n\t *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });\n\t * ts\n\t * // Basic premultiplication\n\t * const color = new Color('red');\n\t * color.premultiply(0.5); // 50% transparent red with premultiplied RGB\n\t *\n\t * // Alpha only (RGB unchanged)\n\t * color.premultiply(0.5, false); // 50% transparent, original RGB\n\t *\n\t * // Chain with other operations\n\t * color\n\t *     .multiply(0x808080)\n\t *     .premultiply(0.5)\n\t *     .toNumber();\n\t * ts\n\t * // Convert to premultiplied format\n\t * const color = new Color('red');\n\t *\n\t * // Full opacity (0xFFRRGGBB)\n\t * color.toPremultiplied(1.0); // 0xFFFF0000\n\t *\n\t * // 50% transparency with premultiplied RGB\n\t * color.toPremultiplied(0.5); // 0x7F7F0000\n\t *\n\t * // 50% transparency without RGB premultiplication\n\t * color.toPremultiplied(0.5, false); // 0x7FFF0000\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Basic colors\n\t * new Color('red').toHex();    // returns \"#ff0000\"\n\t * new Color('white').toHex();  // returns \"#ffffff\"\n\t * new Color('black').toHex();  // returns \"#000000\"\n\t *\n\t * // From different formats\n\t * new Color(0xff0000).toHex(); // returns \"#ff0000\"\n\t * new Color([1, 0, 0]).toHex(); // returns \"#ff0000\"\n\t * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns \"#ff0000\"\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // Fully opaque colors\n\t * new Color('red').toHexa();   // returns \"#ff0000ff\"\n\t * new Color('white').toHexa(); // returns \"#ffffffff\"\n\t *\n\t * // With transparency\n\t * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns \"#ff00007f\"\n\t * new Color([1, 0, 0, 0]).toHexa(); // returns \"#ff000000\"\n\t * ts\n\t * // Basic alpha setting\n\t * const color = new Color('red');\n\t * color.setAlpha(0.5);  // 50% transparent red\n\t *\n\t * // Chain with other operations\n\t * color\n\t *     .setValue('#ff0000')\n\t *     .setAlpha(0.8)    // 80% opaque\n\t *     .premultiply(0.5); // Further modify alpha\n\t *\n\t * // Reset to fully opaque\n\t * color.setAlpha(1);\n\t * ts\n\t * import { Color } from 'pixi.js';\n\t *\n\t * // CSS colors and hex values\n\t * Color.isColorLike('red');          // true\n\t * Color.isColorLike('#ff0000');      // true\n\t * Color.isColorLike(0xff0000);       // true\n\t *\n\t * // Arrays (RGB/RGBA)\n\t * Color.isColorLike([1, 0, 0]);      // true\n\t * Color.isColorLike([1, 0, 0, 0.5]); // true\n\t *\n\t * // TypedArrays\n\t * Color.isColorLike(new Float32Array([1, 0, 0]));          // true\n\t * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true\n\t * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true\n\t *\n\t * // Object formats\n\t * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)\n\t * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)\n\t * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)\n\t * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)\n\t * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)\n\t * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)\n\t *\n\t * // Color instances\n\t * Color.isColorLike(new Color('red')); // true\n\t *\n\t * // Invalid values\n\t * Color.isColorLike(null);           // false\n\t * Color.isColorLike(undefined);      // false\n\t * Color.isColorLike({});             // false\n\t * Color.isColorLike([]);             // false\n\t * Color.isColorLike('not-a-color');  // false\n\t * ts\n * // Create an object implementing PointData\n * const point: PointData = { x: 100, y: 200 };\n *\n * // Use with matrix transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Mix with other point types\n * const observablePoint = new ObservablePoint(() => {}, null, 0, 0);\n * const regularPoint = new Point(0, 0);\n * // All are PointData compatible\n * ts\n * // Basic point manipulation\n * const point: PointLike = new Point(10, 20);\n * point.set(30, 40);\n *\n * // Copy between points\n * const other = new Point();\n * point.copyTo(other);\n *\n * // Compare points\n * const same = point.equals(other); // true\n * ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(30, 40);\n\t * point1.copyFrom(point2);\n\t * console.log(point1.x, point1.y); // 30, 40\n\t * ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(0, 0);\n\t * point1.copyTo(point2);\n\t * console.log(point2.x, point2.y); // 10, 20\n\t * ts\n\t * const point1: PointLike = new Point(10, 20);\n\t * const point2: PointLike = new Point(10, 20);\n\t * const point3: PointLike = new Point(30, 40);\n\t * console.log(point1.equals(point2)); // true\n\t * console.log(point1.equals(point3)); // false\n\t * ts\n\t * const point: PointLike = new Point(10, 20);\n\t * point.set(30, 40);\n\t * console.log(point.x, point.y); // 30, 40\n\t * point.set(50); // Sets both x and y to 50\n\t * console.log(point.x, point.y); // 50, 50\n\t * ts\n * // Basic point creation\n * const point = new Point(100, 200);\n *\n * // Using with transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Point arithmetic\n * const start = new Point(0, 0);\n * const end = new Point(100, 100);\n * const middle = new Point(\n *     (start.x + end.x) / 2,\n *     (start.y + end.y) / 2\n * );\n * ts\n\t * // Set x position\n\t * const point = new Point();\n\t * point.x = 100;\n\t *\n\t * // Use in calculations\n\t * const width = rightPoint.x - leftPoint.x;\n\t * ts\n\t * // Set y position\n\t * const point = new Point();\n\t * point.y = 200;\n\t *\n\t * // Use in calculations\n\t * const height = bottomPoint.y - topPoint.y;\n\t * ts\n\t * // Basic point cloning\n\t * const original = new Point(100, 200);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.set(300, 400);\n\t *\n\t * // Verify independence\n\t * console.log(original); // Point(100, 200)\n\t * console.log(modified); // Point(300, 400)\n\t * ts\n\t * // Basic copying\n\t * const source = new Point(100, 200);\n\t * const target = new Point();\n\t * target.copyFrom(source);\n\t *\n\t * // Copy and chain operations\n\t * const point = new Point()\n\t *     .copyFrom(source)\n\t *     .set(x + 50, y + 50);\n\t *\n\t * // Copy from any PointData\n\t * const data = { x: 10, y: 20 };\n\t * point.copyFrom(data);\n\t * ts\n\t * // Basic copying\n\t * const source = new Point(100, 200);\n\t * const target = new Point();\n\t * source.copyTo(target);\n\t * ts\n\t * // Basic equality check\n\t * const p1 = new Point(100, 200);\n\t * const p2 = new Point(100, 200);\n\t * console.log(p1.equals(p2)); // true\n\t *\n\t * // Compare with PointData\n\t * const data = { x: 100, y: 200 };\n\t * console.log(p1.equals(data)); // true\n\t *\n\t * // Check different points\n\t * const p3 = new Point(200, 300);\n\t * console.log(p1.equals(p3)); // false\n\t * ts\n\t * // Basic position setting\n\t * const point = new Point();\n\t * point.set(100, 200);\n\t *\n\t * // Set both x and y to same value\n\t * point.set(50); // x=50, y=50\n\t *\n\t * // Chain with other operations\n\t * point\n\t *     .set(10, 20)\n\t *     .copyTo(otherPoint);\n\t * ts\n\t * // Use for temporary calculations\n\t * const tempPoint = Point.shared;\n\t * tempPoint.set(100, 200);\n\t * matrix.apply(tempPoint);\n\t *\n\t * // Will be reset to (0,0) on next access\n\t * const fresh = Point.shared; // x=0, y=0\n\t * js\n * | a  c  tx |\n * | b  d  ty |\n * | 0  0  1  |\n * ts\n * // Create identity matrix\n * const matrix = new Matrix();\n *\n * // Create matrix with custom values\n * const transform = new Matrix(2, 0, 0, 2, 100, 100); // Scale 2x, translate 100,100\n *\n * // Transform a point\n * const point = { x: 10, y: 20 };\n * const transformed = transform.apply(point);\n *\n * // Chain transformations\n * matrix\n *     .translate(100, 50)\n *     .rotate(Math.PI / 4)\n *     .scale(2, 2);\n * \n\t * > array[0] = a  (x scale)\n\t * > array[1] = b  (y skew)\n\t * > array[2] = tx (x translation)\n\t * > array[3] = c  (x skew)\n\t * > array[4] = d  (y scale)\n\t * > array[5] = ty (y translation)\n\t * > ts\n\t * // Create matrix from array\n\t * const matrix = new Matrix();\n\t * matrix.fromArray([\n\t *     2, 0,  100,  // a, b, tx\n\t *     0, 2,  100   // c, d, ty\n\t * ]);\n\t *\n\t * // Create matrix from typed array\n\t * const float32Array = new Float32Array([\n\t *     1, 0, 0,     // Scale x1, no skew\n\t *     0, 1, 0      // No skew, scale x1\n\t * ]);\n\t * matrix.fromArray(float32Array);\n\t * ts\n\t * // Set to identity matrix\n\t * matrix.set(1, 0, 0, 1, 0, 0);\n\t *\n\t * // Set to scale matrix\n\t * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n\t *\n\t * // Set to translation matrix\n\t * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n\t * \n\t * > Non-transposed:\n\t * > [a, c, tx,\n\t * > b, d, ty,\n\t * > 0, 0, 1]\n\t * >\n\t * > Transposed:\n\t * > [a, b, 0,\n\t * > c, d, 0,\n\t * > tx,ty,1]\n\t * > ts\n\t * // Basic array conversion\n\t * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n\t * const array = matrix.toArray();\n\t *\n\t * // Using existing array\n\t * const float32Array = new Float32Array(9);\n\t * matrix.toArray(false, float32Array);\n\t *\n\t * // Get transposed array\n\t * const transposed = matrix.toArray(true);\n\t * ts\n\t * // Basic point transformation\n\t * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n\t * const point = new Point(10, 20);\n\t * const transformed = matrix.apply(point);\n\t *\n\t * // Reuse existing point\n\t * const output = new Point();\n\t * matrix.apply(point, output);\n\t * ts\n\t * // Basic inverse transformation\n\t * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n\t * const worldPoint = new Point(150, 100);\n\t * const localPoint = matrix.applyInverse(worldPoint);\n\t *\n\t * // Reuse existing point\n\t * const output = new Point();\n\t * matrix.applyInverse(worldPoint, output);\n\t *\n\t * // Convert mouse position to local space\n\t * const mousePoint = new Point(mouseX, mouseY);\n\t * const localMouse = matrix.applyInverse(mousePoint);\n\t * ts\n\t * // Basic translation\n\t * const matrix = new Matrix();\n\t * matrix.translate(100, 50); // Move right 100, down 50\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .scale(2, 2)\n\t *     .translate(100, 0)\n\t *     .rotate(Math.PI / 4);\n\t * ts\n\t * // Basic scaling\n\t * const matrix = new Matrix();\n\t * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .translate(100, 100)\n\t *     .scale(2, 2)     // Scales after translation\n\t *     .rotate(Math.PI / 4);\n\t * ts\n\t * // Basic rotation\n\t * const matrix = new Matrix();\n\t * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n\t *\n\t * // Chain with other transformations\n\t * matrix\n\t *     .translate(100, 100) // Move to rotation center\n\t *     .rotate(Math.PI)     // Rotate 180 degrees\n\t *     .scale(2, 2);        // Scale after rotation\n\t *\n\t * // Common angles\n\t * matrix.rotate(Math.PI / 2);  // 90 degrees\n\t * matrix.rotate(Math.PI);      // 180 degrees\n\t * matrix.rotate(Math.PI * 2);  // 360 degrees\n\t * ts\n\t * // Basic matrix combination\n\t * const matrix = new Matrix();\n\t * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n\t * matrix.append(other);\n\t * ts\n\t * // Basic matrix multiplication\n\t * const result = new Matrix();\n\t * const matrixA = new Matrix().scale(2, 2);\n\t * const matrixB = new Matrix().rotate(Math.PI / 4);\n\t * result.appendFrom(matrixA, matrixB);\n\t * ts\n\t * // Basic transform setup\n\t * const matrix = new Matrix();\n\t * matrix.setTransform(\n\t *     100, 100,    // position\n\t *     0, 0,        // pivot\n\t *     2, 2,        // scale\n\t *     Math.PI / 4, // rotation (45 degrees)\n\t *     0, 0         // skew\n\t * );\n\t * ts\n\t * // Basic matrix prepend\n\t * const matrix = new Matrix().scale(2, 2);\n\t * const other = new Matrix().translate(100, 0);\n\t * matrix.prepend(other); // Translation happens before scaling\n\t * ts\n\t * // Basic decomposition\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * const transform = {\n\t *     position: new Point(),\n\t *     scale: new Point(),\n\t *     pivot: new Point(),\n\t *     skew: new Point(),\n\t *     rotation: 0\n\t * };\n\t *\n\t * matrix.decompose(transform);\n\t * console.log(transform.position); // Point(100, 100)\n\t * console.log(transform.rotation); // ~0.785 (PI/4)\n\t * console.log(transform.scale); // Point(2, 2)\n\t * ts\n\t * // Basic matrix inversion\n\t * const matrix = new Matrix()\n\t *     .translate(100, 50)\n\t *     .scale(2, 2);\n\t *\n\t * matrix.invert(); // Now transforms in opposite direction\n\t *\n\t * // Verify inversion\n\t * const point = new Point(50, 50);\n\t * const transformed = matrix.apply(point);\n\t * const original = matrix.invert().apply(transformed);\n\t * // original â‰ˆ point\n\t * ts\n\t * // Check if matrix is identity\n\t * const matrix = new Matrix();\n\t * console.log(matrix.isIdentity()); // true\n\t *\n\t * // Check after transformations\n\t * matrix.translate(100, 0);\n\t * console.log(matrix.isIdentity()); // false\n\t *\n\t * // Reset and verify\n\t * matrix.identity();\n\t * console.log(matrix.isIdentity()); // true\n\t * ts\n\t * // Reset transformed matrix\n\t * const matrix = new Matrix()\n\t *     .scale(2, 2)\n\t *     .rotate(Math.PI / 4);\n\t * matrix.identity(); // Back to default state\n\t *\n\t * // Chain after reset\n\t * matrix\n\t *     .identity()\n\t *     .translate(100, 100)\n\t *     .scale(2, 2);\n\t *\n\t * // Compare with identity constant\n\t * const isDefault = matrix.equals(Matrix.IDENTITY);\n\t * ts\n\t * // Basic matrix cloning\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t * const copy = matrix.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = matrix.clone()\n\t *     .scale(2, 2);\n\t *\n\t * // Compare matrices\n\t * console.log(matrix.equals(copy));     // true\n\t * console.log(matrix.equals(modified)); // false\n\t * ts\n\t * // Basic matrix copying\n\t * const source = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t * const target = new Matrix();\n\t * target.copyFrom(source);\n\t * ts\n\t * // Basic equality check\n\t * const m1 = new Matrix();\n\t * const m2 = new Matrix();\n\t * console.log(m1.equals(m2)); // true\n\t *\n\t * // Compare transformed matrices\n\t * const transform = new Matrix()\n\t *     .translate(100, 100)\n\t * const clone = new Matrix()\n\t *     .scale(2, 2);\n\t * console.log(transform.equals(clone)); // false\n\t * ts\n\t * // Get identity matrix reference\n\t * const identity = Matrix.IDENTITY;\n\t * console.log(identity.isIdentity()); // true\n\t *\n\t * // Compare with identity\n\t * const matrix = new Matrix();\n\t * console.log(matrix.equals(Matrix.IDENTITY)); // true\n\t *\n\t * // Create new matrix instead of modifying IDENTITY\n\t * const transform = new Matrix()\n\t *     .copyFrom(Matrix.IDENTITY)\n\t *     .translate(100, 100);\n\t * ts\n\t * // Use for temporary calculations\n\t * const tempMatrix = Matrix.shared;\n\t * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n\t * const point = tempMatrix.apply({ x: 10, y: 20 });\n\t *\n\t * // Will be reset to identity on next access\n\t * const fresh = Matrix.shared; // Back to identity\n\t * ts\n * // Basic observer implementation\n * const observer: Observer<ObservablePoint> = {\n *     _onUpdate: (point) => {\n *         console.log(`Point updated to (${point.x}, ${point.y})`);\n *     }\n * };\n *\n * // Create observable point with observer\n * const point = new ObservablePoint(observer, 100, 100);\n *\n * // Observer will be notified on changes\n * point.x = 200; // Logs: Point updated to (200, 100)\n * ts\n * // Basic observable point usage\n * const point = new ObservablePoint(\n *     { _onUpdate: (p) => console.log(`Updated to (${p.x}, ${p.y})`) },\n *     100, 100\n * );\n *\n * // Update triggers callback\n * point.x = 200; // Logs: Updated to (200, 100)\n * point.y = 300; // Logs: Updated to (200, 300)\n *\n * // Set both coordinates\n * point.set(50, 50); // Logs: Updated to (50, 50)\n * ts\n\t * // Basic cloning\n\t * const point = new ObservablePoint(observer, 100, 200);\n\t * const copy = point.clone();\n\t *\n\t * // Clone with new observer\n\t * const newObserver = {\n\t *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n\t * };\n\t * const watched = point.clone(newObserver);\n\t *\n\t * // Verify independence\n\t * watched.set(300, 400); // Only triggers new observer\n\t * ts\n\t * // Basic position setting\n\t * const point = new ObservablePoint(observer);\n\t * point.set(100, 200);\n\t *\n\t * // Set both x and y to same value\n\t * point.set(50); // x=50, y=50\n\t * ts\n\t * // Basic copying\n\t * const source = new ObservablePoint(observer, 100, 200);\n\t * const target = new ObservablePoint();\n\t * target.copyFrom(source);\n\t *\n\t * // Copy and chain operations\n\t * const point = new ObservablePoint()\n\t *     .copyFrom(source)\n\t *     .set(x + 50, y + 50);\n\t *\n\t * // Copy from any PointData\n\t * const data = { x: 10, y: 20 };\n\t * point.copyFrom(data);\n\t * ts\n\t * // Basic copying\n\t * const source = new ObservablePoint(100, 200);\n\t * const target = new ObservablePoint();\n\t * source.copyTo(target);\n\t * ts\n\t * // Basic equality check\n\t * const p1 = new ObservablePoint(100, 200);\n\t * const p2 = new ObservablePoint(100, 200);\n\t * console.log(p1.equals(p2)); // true\n\t *\n\t * // Compare with PointData\n\t * const data = { x: 100, y: 200 };\n\t * console.log(p1.equals(data)); // true\n\t *\n\t * // Check different points\n\t * const p3 = new ObservablePoint(200, 300);\n\t * console.log(p1.equals(p3)); // false\n\t * ts\n\t * // Basic x position\n\t * const point = new ObservablePoint(observer);\n\t * point.x = 100; // Triggers observer\n\t *\n\t * // Use in calculations\n\t * const width = rightPoint.x - leftPoint.x;\n\t * ts\n\t * // Basic y position\n\t * const point = new ObservablePoint(observer);\n\t * point.y = 200; // Triggers observer\n\t *\n\t * // Use in calculations\n\t * const height = bottomPoint.y - topPoint.y;\n\t * ts\n * // Create bounds data\n * const bounds: BoundsData = {\n *     minX: 0,\n *     minY: 0,\n *     maxX: 100,\n *     maxY: 100\n * };\n *\n * // Calculate dimensions\n * const width = bounds.maxX - bounds.minX;\n * const height = bounds.maxY - bounds.minY;\n *\n * // Check if point is inside\n * const isInside = (x: number, y: number) =>\n *     x >= bounds.minX && x <= bounds.maxX &&\n *     y >= bounds.minY && y <= bounds.maxY;\n * ts\n * // Create bounds\n * const bounds = new Bounds();\n *\n * // Add a rectangular frame\n * bounds.addFrame(0, 0, 100, 100);\n * console.log(bounds.width, bounds.height); // 100, 100\n *\n * // Transform bounds\n * const matrix = new Matrix()\n *     .translate(50, 50)\n *     .rotate(Math.PI / 4);\n * bounds.applyMatrix(matrix);\n *\n * // Check point intersection\n * if (bounds.containsPoint(75, 75)) {\n *     console.log('Point is inside bounds!');\n * }\n * ts\n\t * const bounds = new Bounds();\n\t * // Set left edge\n\t * bounds.minX = 100;\n\t * ts\n\t * const bounds = new Bounds();\n\t * // Set top edge\n\t * bounds.minY = 100;\n\t * ts\n\t * const bounds = new Bounds();\n\t * // Set right edge\n\t * bounds.maxX = 200;\n\t * // Get width\n\t * const width = bounds.maxX - bounds.minX;\n\t * ts\n\t * const bounds = new Bounds();\n\t * // Set bottom edge\n\t * bounds.maxY = 200;\n\t * // Get height\n\t * const height = bounds.maxY - bounds.minY;\n\t * ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Check if newly created bounds are empty\n\t * console.log(bounds.isEmpty()); // true, default bounds are empty\n\t *\n\t * // Add frame and check again\n\t * bounds.addFrame(0, 0, 100, 100);\n\t * console.log(bounds.isEmpty()); // false, bounds now have area\n\t *\n\t * // Clear bounds\n\t * bounds.clear();\n\t * console.log(bounds.isEmpty()); // true, bounds are empty again\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Get rectangle representation\n\t * const rect = bounds.rectangle;\n\t * console.log(rect.x, rect.y, rect.width, rect.height);\n\t *\n\t * // Use for hit testing\n\t * if (bounds.rectangle.contains(mouseX, mouseY)) {\n\t *     console.log('Mouse is inside bounds!');\n\t * }\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.isEmpty()); // false\n\t * // Clear the bounds\n\t * bounds.clear();\n\t * console.log(bounds.isEmpty()); // true\n\t * ts\n\t * const bounds = new Bounds();\n\t * bounds.set(0, 0, 100, 100);\n\t * ts\n\t * const bounds = new Bounds();\n\t * bounds.addFrame(0, 0, 100, 100);\n\t *\n\t * // Add transformed frame\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addFrame(0, 0, 100, 100, matrix);\n\t * ts\n\t * const bounds = new Bounds();\n\t * // Add simple rectangle\n\t * const rect = new Rectangle(0, 0, 100, 100);\n\t * bounds.addRect(rect);\n\t *\n\t * // Add transformed rectangle\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addRect(rect, matrix);\n\t * ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Add child bounds\n\t * const childBounds = sprite.getBounds();\n\t * bounds.addBounds(childBounds);\n\t *\n\t * // Add transformed bounds\n\t * const matrix = new Matrix()\n\t *     .scale(2, 2);\n\t * bounds.addBounds(childBounds, matrix);\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Create mask bounds\n\t * const mask = new Bounds();\n\t * mask.addFrame(50, 50, 150, 150);\n\t * // Apply mask - results in bounds of (50,50,100,100)\n\t * bounds.addBoundsMask(mask);\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Apply translation\n\t * const translateMatrix = new Matrix()\n\t *     .translate(50, 50);\n\t * bounds.applyMatrix(translateMatrix);\n\t * ts\n\t * const bounds = new Bounds(0, 0, 200, 200);\n\t * // Fit within viewport\n\t * const viewport = new Rectangle(50, 50, 100, 100);\n\t * bounds.fit(viewport);\n\t * // bounds are now (50, 50, 150, 150)\n\t * ts\n\t * const bounds = new Bounds(0, 0, 200, 200);\n\t * // Fit to specific coordinates\n\t * bounds.fitBounds(50, 150, 50, 150);\n\t * // bounds are now (50, 50, 150, 150)\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Add equal padding\n\t * bounds.pad(10);\n\t * // bounds are now (-10, -10, 110, 110)\n\t *\n\t * // Add different padding for x and y\n\t * bounds.pad(20, 10);\n\t * // bounds are now (-30, -20, 130, 120)\n\t * ts\n\t * const bounds = new Bounds();\n\t * bounds.set(10.2, 10.9, 50.1, 50.8);\n\t *\n\t * // Round to whole pixels\n\t * bounds.ceil();\n\t * // bounds are now (10, 10, 51, 51)\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Create a copy\n\t * const copy = bounds.clone();\n\t *\n\t * // Original and copy are independent\n\t * bounds.pad(10);\n\t * console.log(copy.width === bounds.width); // false\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t *\n\t * // Scale uniformly\n\t * bounds.scale(2);\n\t * // bounds are now (0, 0, 200, 200)\n\t *\n\t * // Scale non-uniformly\n\t * bounds.scale(0.5, 2);\n\t * // bounds are now (0, 0, 100, 400)\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get x position\n\t * console.log(bounds.x); // 0\n\t *\n\t * // Move bounds horizontally\n\t * bounds.x = 50;\n\t * console.log(bounds.minX, bounds.maxX); // 50, 150\n\t *\n\t * // Width stays the same\n\t * console.log(bounds.width); // Still 100\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get y position\n\t * console.log(bounds.y); // 0\n\t *\n\t * // Move bounds vertically\n\t * bounds.y = 50;\n\t * console.log(bounds.minY, bounds.maxY); // 50, 150\n\t *\n\t * // Height stays the same\n\t * console.log(bounds.height); // Still 100\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get width\n\t * console.log(bounds.width); // 100\n\t * // Resize width\n\t * bounds.width = 200;\n\t * console.log(bounds.maxX - bounds.minX); // 200\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Get height\n\t * console.log(bounds.height); // 100\n\t * // Resize height\n\t * bounds.height = 150;\n\t * console.log(bounds.maxY - bounds.minY); // 150\n\t * ts\n\t * const bounds = new Bounds(50, 0, 150, 100);\n\t * console.log(bounds.left); // 50\n\t * console.log(bounds.left === bounds.minX); // true\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.right); // 100\n\t * console.log(bounds.right === bounds.maxX); // true\n\t * ts\n\t * const bounds = new Bounds(0, 25, 100, 125);\n\t * console.log(bounds.top); // 25\n\t * console.log(bounds.top === bounds.minY); // true\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 200);\n\t * console.log(bounds.bottom); // 200\n\t * console.log(bounds.bottom === bounds.maxY); // true\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Check if bounds are positive\n\t * console.log(bounds.isPositive); // true\n\t *\n\t * // Negative bounds\n\t * bounds.maxX = bounds.minX;\n\t * console.log(bounds.isPositive); // false, width is 0\n\t * ts\n\t * const bounds = new Bounds();\n\t * console.log(bounds.isValid); // false, default state\n\t *\n\t * // Set valid bounds\n\t * bounds.addFrame(0, 0, 100, 100);\n\t * console.log(bounds.isValid); // true\n\t * ts\n\t * const bounds = new Bounds();\n\t *\n\t * // Add vertices from geometry\n\t * const vertices = new Float32Array([\n\t *     0, 0,    // Vertex 1\n\t *     100, 0,  // Vertex 2\n\t *     100, 100 // Vertex 3\n\t * ]);\n\t * bounds.addVertexData(vertices, 0, 6);\n\t *\n\t * // Add transformed vertices\n\t * const matrix = new Matrix()\n\t *     .translate(50, 50)\n\t *     .rotate(Math.PI / 4);\n\t * bounds.addVertexData(vertices, 0, 6, matrix);\n\t *\n\t * // Add subset of vertices\n\t * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * // Basic point check\n\t * console.log(bounds.containsPoint(50, 50)); // true\n\t * console.log(bounds.containsPoint(150, 150)); // false\n\t *\n\t * // Check edges\n\t * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n\t * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n\t * ts\n\t * const bounds = new Bounds(0, 0, 100, 100);\n\t * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n\t * ts\n\t * const sourceBounds = new Bounds(0, 0, 100, 100);\n\t * // Copy bounds\n\t * const targetBounds = new Bounds();\n\t * targetBounds.copyFrom(sourceBounds);\n\t * ts\n * // Basic rectangle creation\n * const rect = new Rectangle(100, 100, 200, 150);\n *\n * // Use as container bounds\n * container.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n *\n * // Manipulate dimensions\n * rect.width *= 2;\n * rect.height += 50;\n * ts\n\t * // Check shape type\n\t * const shape = new Rectangle(0, 0, 100, 100);\n\t * console.log(shape.type); // 'rectangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'rectangle') {\n\t *     console.log(shape.width, shape.height);\n\t * }\n\t * ts\n\t * // Basic x position\n\t * const rect = new Rectangle();\n\t * rect.x = 100;\n\t * ts\n\t * // Basic y position\n\t * const rect = new Rectangle();\n\t * rect.y = 100;\n\t * ts\n\t * // Basic width setting\n\t * const rect = new Rectangle();\n\t * rect.width = 200;\n\t * ts\n\t * // Basic height setting\n\t * const rect = new Rectangle();\n\t * rect.height = 150;\n\t * ts\n\t * // Get left edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.left); // 100\n\t *\n\t * // Use in alignment calculations\n\t * sprite.x = rect.left + padding;\n\t *\n\t * // Compare positions\n\t * if (point.x > rect.left) {\n\t *     console.log('Point is right of rectangle');\n\t * }\n\t * ts\n\t * // Get right edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.right); // 300\n\t *\n\t * // Align to right edge\n\t * sprite.x = rect.right - sprite.width;\n\t *\n\t * // Check boundaries\n\t * if (point.x < rect.right) {\n\t *     console.log('Point is inside right bound');\n\t * }\n\t * ts\n\t * // Get top edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.top); // 100\n\t *\n\t * // Position above rectangle\n\t * sprite.y = rect.top - sprite.height;\n\t *\n\t * // Check vertical position\n\t * if (point.y > rect.top) {\n\t *     console.log('Point is below top edge');\n\t * }\n\t * ts\n\t * // Get bottom edge position\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * console.log(rect.bottom); // 250\n\t *\n\t * // Stack below rectangle\n\t * sprite.y = rect.bottom + margin;\n\t *\n\t * // Check vertical bounds\n\t * if (point.y < rect.bottom) {\n\t *     console.log('Point is above bottom edge');\n\t * }\n\t * ts\n\t * // Check zero dimensions\n\t * const rect = new Rectangle(100, 100, 0, 50);\n\t * console.log(rect.isEmpty()); // true\n\t * ts\n\t * // Get fresh empty rectangle\n\t * const empty = Rectangle.EMPTY;\n\t * console.log(empty.isEmpty()); // true\n\t * ts\n\t * // Basic cloning\n\t * const original = new Rectangle(100, 100, 200, 150);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.width *= 2;\n\t * modified.height += 50;\n\t *\n\t * // Verify independence\n\t * console.log(original.width);  // 200\n\t * console.log(modified.width);  // 400\n\t * ts\n\t * // Convert bounds to rectangle\n\t * const bounds = container.getBounds();\n\t * const rect = new Rectangle().copyFromBounds(bounds);\n\t * ts\n\t * // Basic copying\n\t * const source = new Rectangle(100, 100, 200, 150);\n\t * const target = new Rectangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const rect = new Rectangle()\n\t *     .copyFrom(source)\n\t *     .pad(10);\n\t * ts\n\t * // Basic copying\n\t * const source = new Rectangle(100, 100, 200, 150);\n\t * const target = new Rectangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new Rectangle())\n\t *     .getBounds();\n\t * ts\n\t * // Basic containment check\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const isInside = rect.contains(150, 125); // true\n\t * // Check edge cases\n\t * console.log(rect.contains(100, 100)); // true (on edge)\n\t * console.log(rect.contains(300, 250)); // false (outside)\n\t * ts\n\t * // Basic stroke check\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n\t * ts\n\t * // Basic intersection check\n\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t * console.log(rect1.intersects(rect2)); // true\n\t *\n\t * // With transformation matrix\n\t * const matrix = new Matrix();\n\t * matrix.rotate(Math.PI / 4); // 45 degrees\n\t * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation\n\t *\n\t * // Edge cases\n\t * const zeroWidth = new Rectangle(0, 0, 0, 100);\n\t * console.log(rect1.intersects(zeroWidth)); // false (no area)\n\t * ts\n\t * // Basic padding\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * rect.pad(10); // Adds 10px padding on all sides\n\t *\n\t * // Different horizontal and vertical padding\n\t * const uiRect = new Rectangle(0, 0, 100, 50);\n\t * uiRect.pad(20, 10); // 20px horizontal, 10px vertical\n\t * ts\n\t * // Basic fitting\n\t * const container = new Rectangle(0, 0, 100, 100);\n\t * const content = new Rectangle(25, 25, 200, 200);\n\t * content.fit(container); // Clips to container bounds\n\t * ts\n\t * // Basic grid alignment\n\t * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);\n\t * rect.ceil(); // Aligns to whole pixels\n\t *\n\t * // Custom resolution grid\n\t * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);\n\t * uiRect.ceil(0.5); // Aligns to half pixels\n\t *\n\t * // Use with precision value\n\t * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);\n\t * preciseRect.ceil(1, 0.01); // Handles small decimal variations\n\t * ts\n\t * const rect = new Rectangle(50, 50, 100, 100);\n\t *\n\t * // Scale uniformly\n\t * rect.scale(0.5, 0.5);\n\t * // rect is now: x=25, y=25, width=50, height=50\n\t *\n\t * // non-uniformly\n\t * rect.scale(0.5, 1);\n\t * // rect is now: x=25, y=50, width=50, height=100\n\t * ts\n\t * // Basic enlargement\n\t * const rect = new Rectangle(50, 50, 100, 100);\n\t * const other = new Rectangle(0, 0, 200, 75);\n\t * rect.enlarge(other);\n\t * // rect is now: x=0, y=0, width=200, height=150\n\t *\n\t * // Use for bounding box calculation\n\t * const bounds = new Rectangle();\n\t * objects.forEach((obj) => {\n\t *     bounds.enlarge(obj.getBounds());\n\t * });\n\t * ts\n\t * // Basic bounds retrieval\n\t * const rect = new Rectangle(100, 100, 200, 150);\n\t * const bounds = rect.getBounds();\n\t *\n\t * // Reuse existing rectangle\n\t * const out = new Rectangle();\n\t * rect.getBounds(out);\n\t * ts\n\t * // Check if one rectangle contains another\n\t * const container = new Rectangle(0, 0, 100, 100);\n\t * const inner = new Rectangle(25, 25, 50, 50);\n\t *\n\t * console.log(container.containsRect(inner)); // true\n\t *\n\t * // Check overlapping rectangles\n\t * const partial = new Rectangle(75, 75, 50, 50);\n\t * console.log(container.containsRect(partial)); // false\n\t *\n\t * // Zero-area rectangles\n\t * const empty = new Rectangle(0, 0, 0, 100);\n\t * console.log(container.containsRect(empty)); // false\n\t * ts\n\t * // Basic usage\n\t * const rect = new Rectangle();\n\t * rect.set(100, 100, 200, 150);\n\t *\n\t * // Chain with other operations\n\t * const bounds = new Rectangle()\n\t *     .set(0, 0, 100, 100)\n\t *     .pad(10);\n\t * ts\n * // Basic destruction - only this container\n * container.destroy({ children: false });\n *\n * // Deep destruction - container and all children\n * container.destroy({ children: true });\n *\n * // Cleanup pattern\n * function cleanupScene(scene: Container) {\n *     // Remove from parent first\n *     scene.parent?.removeChild(scene);\n *     // Then destroy with all children\n *     scene.destroy({ children: true });\n * }\n * js\n\t * container.destroy({ children: true });\n\t * ts\n * // Basic texture cleanup\n * sprite.destroy({\n *     texture: true\n * });\n *\n * // Complete texture cleanup\n * sprite.destroy({\n *     texture: true,\n *     textureSource: true\n * });\n * js\n\t * texturedObject.destroy({ texture: true });\n\t * js\n\t * texturedObject.destroy({ textureSource: true });\n\t * ts\n * // Basic context cleanup\n * graphics.destroy({\n *     context: true\n * });\n *\n * // Full graphics cleanup\n * graphics.destroy({\n *     context: true,\n *     texture: true,\n *     textureSource: true\n * });\n * js\n\t * graphics.destroy({ context: true });\n\t * ts\n * // Basic text cleanup\n * text.destroy({ style: false }); // Keep style for reuse\n * text.destroy({ style: true }); // Destroy style as well\n * ts\n * // Destroy the container and all its children, including textures and styles\n * container.destroy({\n *     children: true,\n *     texture: true,\n *     textureSource: true,\n *     context: true,\n *     style: true\n * });\n * ts\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // Register a simple object extension\n * extensions.add({\n *   extension: {\n *       type: ExtensionType.LoadParser,\n *       name: 'my-loader',\n *       priority: 100, // Optional priority for ordering\n *   },\n *   // add load parser functions\n * });\n *\n * // Register a class-based extension\n * class MyRendererPlugin {\n *     static extension = {\n *         type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n *         name: 'myRendererPlugin'\n *     };\n *\n *    // add renderer plugin methods\n * }\n * extensions.add(MyRendererPlugin);\n *\n * // Remove extensions\n * extensions.remove(MyRendererPlugin);\n * ts\n\t * // Remove a single extension\n\t * extensions.remove(MyRendererPlugin);\n\t *\n\t * // Remove multiple extensions\n\t * extensions.remove(\n\t *     MyRendererPlugin,\n\t *     MySystemPlugin\n\t * );\n\t * ts\n\t * // Register a simple extension\n\t * extensions.add(MyRendererPlugin);\n\t *\n\t * // Register multiple extensions\n\t * extensions.add(\n\t *     MyRendererPlugin,\n\t *     MySystemPlugin,\n\t * });\n\t * ts\n\t * // Create a mixin with shared properties\n\t * const moveable = {\n\t *     x: 0,\n\t *     y: 0,\n\t *     move(x: number, y: number) {\n\t *         this.x += x;\n\t *         this.y += y;\n\t *     }\n\t * };\n\t *\n\t * // Create a mixin with computed properties\n\t * const scalable = {\n\t *     scale: 1,\n\t *     get scaled() {\n\t *         return this.scale > 1;\n\t *     }\n\t * };\n\t *\n\t * // Apply mixins to a class\n\t * extensions.mixin(Sprite, moveable, scalable);\n\t *\n\t * // Use mixed-in properties\n\t * const sprite = new Sprite();\n\t * sprite.move(10, 20);\n\t * console.log(sprite.x, sprite.y); // 10, 20\n\t * js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Assets.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ts\n\t * // Basic usage with a container\n\t * const container = new Container();\n\t * container.addChild(\n\t *     new Graphics()\n\t *         .circle(0, 0, 50)\n\t *         .fill('red')\n\t * );\n\t *\n\t * const texture = renderer.textureGenerator.generateTexture(container);\n\t *\n\t * // Advanced usage with options\n\t * const texture = renderer.textureGenerator.generateTexture({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n\t *     resolution: 2,                        // High DPI\n\t *     clearColor: '#ff0000',               // Red background\n\t *     antialias: true                      // Smooth edges\n\t * });\n\t *\n\t * // Create a sprite from the generated texture\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Clean up when done\n\t * texture.destroy(true);\n\t * ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ts\n\t * // Create a sprite with a texture\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t * ts\n\t * // Centered anchor\n\t * anchor: 0.5\n\t * // Separate x/y anchor\n\t * anchor: { x: 0.5, y: 0.5 }\n\t * // Right-aligned anchor\n\t * anchor: { x: 1, y: 0 }\n\t * ts\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('sprite.png'),\n\t *     roundPixels: true // Ensures crisp rendering\n\t * });\n\t * ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ts\n\t * // Create from path or URL\n\t * const sprite = Sprite.from('assets/image.png');\n\t *\n\t * // Create from existing texture\n\t * const sprite = Sprite.from(texture);\n\t *\n\t * // Create from canvas\n\t * const canvas = document.createElement('canvas');\n\t * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n\t * ts\n\t * // Create sprite with texture\n\t * const sprite = new Sprite({\n\t *     texture: Texture.from('sprite.png')\n\t * });\n\t *\n\t * // Update texture\n\t * sprite.texture = Texture.from('newSprite.png');\n\t *\n\t * // Use texture from spritesheet\n\t * const sheet = await Assets.load('spritesheet.json');\n\t * sprite.texture = sheet.textures['frame1.png'];\n\t *\n\t * // Reset to empty texture\n\t * sprite.texture = Texture.EMPTY;\n\t * ts\n\t * const texture = new Texture({\n\t *     source: new TextureSource({ width: 300, height: 300 }),\n\t *     frame: new Rectangle(196, 66, 58, 56),\n\t *     trim: new Rectangle(4, 4, 58, 56),\n\t *     orig: new Rectangle(0, 0, 64, 64),\n\t *     rotate: 2,\n\t * });\n\t * const sprite = new Sprite(texture);\n\t * const visualBounds = sprite.visualBounds;\n\t * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n\t */\n\tget visualBounds(): BoundsData;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * sprite.destroy();\n\t * sprite.destroy(true);\n\t * sprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * \n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * \n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n\t * @example\n\t * \n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n\t * This is faster than getting width and height separately as it only calculates the bounds once.\n\t * @example\n\t * \n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the Sprite\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Sets the size of the Sprite to the specified width and height.\n\t * This is faster than setting width and height separately as it only recalculates bounds once.\n\t * @example\n\t * \n\t * @param value - This can be either a number or a {@link Size} object\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n}\ntype OPTIONAL_SPACE = \" \" | \"\";\ntype FLOPS<T = UniformData> = T extends {\n\tvalue: infer V;\n} ? V : never;\ninterface System$1 {\n\textension: {\n\t\tname: string;\n\t};\n\tdefaultOptions?: any;\n\tnew (...args: any): any;\n}\ntype SystemsWithExtensionList = System$1[];\ntype InstanceType$1<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;\ntype NameType<T extends SystemsWithExtensionList> = T[number][\"extension\"][\"name\"];\ntype NotUnknown<T> = T extends unknown ? keyof T extends never ? never : T : T;\ntype KnownProperties<T> = {\n\t[K in keyof T as NotUnknown<T[K]> extends never ? never : K]: T[K];\n};\ntype FlattenOptions<T> = T extends {\n\t[K: string]: infer U;\n} ? U : never;\ntype OptionsUnion<T extends SystemsWithExtensionList> = FlattenOptions<SeparateOptions<T>>;\ntype DefaultOptionsTypes<T extends SystemsWithExtensionList> = {\n\t[K in NameType<T>]: Extract<T[number], {\n\t\textension: {\n\t\t\tname: K;\n\t\t};\n\t}>[\"defaultOptions\"];\n};\ntype SeparateOptions<T extends SystemsWithExtensionList> = KnownProperties<DefaultOptionsTypes<T>>;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\ntype MaskMode = \"pushMaskBegin\" | \"pushMaskEnd\" | \"popMaskBegin\" | \"popMaskEnd\";\ndeclare class AlphaMaskEffect extends FilterEffect implements PoolItem {\n\tconstructor();\n\tget sprite(): Sprite;\n\tset sprite(value: Sprite);\n\tget inverse(): boolean;\n\tset inverse(value: boolean);\n\tinit: () => void;\n}\ninterface MaskConversionTest {\n\ttest: (item: any) => boolean;\n\tmaskClass: new (item: any) => Effect & PoolItem;\n}\ntype MaskMode$1 = \"pushMaskBegin\" | \"pushMaskEnd\" | \"popMaskBegin\" | \"popMaskEnd\";\ninterface EnsurePrecisionOptions {\n\trequestedVertexPrecision: PRECISION;\n\trequestedFragmentPrecision: PRECISION;\n\tmaxSupportedVertexPrecision: PRECISION;\n\tmaxSupportedFragmentPrecision: PRECISION;\n}\ninterface AdvancedBlendInstruction extends Instruction {\n\trenderPipeId: \"blendMode\";\n\tblendMode: BLEND_MODES;\n\tactiveBlend: Renderable[];\n}\ndeclare const imageTypes: {\n\tpng: string;\n\tjpg: string;\n\twebp: string;\n};\ntype Formats = keyof typeof imageTypes;\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * \n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n */\nexport declare class ExtractSystem implements System {\n\t/**\n\t * Default options for image extraction.\n\t * @example\n\t * \n\t */\n\tstatic defaultImageOptions: ImageOptions;\n\t/** @param renderer - The renderer this System works for. */\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Creates an IImage from a display object or texture.\n\t * @param options - Options for creating the image, or the target to extract\n\t * @returns Promise that resolves with the generated IImage\n\t * @example\n\t * \n\t */\n\timage(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>;\n\t/**\n\t * Converts the target into a base64 encoded string.\n\t *\n\t * This method works by first creating\n\t * a canvas using `Extract.canvas` and then converting it to a base64 string.\n\t * @param options - The options for creating the base64 string, or the target to extract\n\t * @returns Promise that resolves with the base64 encoded string\n\t * @example\n\t * \n\t * @throws Will throw an error if the platform doesn't support any of:\n\t * - ICanvas.toDataURL\n\t * - ICanvas.toBlob\n\t * - ICanvas.convertToBlob\n\t */\n\tbase64(options: ExtractImageOptions | Container | Texture): Promise<string>;\n\t/**\n\t * Creates a Canvas element, renders the target to it and returns it.\n\t * This method is useful for creating static images or when you need direct canvas access.\n\t * @param options - The options for creating the canvas, or the target to extract\n\t * @returns A Canvas element with the texture rendered on\n\t * @example\n\t * \n\t */\n\tcanvas(options: ExtractOptions | Container | Texture): ICanvas;\n\t/**\n\t * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n\t * with integer values between 0 and 255 (inclusive).\n\t * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n\t * @param options - The options for extracting the image, or the target to extract\n\t * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n\t * @example\n\t * \n\t */\n\tpixels(options: ExtractOptions | Container | Texture): GetPixelsOutput;\n\t/**\n\t * Creates a texture from a display object or existing texture.\n\t *\n\t * This is useful for creating\n\t * reusable textures from rendered content or making copies of existing textures.\n\t * > [!NOTE] The returned texture should be destroyed when no longer needed\n\t * @param options - The options for creating the texture, or the target to extract\n\t * @returns A new texture containing the extracted content\n\t * @example\n\t * \n\t */\n\ttexture(options: ExtractOptions | Container | Texture): Texture;\n\t/**\n\t * Extracts and downloads content from the renderer as an image file.\n\t * This is a convenient way to save screenshots or export rendered content.\n\t * > [!NOTE] The download will use PNG format regardless of the filename extension\n\t * @param options - The options for downloading and extracting the image, or the target to extract\n\t * @example\n\t * \n\t */\n\tdownload(options: ExtractDownloadOptions | Container | Texture): void;\n\tdestroy(): void;\n}\ninterface UniformParserDefinition {\n\ttype: UNIFORM_TYPES;\n\ttest(data: UniformData): boolean;\n\tubo?: string;\n\tuboWgsl?: string;\n\tuboStd40?: string;\n\tuniform?: string;\n}\ndeclare const DefaultWebGPUSystems: (typeof BackgroundSystem | typeof GlobalUniformSystem | typeof HelloSystem | typeof ViewSystem | typeof RenderGroupSystem | typeof TextureGCSystem | typeof GenerateTextureSystem | typeof ExtractSystem | typeof RendererInitHook | typeof RenderableGCSystem | typeof SchedulerSystem | typeof GpuUboSystem | typeof GpuEncoderSystem | typeof GpuDeviceSystem | typeof GpuLimitsSystem | typeof GpuBufferSystem | typeof GpuTextureSystem | typeof GpuRenderTargetSystem | typeof GpuShaderSystem | typeof GpuStateSystem | typeof PipelineSystem | typeof GpuColorMaskSystem | typeof GpuStencilSystem | typeof BindGroupSystem)[];\ndeclare const DefaultWebGPUPipes: (typeof BlendModePipe | typeof BatcherPipe | typeof SpritePipe | typeof RenderGroupPipe | typeof AlphaMaskPipe | typeof StencilMaskPipe | typeof ColorMaskPipe | typeof CustomRenderPipe | typeof GpuUniformBatchPipe)[];\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> & PixiMixins.RendererSystems & PixiMixins.WebGPUSystems;\n/**\n * Options for WebGPURenderer.\n */\nexport interface WebGPUOptions extends SharedRendererOptions, ExtractRendererOptions<typeof DefaultWebGPUSystems>, PixiMixins.WebGPUOptions {\n}\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>, WebGPUSystems {\n}\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * \n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * \n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n */\nexport declare class WebGPURenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T> implements WebGPUSystems {\n\t/** The WebGPU Device. */\n\tgpu: GPU$1;\n\tconstructor();\n}\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n */\nexport declare function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>;\n/**\n * Application options supplied to the {@link Application#init} method.\n * These options configure how your PixiJS application behaves.\n * @example\n * \n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions {\n}\nexport interface Application extends PixiMixins.Application {\n}\n/**\n * Convenience class to create a new PixiJS application.\n *\n * The Application class is the main entry point for creating a PixiJS application. It handles the setup of all core\n * components needed to start rendering and managing your game or interactive experience.\n *\n * Key features:\n * - Automatically creates and manages the renderer\n * - Provides a stage (root container) for your display objects\n * - Handles canvas creation and management\n * - Supports plugins for extending functionality\n *   - {@link ResizePlugin} for automatic resizing\n *   - {@link TickerPlugin} for managing frame updates\n *   - {@link CullerPlugin} for culling off-screen objects\n * @example\n * \n * > [!IMPORTANT] From PixiJS v8.0.0, the application must be initialized using the async `init()` method\n * > rather than passing options to the constructor.\n */\nexport declare class Application<R extends Renderer = Renderer> {\n\t/**\n\t * The root display container for your application.\n\t * All visual elements should be added to this container or its children.\n\t * @example\n\t * \n\t */\n\tstage: Container;\n\t/**\n\t * The renderer instance that handles all drawing operations.\n\t *\n\t * Unless specified, it will automatically create a WebGL renderer if available.\n\t * If WebGPU is available and the `preference` is set to `webgpu`, it will create a WebGPU renderer.\n\t * @example\n\t * \n\t */\n\trenderer: R;\n\t/** Create new Application instance */\n\tconstructor();\n\t/** @deprecated since 8.0.0 */\n\tconstructor(options?: Partial<ApplicationOptions>);\n\t/**\n\t * Initializes the PixiJS application with the specified options.\n\t *\n\t * This method must be called after creating a new Application instance.\n\t * @param options - Configuration options for the application and renderer\n\t * @returns A promise that resolves when initialization is complete\n\t * @example\n\t * \n\t */\n\tinit(options?: Partial<ApplicationOptions>): Promise<void>;\n\t/**\n\t * Renders the current stage to the screen.\n\t *\n\t * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call\n\t * this method directly as rendering is handled automatically.\n\t *\n\t * Only use this method if you've disabled the {@link TickerPlugin} or need custom\n\t * render timing control.\n\t * @example\n\t * \n\t */\n\trender(): void;\n\t/**\n\t * Reference to the renderer's canvas element. This is the HTML element\n\t * that displays your application's graphics.\n\t * @type {HTMLCanvasElement}\n\t * @example\n\t * \n\t */\n\tget canvas(): R[\"canvas\"];\n\t/**\n\t * Reference to the renderer's canvas element.\n\t * @type {HTMLCanvasElement}\n\t * @deprecated since 8.0.0\n\t */\n\tget view(): R[\"canvas\"];\n\t/**\n\t * Reference to the renderer's screen rectangle. This represents the visible area of your application.\n\t *\n\t * It's commonly used for:\n\t * - Setting filter areas for full-screen effects\n\t * - Defining hit areas for screen-wide interaction\n\t * - Determining the visible bounds of your application\n\t * @example\n\t * \n\t */\n\tget screen(): Rectangle;\n\t/**\n\t * Destroys the application and all of its resources.\n\t *\n\t * This method should be called when you want to completely\n\t * clean up the application and free all associated memory.\n\t * @param rendererDestroyOptions - Options for destroying the renderer:\n\t *  - `false` or `undefined`: Preserves the canvas element (default)\n\t *  - `true`: Removes the canvas element\n\t *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal\n\t * @param options - Options for destroying the application:\n\t *  - `false` or `undefined`: Basic cleanup (default)\n\t *  - `true`: Complete cleanup including children\n\t *  - Detailed options object:\n\t *    - `children`: Remove children\n\t *    - `texture`: Destroy textures\n\t *    - `textureSource`: Destroy texture sources\n\t *    - `context`: Destroy WebGL context\n\t * @example\n\t * \n\t * > [!WARNING] After calling destroy, the application instance should no longer be used.\n\t * > All properties will be null and further operations will throw errors.\n\t */\n\tdestroy(rendererDestroyOptions?: RendererDestroyOptions, options?: DestroyOptions): void;\n}\ndeclare global {\n\tvar __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n\tvar __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n}\n/**\n * The options for rendering a view.\n */\nexport interface RenderOptions extends ClearOptions {\n\t/** The container to render. */\n\tcontainer: Container;\n\t/** the transform to apply to the container. */\n\ttransform?: Matrix;\n}\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n\t/** Whether to clean up global resource pools/caches */\n\treleaseGlobalResources?: boolean;\n}>;\ndeclare const defaultRunners: readonly [\n\t\"init\",\n\t\"destroy\",\n\t\"contextChange\",\n\t\"resolutionChange\",\n\t\"resetState\",\n\t\"renderEnd\",\n\t\"renderStart\",\n\t\"render\",\n\t\"update\",\n\t\"postrender\",\n\t\"prerender\"\n];\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {\n\t[key in DefaultRunners]: SystemRunner;\n} & {\n\t[K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\ndeclare const DefaultWebGLSystems: (typeof BackgroundSystem | typeof GlobalUniformSystem | typeof HelloSystem | typeof ViewSystem | typeof RenderGroupSystem | typeof TextureGCSystem | typeof GenerateTextureSystem | typeof ExtractSystem | typeof RendererInitHook | typeof RenderableGCSystem | typeof SchedulerSystem | typeof GlUboSystem | typeof GlBackBufferSystem | typeof GlContextSystem | typeof GlLimitsSystem | typeof GlBufferSystem | typeof GlTextureSystem | typeof GlRenderTargetSystem | typeof GlGeometrySystem | typeof GlUniformGroupSystem | typeof GlShaderSystem | typeof GlEncoderSystem | typeof GlStateSystem | typeof GlStencilSystem | typeof GlColorMaskSystem)[];\ndeclare const DefaultWebGLPipes: (typeof BlendModePipe | typeof BatcherPipe | typeof SpritePipe | typeof RenderGroupPipe | typeof AlphaMaskPipe | typeof StencilMaskPipe | typeof ColorMaskPipe | typeof CustomRenderPipe)[];\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n */\nexport type WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems> & PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n/**\n * Options for WebGLRenderer.\n */\nexport interface WebGLOptions extends SharedRendererOptions, ExtractRendererOptions<typeof DefaultWebGLSystems>, PixiMixins.WebGLOptions {\n}\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGLPipes, WebGLOptions, T>, WebGLSystems {\n}\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * \n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * \n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @property {GlUboSystem} ubo - UboSystem instance.\n * @property {GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {GlContextSystem} context - ContextSystem instance.\n * @property {GlBufferSystem} buffer - BufferSystem instance.\n * @property {GlTextureSystem} texture - TextureSystem instance.\n * @property {GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {GlShaderSystem} shader - ShaderSystem instance.\n * @property {GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {GlStateSystem} state - StateSystem instance.\n * @property {GlStencilSystem} stencil - StencilSystem instance.\n * @property {GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n */\nexport declare class WebGLRenderer<T extends ICanvas = HTMLCanvasElement> extends AbstractRenderer<WebGLPipes, WebGLOptions, T> implements WebGLSystems {\n\tgl: GlRenderingContext;\n\tconstructor();\n}\n/**\n * A generic renderer that can be either a WebGL or WebGPU renderer.\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\n/**\n * Options for the renderer.\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {\n}\nexport interface ViewContainer<GPU_DATA extends GPUData = any> extends PixiMixins.ViewContainer, Container {\n\t_gpuData: Record<number, GPU_DATA>;\n}\n/**\n * Options for configuring a RenderLayer. A RenderLayer allows control over rendering order\n * independent of the scene graph hierarchy.\n * @example\n * \n */\nexport interface RenderLayerOptions {\n\t/**\n\t * If true, the layer's children will be sorted by zIndex before rendering.\n\t * If false, you can manually sort the children using sortRenderLayerChildren when needed.\n\t * @default false\n\t * @example\n\t * \n\t */\n\tsortableChildren?: boolean;\n\t/**\n\t * Custom sort function to sort layer children. Default sorts by zIndex.\n\t * @param a - First container to compare\n\t * @param b - Second container to compare\n\t * @returns Negative if a should render before b, positive if b should render before a\n\t * @example\n\t * \n\t * @default (a, b) => a.zIndex - b.zIndex\n\t */\n\tsortFunction?: (a: Container, b: Container) => number;\n}\n/**\n * The RenderLayer API provides a way to control the rendering order of objects independently\n * of their logical parent-child relationships in the scene graph.\n * This allows developers to decouple how objects are transformed\n * (via their logical parent) from how they are rendered on the screen.\n *\n * ### Key Concepts\n *\n * #### RenderLayers Control Rendering Order:\n * - RenderLayers define where in the render stack objects are drawn,\n * but they do not affect an object's transformations (e.g., position, scale, rotation) or logical hierarchy.\n * - RenderLayers can be added anywhere in the scene graph.\n *\n * #### Logical Parenting Remains Unchanged:\n * - Objects still have a logical parent for transformations via addChild.\n * - Assigning an object to a layer does not reparent it.\n *\n * #### Explicit Control:\n * - Developers assign objects to layers using renderLayer.add and remove them using renderLayer.remove.\n * ---\n * ### API Details\n *\n * #### 1. Creating a RenderLayer\n * A RenderLayer is a lightweight object responsible for controlling render order.\n * It has no children or transformations of its own\n * but can be inserted anywhere in the scene graph to define its render position.\n * \n *\n * #### 2. Adding Objects to a Layer\n * Use renderLayer.add to assign an object to a layer.\n * This overrides the object's default render order defined by its logical parent.\n * \n *\n * #### 3. Removing Objects from a Layer\n * To stop an object from being rendered in the layer, use remove.\n * \n * When an object is removed from its logical parent (removeChild), it is automatically removed from the layer.\n *\n * #### 4. Re-Adding Objects to Layers\n * If an object is re-added to a logical parent, it does not automatically reassign itself to the layer.\n * Developers must explicitly reassign it.\n * \n *\n * #### 5. Layer Position in Scene Graph\n * A layer's position in the scene graph determines its render priority relative to other layers and objects.\n * Layers can be inserted anywhere in the scene graph.\n * \n * This is a new API and therefore considered experimental at this stage.\n * While the core is pretty robust, there are still a few tricky issues we need to tackle.\n * However, even with the known issues below, we believe this API is incredibly useful!\n *\n * Known issues:\n *  - Interaction may not work as expected since hit testing does not account for the visual render order created by layers.\n *    For example, if an object is visually moved to the front via a layer, hit testing will still use its original position.\n *  - RenderLayers and their children must all belong to the same renderGroup to work correctly\n */\nexport declare class RenderLayer extends Container {\n\t/**\n\t * Default options for RenderLayer instances. These options control the sorting behavior\n\t * of objects within the render layer.\n\t * @example\n\t * \n\t * @property {boolean} sortableChildren -\n\t * @property {Function} sortFunction -\n\t */\n\tstatic defaultOptions: RenderLayerOptions;\n\t/** Function used to sort layer children if sortableChildren is true */\n\tsortFunction: (a: Container, b: Container) => number;\n\t/**\n\t * The list of objects that this layer is responsible for rendering. Objects in this list maintain\n\t * their original parent in the scene graph but are rendered as part of this layer.\n\t * @example\n\t * \n\t */\n\trenderLayerChildren: Container[];\n\t/**\n\t * Creates a new RenderLayer instance\n\t * @param options - Configuration options for the RenderLayer\n\t * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render\n\t * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex\n\t */\n\tconstructor(options?: RenderLayerOptions);\n\t/**\n\t * Adds one or more Containers to this render layer. The Containers will be rendered as part of this layer\n\t * while maintaining their original parent in the scene graph.\n\t *\n\t * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.\n\t * @example\n\t * \n\t * @param children - The Container(s) to add to this layer. Can be any Container or array of Containers.\n\t * @returns The first child that was added, for method chaining\n\t */\n\tattach<U extends Container[]>(...children: U): U[0];\n\t/**\n\t * Removes one or more Containers from this render layer. The Containers will maintain their\n\t * original parent in the scene graph but will no longer be rendered as part of this layer.\n\t * @example\n\t * \n\t * @param children - The Container(s) to remove from this layer\n\t * @returns The first child that was removed, for method chaining\n\t */\n\tdetach<U extends Container[]>(...children: U): U[0];\n\t/**\n\t * Removes all objects from this render layer. Objects will maintain their\n\t * original parent in the scene graph but will no longer be rendered as part of this layer.\n\t * @example\n\t * \n\t * @returns The RenderLayer instance for method chaining\n\t */\n\tdetachAll(): void;\n\t/**\n\t * Sort the layer's children using the defined sort function. This method allows manual sorting\n\t * of layer children and is automatically called during rendering if sortableChildren is true.\n\t * @example\n\t * \n\t * @returns The RenderLayer instance for method chaining\n\t */\n\tsortRenderLayerChildren(): void;\n}\n/**\n * The type of child that can be added to a {@link Container}.\n * This is a generic type that extends the {@link Container} class.\n */\nexport type ContainerChild = Container;\n/**\n * Events that can be emitted by a Container. These events provide lifecycle hooks and notifications\n * for container state changes.\n * @example\n * \n */\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents {\n\t/**\n\t * Emitted when this container is added to a new container.\n\t * Useful for setting up parent-specific behaviors.\n\t * @param container - The parent container this was added to\n\t * @example\n\t * \n\t */\n\tadded: [\n\t\tcontainer: Container\n\t];\n\t/**\n\t * Emitted when a child is added to this container.\n\t * Useful for tracking container composition changes.\n\t * @param child - The child that was added\n\t * @param container - The container the child was added to (this container)\n\t * @param index - The index at which the child was added\n\t * @example\n\t * \n\t */\n\tchildAdded: [\n\t\tchild: C,\n\t\tcontainer: Container,\n\t\tindex: number\n\t];\n\t/**\n\t * Emitted when this container is removed from its parent.\n\t * Useful for cleanup and state management.\n\t * @param container - The parent container this was removed from\n\t * @example\n\t * \n\t */\n\tremoved: [\n\t\tcontainer: Container\n\t];\n\t/**\n\t * Emitted when a child is removed from this container.\n\t * Useful for cleanup and maintaining container state.\n\t * @param child - The child that was removed\n\t * @param container - The container the child was removed from (this container)\n\t * @param index - The index from which the child was removed\n\t * @example\n\t * \n\t */\n\tchildRemoved: [\n\t\tchild: C,\n\t\tcontainer: Container,\n\t\tindex: number\n\t];\n\t/**\n\t * Emitted when the container is destroyed.\n\t * Useful for final cleanup and resource management.\n\t * @param container - The container that was destroyed\n\t * @example\n\t * \n\t */\n\tdestroyed: [\n\t\tcontainer: Container\n\t];\n}\ntype AnyEvent = {\n\t[K: ({} & string) | ({} & symbol)]: any;\n};\n/**\n * Options for updating the transform of a container.\n */\nexport interface UpdateTransformOptions {\n\tx: number;\n\ty: number;\n\tscaleX: number;\n\tscaleY: number;\n\trotation: number;\n\tskewX: number;\n\tskewY: number;\n\tpivotX: number;\n\tpivotY: number;\n\toriginX: number;\n\toriginY: number;\n}\n/**\n * Constructor options used for `Container` instances.\n * \n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions {\n\t/** @see Container#isRenderGroup */\n\tisRenderGroup?: boolean;\n\t/**\n\t * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n\t *\n\t * Setting to 'normal' will reset to default blending.\n\t * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n\t * @example\n\t * \n\t * @default 'normal'\n\t */\n\tblendMode?: BLEND_MODES;\n\t/**\n\t * The tint applied to the sprite.\n\t *\n\t * This can be any valid {@link ColorSource}.\n\t * @example\n\t * \n\t * @default 0xFFFFFF\n\t */\n\ttint?: ColorSource;\n\t/**\n\t * The opacity of the object relative to its parent's opacity.\n\t * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n\t * @example\n\t * \n\t * @default 1\n\t */\n\talpha?: number;\n\t/**\n\t * The angle of the object in degrees.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * \n\t */\n\tangle?: number;\n\t/**\n\t * The array of children of this container. Each child must be a Container or extend from it.\n\t *\n\t * The array is read-only, but its contents can be modified using Container methods.\n\t * @example\n\t * \n\t */\n\tchildren?: C[];\n\t/**\n\t * The display object container that contains this display object.\n\t * This represents the parent-child relationship in the display tree.\n\t */\n\tparent?: Container;\n\t/**\n\t * Controls whether this object can be rendered. If false the object will not be drawn,\n\t * but the transform will still be updated. This is different from visible, which skips\n\t * transform updates.\n\t * @example\n\t * \n\t * @default true\n\t */\n\trenderable?: boolean;\n\t/**\n\t * The rotation of the object in radians.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * \n\t */\n\trotation?: number;\n\t/**\n\t * The scale factors of this object along the local coordinate axes.\n\t *\n\t * The default scale is (1, 1).\n\t * @example\n\t * \n\t */\n\tscale?: PointData | number;\n\t/**\n\t * The center of rotation, scaling, and skewing for this display object in its local space.\n\t * The `position` is the projection of `pivot` in the parent's local space.\n\t *\n\t * By default, the pivot is the origin (0, 0).\n\t * @example\n\t * \n\t */\n\tpivot?: PointData | number;\n\t/**\n\t * The origin point around which the container rotates and scales.\n\t * Unlike pivot, changing origin will not move the container's position.\n\t * @example\n\t * \n\t */\n\torigin?: PointData | number;\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * \n\t */\n\tposition?: PointData;\n\t/**\n\t * The skew factor for the object in radians. Skewing is a transformation that distorts\n\t * the object by rotating it differently at each point, creating a non-uniform shape.\n\t * @example\n\t * \n\t * @default { x: 0, y: 0 }\n\t */\n\tskew?: PointData;\n\t/**\n\t * The visibility of the object. If false the object will not be drawn,\n\t * and the transform will not be updated.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tvisible?: boolean;\n\t/**\n\t * The position of the container on the x axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.x\n\t * @example\n\t * \n\t */\n\tx?: number;\n\t/**\n\t * The position of the container on the y axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.y\n\t * @example\n\t * \n\t */\n\ty?: number;\n\t/**\n\t * An optional bounds area for this container. Setting this rectangle will stop the renderer\n\t * from recursively measuring the bounds of each children and instead use this single boundArea.\n\t *\n\t * > [!IMPORTANT] This is great for optimisation! If for example you have a\n\t * > 1000 spinning particles and you know they all sit within a specific bounds,\n\t * > then setting it will mean the renderer will not need to measure the\n\t * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n\t * @example\n\t * \n\t */\n\tboundsArea?: Rectangle;\n}\nexport interface Container<C extends ContainerChild> extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {\n}\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link Container#localTransform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         âº and \"skew.y\" is Î², then the line x = 0 will be rotated by âº (y = -x*cotâº) and the line y = 0 will be\n *         rotated by Î² (y = x*tanÎ²). A line y = x*tanÏ´ (i.e. a line at angle Ï´ to the x-axis in local-space) will\n *         be rotated by an angle between âº and Î².\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -Ï´ and \"skew.y\" = Ï´, it will produce an equivalent of \"rotation\" = Ï´.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * \n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJSâ€™s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n */\nexport declare class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent> {\n\t/**\n\t * Mixes all enumerable properties and methods from a source object to Container.\n\t * @param source - The source of properties and methods to mix in.\n\t * @deprecated since 8.8.0\n\t */\n\tstatic mixin(source: Dict<any>): void;\n\t/**\n\t * The array of children of this container. Each child must be a Container or extend from it.\n\t *\n\t * The array is read-only, but its contents can be modified using Container methods.\n\t * @example\n\t * \n\t */\n\tchildren: C[];\n\t/**\n\t * The display object container that contains this display object.\n\t * This represents the parent-child relationship in the display tree.\n\t * @example\n\t * \n\t */\n\tparent: Container | null;\n\t/**\n\t * Current transform of the object based on local factors: position, scale, other stuff.\n\t * This matrix represents the local transformation without any parent influence.\n\t * @example\n\t * \n\t */\n\tlocalTransform: Matrix;\n\t/**\n\t * Whether this object has been destroyed. If true, the object should no longer be used.\n\t * After an object is destroyed, all of its functionality is disabled and references are removed.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * An optional bounds area for this container. Setting this rectangle will stop the renderer\n\t * from recursively measuring the bounds of each children and instead use this single boundArea.\n\t *\n\t * > [!IMPORTANT] This is great for optimisation! If for example you have a\n\t * > 1000 spinning particles and you know they all sit within a specific bounds,\n\t * > then setting it will mean the renderer will not need to measure the\n\t * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n\t * @example\n\t * \n\t */\n\tboundsArea: Rectangle;\n\tconstructor(options?: ContainerOptions<C>);\n\t/**\n\t * Adds one or more children to the container.\n\t * The children will be rendered as part of this container's display list.\n\t * @example\n\t * \n\t * @param children - The Container(s) to add to the container\n\t * @returns The first child that was added\n\t */\n\taddChild<U extends C[]>(...children: U): U[0];\n\t/**\n\t * Removes one or more children from the container.\n\t * When removing multiple children, events will be triggered for each child in sequence.\n\t * @example\n\t * \n\t * @param children - The Container(s) to remove\n\t * @returns The first child that was removed\n\t */\n\tremoveChild<U extends C[]>(...children: U): U[0];\n\tset isRenderGroup(value: boolean);\n\t/**\n\t * Current transform of the object based on world (parent) factors.\n\t *\n\t * This matrix represents the absolute transformation in the scene graph.\n\t * @example\n\t * \n\t */\n\tget worldTransform(): Matrix;\n\t/**\n\t * The position of the container on the x axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.x\n\t * @example\n\t * \n\t */\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * The position of the container on the y axis relative to the local coordinates of the parent.\n\t *\n\t * An alias to position.y\n\t * @example\n\t * \n\t */\n\tget y(): number;\n\tset y(value: number);\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * \n\t * @since 4.0.0\n\t */\n\tget position(): ObservablePoint;\n\tset position(value: PointData);\n\t/**\n\t * The rotation of the object in radians.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * \n\t */\n\tget rotation(): number;\n\tset rotation(value: number);\n\t/**\n\t * The angle of the object in degrees.\n\t *\n\t * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n\t * > rotation is in radians, angle is in degrees.\n\t * @example\n\t * \n\t */\n\tget angle(): number;\n\tset angle(value: number);\n\t/**\n\t * The center of rotation, scaling, and skewing for this display object in its local space.\n\t * The `position` is the projection of `pivot` in the parent's local space.\n\t *\n\t * By default, the pivot is the origin (0, 0).\n\t * @example\n\t * \n\t * @since 4.0.0\n\t */\n\tget pivot(): ObservablePoint;\n\tset pivot(value: PointData | number);\n\t/**\n\t * The skew factor for the object in radians. Skewing is a transformation that distorts\n\t * the object by rotating it differently at each point, creating a non-uniform shape.\n\t * @example\n\t * \n\t * @since 4.0.0\n\t * @type {ObservablePoint} Point-like object with x/y properties in radians\n\t * @default {x: 0, y: 0}\n\t */\n\tget skew(): ObservablePoint;\n\tset skew(value: PointData);\n\t/**\n\t * The scale factors of this object along the local coordinate axes.\n\t *\n\t * The default scale is (1, 1).\n\t * @example\n\t * \n\t * @since 4.0.0\n\t */\n\tget scale(): ObservablePoint;\n\tset scale(value: PointData | number | string);\n\t/**\n\t * @experimental\n\t * The origin point around which the container rotates and scales without affecting its position.\n\t * Unlike pivot, changing the origin will not move the container's position.\n\t * @example\n\t * \n\t */\n\tget origin(): ObservablePoint;\n\tset origin(value: PointData | number);\n\t/**\n\t * The width of the Container, setting this will actually modify the scale to achieve the value set.\n\t * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n\t * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n\t * as it is more optimized by not recalculating the local bounds twice.\n\t * @example\n\t * \n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the Container,\n\t * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n\t * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n\t * as it is more optimized by not recalculating the local bounds twice.\n\t * @example\n\t * \n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Retrieves the size of the container as a [Size]{@link Size} object.\n\t *\n\t * This is faster than get the width and height separately.\n\t * @example\n\t * \n\t * @param out - Optional object to store the size in.\n\t * @returns The size of the container.\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Sets the size of the container to the specified width and height.\n\t * This is more efficient than setting width and height separately as it only recalculates bounds once.\n\t * @example\n\t * \n\t * @param value - This can be either a number or a [Size]{@link Size} object.\n\t * @param height - The height to set. Defaults to the value of `width` if not provided.\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Updates the transform properties of the container.\n\t * Allows partial updates of transform properties for optimized manipulation.\n\t * @example\n\t * \n\t * @param opts - Transform options to update\n\t * @param opts.x - The x position\n\t * @param opts.y - The y position\n\t * @param opts.scaleX - The x-axis scale factor\n\t * @param opts.scaleY - The y-axis scale factor\n\t * @param opts.rotation - The rotation in radians\n\t * @param opts.skewX - The x-axis skew factor\n\t * @param opts.skewY - The y-axis skew factor\n\t * @param opts.pivotX - The x-axis pivot point\n\t * @param opts.pivotY - The y-axis pivot point\n\t * @returns This container, for chaining\n\t */\n\tupdateTransform(opts: Partial<UpdateTransformOptions>): this;\n\t/**\n\t * Updates the local transform properties by decomposing the given matrix.\n\t * Extracts position, scale, rotation, and skew from a transformation matrix.\n\t * @example\n\t * \n\t * @param matrix - The matrix to use for updating the transform\n\t */\n\tsetFromMatrix(matrix: Matrix): void;\n\t/** Updates the local transform. */\n\tupdateLocalTransform(): void;\n\tset alpha(value: number);\n\t/**\n\t * The opacity of the object relative to its parent's opacity.\n\t * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tget alpha(): number;\n\tset tint(value: ColorSource);\n\t/**\n\t * The tint applied to the sprite.\n\t *\n\t * This can be any valid {@link ColorSource}.\n\t * @example\n\t * \n\t * @default 0xFFFFFF\n\t */\n\tget tint(): number;\n\tset blendMode(value: BLEND_MODES);\n\t/**\n\t * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n\t *\n\t * Setting to 'normal' will reset to default blending.\n\t * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n\t * @example\n\t * \n\t * @default 'normal'\n\t */\n\tget blendMode(): BLEND_MODES;\n\t/**\n\t * The visibility of the object. If false the object will not be drawn,\n\t * and the transform will not be updated.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tget visible(): boolean;\n\tset visible(value: boolean);\n\t/**\n\t * Controls whether this object can be rendered. If false the object will not be drawn,\n\t * but the transform will still be updated. This is different from visible, which skips\n\t * transform updates.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tget renderable(): boolean;\n\tset renderable(value: boolean);\n\t/**\n\t * Removes all internal references and listeners as well as removes children from the display list.\n\t * Do not use a Container after calling `destroy`.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * \n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * The type of the pointer event to listen for.\n */\nexport type PointerEvents = \"auto\" | \"none\" | \"visiblePainted\" | \"visibleFill\" | \"visibleStroke\" | \"visible\" | \"painted\" | \"fill\" | \"stroke\" | \"all\" | \"inherit\";\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n */\nexport interface AccessibleOptions {\n\t/**\n\t * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n\t * shadow div with attributes set\n\t * @default false\n\t * @example\n\t * \n\t */\n\taccessible: boolean;\n\t/**\n\t * Sets the title attribute of the shadow div\n\t * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n\t * @type {string}\n\t * @default null\n\t * @example\n\t * \n\t */\n\taccessibleTitle: string | null;\n\t/**\n\t * Sets the tabIndex of the shadow div. You can use this to set the order of the\n\t * elements when using the tab key to navigate.\n\t * @default 0\n\t * @example\n\t * \n\t */\n\ttabIndex: number;\n\t/**\n\t * Sets the text content of the shadow\n\t * @default null\n\t * @example\n\t * \n\t */\n\taccessibleText: string | null;\n\t/**\n\t * Setting to false will prevent any children inside this container to\n\t * be accessible. Defaults to true.\n\t * @default true\n\t * @example\n\t * \n\t */\n\taccessibleChildren: boolean;\n}\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * \n */\nexport type isMobileResult = {\n\t/**\n\t * Apple device detection information.\n\t * Provides detailed iOS device categorization.\n\t * @example\n\t * \n\t */\n\tapple: {\n\t\t/** Whether the device is an iPhone */\n\t\tphone: boolean;\n\t\t/** Whether the device is an iPod Touch */\n\t\tipod: boolean;\n\t\t/** Whether the device is an iPad */\n\t\ttablet: boolean;\n\t\t/** Whether app is running in iOS universal mode */\n\t\tuniversal: boolean;\n\t\t/** Whether device is any Apple mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Amazon device detection information.\n\t * Identifies Amazon Fire tablets and phones.\n\t * @example\n\t * \n\t */\n\tamazon: {\n\t\t/** Whether device is a Fire Phone */\n\t\tphone: boolean;\n\t\t/** Whether device is a Fire Tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Amazon mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Android device detection information.\n\t * Categorizes Android phones and tablets.\n\t * @example\n\t * \n\t */\n\tandroid: {\n\t\t/** Whether device is an Android phone */\n\t\tphone: boolean;\n\t\t/** Whether device is an Android tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Android device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Windows device detection information.\n\t * Identifies Windows phones and tablets.\n\t * @example\n\t * \n\t */\n\twindows: {\n\t\t/** Whether device is a Windows Phone */\n\t\tphone: boolean;\n\t\t/** Whether device is a Windows tablet */\n\t\ttablet: boolean;\n\t\t/** Whether device is any Windows mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Other device detection information.\n\t * Covers additional platforms and browsers.\n\t * @example\n\t * \n\t */\n\tother: {\n\t\t/** Whether device is a BlackBerry */\n\t\tblackberry: boolean;\n\t\t/** Whether device is a BlackBerry 10 */\n\t\tblackberry10: boolean;\n\t\t/** Whether browser is Opera Mobile */\n\t\topera: boolean;\n\t\t/** Whether browser is Firefox Mobile */\n\t\tfirefox: boolean;\n\t\t/** Whether browser is Chrome Mobile */\n\t\tchrome: boolean;\n\t\t/** Whether device is any other mobile device */\n\t\tdevice: boolean;\n\t};\n\t/**\n\t * Whether the device is any type of phone.\n\t * Combines detection across all platforms.\n\t * @example\n\t * \n\t */\n\tphone: boolean;\n\t/**\n\t * Whether the device is any type of tablet.\n\t * Combines detection across all platforms.\n\t * @example\n\t * \n\t */\n\ttablet: boolean;\n\t/**\n\t * Whether the device is any type of mobile device.\n\t * True if any mobile platform is detected.\n\t * @example\n\t * \n\t */\n\tany: boolean;\n};\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * \n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n */\nexport declare const isMobile: isMobileResult;\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * \n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * \n *\n * To make individual containers accessible:\n * \n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n */\nexport declare class AccessibilitySystem implements System<AccessibilitySystemOptions> {\n\t/**\n\t * The default options used by the system.\n\t * You can set these before initializing the {@link Application} to change the default behavior.\n\t * @example\n\t * \n\t */\n\tstatic defaultOptions: AccessibilityOptions;\n\t/** Whether accessibility divs are visible for debugging */\n\tdebug: boolean;\n\t/**\n\t * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n\t */\n\tconstructor(renderer: Renderer, _mobileInfo?: isMobileResult);\n\t/**\n\t * Value of `true` if accessibility is currently active and accessibility layers are showing.\n\t * @type {boolean}\n\t */\n\tget isActive(): boolean;\n\t/**\n\t * Value of `true` if accessibility is enabled for touch devices.\n\t * @type {boolean}\n\t */\n\tget isMobileAccessibility(): boolean;\n\t/**\n\t * Button element for handling touch hooks.\n\t */\n\tget hookDiv(): HTMLElement;\n\t/**\n\t * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n\t */\n\tget div(): HTMLElement;\n\t/**\n\t * Destroys the accessibility system. Removes all elements and listeners.\n\t * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n\t * > A typically user should not need to call this method directly.\n\t */\n\tdestroy(): void;\n\t/**\n\t * Enables or disables the accessibility system.\n\t * @param enabled - Whether to enable or disable accessibility.\n\t * @example\n\t * \n\t */\n\tsetAccessibilityEnabled(enabled: boolean): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends Partial<AccessibleTarget> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends Partial<AccessibleOptions> {\n\t\t}\n\t\tinterface RendererSystems {\n\t\t\taccessibility: AccessibilitySystem;\n\t\t}\n\t}\n}\n/**\n * A callback which can be added to a ticker.\n * The callback receives the Ticker instance as its parameter, providing access to timing properties.\n * @example\n * \n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * Used for managing animation frames and timing in a PixiJS application.\n *\n * It provides a way to add listeners that will be called on each frame,\n * allowing for smooth animations and updates.\n *\n * ## Time Units\n * - `deltaTime`: Dimensionless scalar (typically ~1.0 at 60 FPS) for frame-independent animations\n * - `deltaMS`: Milliseconds elapsed (capped and speed-scaled) for time-based calculations\n * - `elapsedMS`: Raw milliseconds elapsed (uncapped, unscaled) for measurements\n * - `lastTime`: Timestamp in milliseconds since epoch (performance.now() format)\n *\n * Animation frames are requested\n * only when necessary, e.g., when the ticker is started and the emitter has listeners.\n * @example\n * \n */\nexport declare class Ticker {\n\t/**\n\t * Target frame rate in frames per millisecond.\n\t * Used for converting deltaTime to a scalar time delta.\n\t * @example\n\t * \n\t * @remarks\n\t * - Default is 0.06 (equivalent to 60 FPS)\n\t * - Used in deltaTime calculations\n\t * - Affects all ticker instances\n\t * @default 0.06\n\t */\n\tstatic targetFPMS: number;\n\t/**\n\t * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n\t * automatically when a listener is added.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tautoStart: boolean;\n\t/**\n\t * Scalar representing the delta time factor.\n\t * This is a dimensionless value representing the fraction of a frame at the target framerate.\n\t * At 60 FPS, this value is typically around 1.0.\n\t *\n\t * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.\n\t * For actual milliseconds, use {@link Ticker#deltaMS}.\n\t * @member {number}\n\t * @example\n\t * \n\t */\n\tdeltaTime: number;\n\t/**\n\t * Scalar time elapsed in milliseconds from last frame to this frame.\n\t * Provides precise timing for animations and updates.\n\t *\n\t * This value is capped by setting {@link Ticker#minFPS|minFPS}\n\t * and is scaled with {@link Ticker#speed|speed}.\n\t *\n\t * If the platform supports DOMHighResTimeStamp,\n\t * this value will have a precision of 1 Âµs.\n\t *\n\t * Defaults to target frame time\n\t *\n\t * > [!NOTE] The cap may be exceeded by scaling.\n\t * @example\n\t * \n\t * @default 16.66\n\t */\n\tdeltaMS: number;\n\t/**\n\t * Time elapsed in milliseconds from the last frame to this frame.\n\t * This value is not capped or scaled and provides raw timing information.\n\t *\n\t * Unlike {@link Ticker#deltaMS}, this value is unmodified by speed scaling or FPS capping.\n\t * @member {number}\n\t * @example\n\t * \n\t */\n\telapsedMS: number;\n\t/**\n\t * The last time update was invoked, in milliseconds since epoch.\n\t * Similar to performance.now() timestamp format.\n\t *\n\t * Used internally for calculating time deltas between frames.\n\t * @member {number}\n\t * @example\n\t * \n\t */\n\tlastTime: number;\n\t/**\n\t * Factor of current {@link Ticker#deltaTime|deltaTime}.\n\t * Used to scale time for slow motion or fast-forward effects.\n\t * @example\n\t * \n\t */\n\tspeed: number;\n\t/**\n\t * Whether or not this ticker has been started.\n\t *\n\t * `true` if {@link Ticker#start|start} has been called.\n\t * `false` if {@link Ticker#stop|Stop} has been called.\n\t *\n\t * While `false`, this value may change to `true` in the\n\t * event of {@link Ticker#autoStart|autoStart} being `true`\n\t * and a listener is added.\n\t * @example\n\t * \n\t */\n\tstarted: boolean;\n\tconstructor();\n\t/**\n\t * Register a handler for tick events.\n\t * @param fn - The listener function to add. Receives the Ticker instance as parameter\n\t * @param context - The context for the listener\n\t * @param priority - The priority of the listener\n\t * @example\n\t * \n\t */\n\tadd<T = any>(fn: TickerCallback<T>, context?: T, priority?: number): this;\n\t/**\n\t * Add a handler for the tick event which is only executed once on the next frame.\n\t * @example\n\t * \n\t * @param fn - The listener function to be added for one update\n\t * @param context - The listener context\n\t * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n\t * @returns This instance of a ticker\n\t */\n\taddOnce<T = any>(fn: TickerCallback<T>, context?: T, priority?: number): this;\n\t/**\n\t * Removes any handlers matching the function and context parameters.\n\t * If no handlers are left after removing, then it cancels the animation frame.\n\t * @example\n\t * \n\t * @param fn - The listener function to be removed\n\t * @param context - The listener context to be removed\n\t * @returns This instance of a ticker\n\t */\n\tremove<T = any>(fn: TickerCallback<T>, context?: T): this;\n\t/**\n\t * The number of listeners on this ticker, calculated by walking through linked list.\n\t * @example\n\t * \n\t */\n\tget count(): number;\n\t/**\n\t * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n\t * @example\n\t * \n\t */\n\tstart(): void;\n\t/**\n\t * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n\t * @example\n\t * \n\t */\n\tstop(): void;\n\t/**\n\t * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n\t * @example\n\t * \n\t */\n\tdestroy(): void;\n\t/**\n\t * Triggers an update.\n\t *\n\t * An update entails setting the\n\t * current {@link Ticker#elapsedMS|elapsedMS},\n\t * the current {@link Ticker#deltaTime|deltaTime},\n\t * invoking all listeners with current deltaTime,\n\t * and then finally setting {@link Ticker#lastTime|lastTime}\n\t * with the value of currentTime that was provided.\n\t *\n\t * This method will be called automatically by animation\n\t * frame callbacks if the ticker instance has been started\n\t * and listeners are added.\n\t * @example\n\t * \n\t * @param currentTime - The current time of execution (defaults to performance.now())\n\t */\n\tupdate(currentTime?: number): void;\n\t/**\n\t * The frames per second at which this ticker is running.\n\t * The default is approximately 60 in most modern browsers.\n\t * > [!NOTE] This does not factor in the value of\n\t * > {@link Ticker#speed|speed}, which is specific\n\t * > to scaling {@link Ticker#deltaTime|deltaTime}.\n\t * @example\n\t * \n\t */\n\tget FPS(): number;\n\t/**\n\t * Manages the maximum amount of milliseconds allowed to\n\t * elapse between invoking {@link Ticker#update|update}.\n\t *\n\t * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n\t * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n\t *\n\t * When setting this property it is clamped to a value between\n\t * `0` and `Ticker.targetFPMS * 1000`.\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tget minFPS(): number;\n\tset minFPS(fps: number);\n\t/**\n\t * Manages the minimum amount of milliseconds required to\n\t * elapse between invoking {@link Ticker#update|update}.\n\t *\n\t * This will effect the measured value of {@link Ticker#FPS|FPS}.\n\t *\n\t * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n\t * Otherwise it will be at least `minFPS`\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tget maxFPS(): number;\n\tset maxFPS(fps: number);\n\t/**\n\t * The shared ticker instance used by {@link AnimatedSprite} and by\n\t * {@link VideoSource} to update animation frames / video textures.\n\t *\n\t * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n\t *\n\t * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n\t * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n\t * @example\n\t * import { Ticker } from 'pixi.js';\n\t *\n\t * const ticker = Ticker.shared;\n\t * // Set this to prevent starting this ticker when listeners are added.\n\t * // By default this is true only for the Ticker.shared instance.\n\t * ticker.autoStart = false;\n\t *\n\t * // FYI, call this to ensure the ticker is stopped. It should be stopped\n\t * // if you have not attempted to render anything yet.\n\t * ticker.stop();\n\t *\n\t * // Call this when you are ready for a running shared ticker.\n\t * ticker.start();\n\t * @example\n\t * import { autoDetectRenderer, Container } from 'pixi.js';\n\t *\n\t * // You may use the shared ticker to render...\n\t * const renderer = autoDetectRenderer();\n\t * const stage = new Container();\n\t * document.body.appendChild(renderer.view);\n\t * ticker.add((time) => renderer.render(stage));\n\t *\n\t * // Or you can just update it manually.\n\t * ticker.autoStart = false;\n\t * ticker.stop();\n\t * const animate = (time) => {\n\t *     ticker.update(time);\n\t *     renderer.render(stage);\n\t *     requestAnimationFrame(animate);\n\t * };\n\t * animate(performance.now());\n\t * @type {Ticker}\n\t */\n\tstatic get shared(): Ticker;\n}\ntype ResizeableRenderer = Pick<Renderer, \"resize\">;\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * \n */\nexport interface ResizePluginOptions {\n\t/**\n\t * Element to automatically resize the renderer to.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tresizeTo?: Window | HTMLElement;\n}\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * \n */\nexport declare class ResizePlugin {\n}\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * \n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n */\nexport interface TickerPluginOptions {\n\t/**\n\t * Controls whether the animation loop starts automatically after initialization.\n\t * > [!IMPORTANT]\n\t * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n\t * > You must stop the shared ticker manually if needed.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tautoStart?: boolean;\n\t/**\n\t * Controls whether to use the shared global ticker or create a new instance.\n\t *\n\t * The shared ticker is useful when you have multiple instances that should sync their updates.\n\t * However, it has some limitations regarding update order control.\n\t *\n\t * Update Order:\n\t * 1. System ticker (always runs first)\n\t * 2. Shared ticker (if enabled)\n\t * 3. App ticker (if using own ticker)\n\t * @example\n\t * \n\t * @default false\n\t */\n\tsharedTicker?: boolean;\n}\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * \n */\nexport declare class TickerPlugin {\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// Extend the Application interface with resize and ticker functionalities\n\t\tinterface Application {\n\t\t\t/**\n\t\t\t * Element to automatically resize the renderer to.\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @default null\n\t\t\t */\n\t\t\tresizeTo: Window | HTMLElement;\n\t\t\t/**\n\t\t\t * Element to automatically resize the renderer to.\n\t\t\t * > [!IMPORTANT]\n\t\t\t * > You do not need to call this method manually in most cases.\n\t\t\t * > A `resize` event will be dispatched automatically when the `resizeTo` element changes size.\n\t\t\t * @remarks\n\t\t\t * - Automatically resizes the renderer to match the size of the `resizeTo` element\n\t\t\t * - If `resizeTo` is `null`, auto-resizing is disabled\n\t\t\t * - If `resizeTo` is a `Window`, it resizes to the full window size\n\t\t\t * - If `resizeTo` is an `HTMLElement`, it resizes to the element's bounding client rectangle\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @default null\n\t\t\t */\n\t\t\tresize(): void;\n\t\t\t/**\n\t\t\t * Queue a resize operation for the next animation frame. This method is throttled\n\t\t\t * and optimized for frequent calls.\n\t\t\t * > [!IMPORTANT]\n\t\t\t * > You do not need to call this method manually in most cases.\n\t\t\t * > A `resize` event will be dispatched automatically when the `resizeTo` element changes size.\n\t\t\t * @remarks\n\t\t\t * - Safe to call multiple times per frame\n\t\t\t * - Only one resize will occur on next frame\n\t\t\t * - Cancels any previously queued resize\n\t\t\t * @example\n\t\t\t * \n\t\t\t */\n\t\t\tqueueResize(): void;\n\t\t\t/**\n\t\t\t * Cancel any pending resize operation that was queued with `queueResize()`.\n\t\t\t * @remarks\n\t\t\t * - Clears the resize operation queued for next frame\n\t\t\t * @example\n\t\t\t * \n\t\t\t */\n\t\t\tcancelResize(): void;\n\t\t\t/**\n\t\t\t * The application's ticker instance that manages the update/render loop.\n\t\t\t * @example\n\t\t\t * \n\t\t\t */\n\t\t\tticker: Ticker;\n\t\t\t/**\n\t\t\t * Stops the render/update loop.\n\t\t\t * @example\n\t\t\t * \n\t\t\t */\n\t\t\tstop(): void;\n\t\t\t/**\n\t\t\t * Starts the render/update loop.\n\t\t\t * @example\n\t\t\t * \n\t\t\t */\n\t\t\tstart(): void;\n\t\t}\n\t\t// Combine ResizePluginOptions and TickerPluginOptions into ApplicationOptions\n\t\tinterface ApplicationOptions extends ResizePluginOptions, TickerPluginOptions {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface AssetsPreferences {\n\t\t}\n\t}\n}\n/**\n * The CullingMixin interface provides properties and methods for managing culling behavior\n * of a display object. Culling is the process of determining whether an object should be rendered\n * based on its visibility within the current view or frame.\n *\n * Key Features:\n * - Custom culling areas for better performance\n * - Per-object culling control\n * - Child culling management\n * @example\n * \n */\nexport interface CullingMixinConstructor {\n\t/**\n\t * Custom shape used for culling calculations instead of object bounds.\n\t * Defined in local space coordinates relative to the object.\n\t * > [!NOTE]\n\t * > Setting this to a custom Rectangle allows you to define a specific area for culling,\n\t * > which can improve performance by avoiding expensive bounds calculations.\n\t * @example\n\t * \n\t * @remarks\n\t * - Improves performance by avoiding bounds calculations\n\t * - Useful for containers with many children\n\t * - Set to null to use object bounds\n\t * @default null\n\t */\n\tcullArea: Rectangle;\n\t/**\n\t * Controls whether this object should be culled when out of view.\n\t * When true, the object will not be rendered if its bounds are outside the visible area.\n\t * @example\n\t * \n\t * @remarks\n\t * - Does not affect transform updates\n\t * - Applies to this object only\n\t * - Children follow their own cullable setting\n\t * @default false\n\t */\n\tcullable: boolean;\n\t/**\n\t * Controls whether children of this container can be culled.\n\t * When false, skips recursive culling checks for better performance.\n\t * @example\n\t * \n\t * @remarks\n\t * - Improves performance for static scenes\n\t * - Useful when children are always within container bounds\n\t * - Parent culling still applies\n\t * @default true\n\t */\n\tcullableChildren: boolean;\n}\n/**\n * Application options for the {@link CullerPlugin}.\n * These options control how your application handles culling of display objects.\n * @example\n * \n */\nexport interface CullerPluginOptions {\n\t/**\n\t * Options for the culler behavior.\n\t * @example\n\t * \n\t */\n\tculler?: {\n\t\t/**\n\t\t * Update the transform of culled objects.\n\t\t *\n\t\t * > [!IMPORTANT] Keeping this as `false` can improve performance by avoiding unnecessary calculations,\n\t\t * > however, the transform used for culling may not be up-to-date if the object has moved since the last render.\n\t\t * @default true\n\t\t * @example\n\t\t * \n\t\t */\n\t\tupdateTransform?: boolean;\n\t};\n}\n/**\n * An {@link Application} plugin that automatically culls (hides) display objects that are outside\n * the visible screen area. This improves performance by not rendering objects that aren't visible.\n *\n * Key Features:\n * - Automatic culling based on screen boundaries\n * - Configurable culling areas and behavior per container\n * - Can improve rendering performance\n * @example\n * \n * @remarks\n * To enable culling, you must set the following properties on your containers:\n * - `cullable`: Set to `true` to enable culling for the container\n * - `cullableChildren`: Set to `true` to enable culling for children (default)\n * - `cullArea`: Optional custom Rectangle for culling bounds\n *\n * Performance Tips:\n * - Group objects that are spatially related\n * - Use `cullArea` for containers with many children to avoid bounds calculations\n * - Set `cullableChildren = false` for containers that are always fully visible\n */\nexport declare class CullerPlugin {\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends Partial<CullingMixinConstructor> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends Partial<CullingMixinConstructor> {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ApplicationOptions extends Partial<CullerPluginOptions> {\n\t\t}\n\t}\n}\n/**\n * Options for configuring a {@link DOMContainer}.\n * Controls how DOM elements are integrated into the PixiJS scene graph.\n * @example\n * \n */\nexport interface DOMContainerOptions extends ViewContainerOptions {\n\t/**\n\t * The DOM element to use for the container.\n\t * Can be any HTML element like div, input, textarea, etc.\n\t *\n\t * If not provided, creates a new div element.\n\t * @default document.createElement('div')\n\t */\n\telement?: HTMLElement;\n\t/**\n\t * The anchor point of the container.\n\t * - Can be a single number to set both x and y\n\t * - Can be a point-like object with x,y coordinates\n\t * - (0,0) is top-left\n\t * - (1,1) is bottom-right\n\t * - (0.5,0.5) is center\n\t * @default 0\n\t */\n\tanchor?: PointData | number;\n}\n/**\n * The DOMContainer object is used to render DOM elements within the PixiJS scene graph.\n * It allows you to integrate HTML elements into your PixiJS application while maintaining\n * proper transform hierarchy and visibility.\n *\n * DOMContainer is especially useful for rendering standard DOM elements\n * that handle user input, such as `<input>` or `<textarea>`.\n * This is often simpler and more flexible than trying to implement text input\n * directly in PixiJS. For instance, if you need text fields or text areas,\n * you can embed them through this container for native browser text handling.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * @example\n * \n */\nexport declare class DOMContainer extends ViewContainer<never> {\n\t/**\n\t * @param options - The options for creating the DOM container.\n\t */\n\tconstructor(options?: DOMContainerOptions);\n\t/**\n\t * The anchor sets the origin point of the container.\n\t * Controls the relative positioning of the DOM element.\n\t *\n\t * The default is `(0,0)`, this means the container's origin is the top left.\n\t * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.\n\t * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.\n\t * @example\n\t * \n\t */\n\tget anchor(): Point;\n\t/**\n\t * Sets the anchor point of the container.\n\t * @param value - New anchor value:\n\t * - number: Sets both x and y to same value\n\t * - PointData: Sets x and y separately\n\t */\n\tset anchor(value: PointData | number);\n\t/**\n\t * Sets the DOM element for this container.\n\t * This will replace the current element and update the view.\n\t * @param value - The new DOM element to use\n\t * @example\n\t * \n\t */\n\tset element(value: HTMLElement);\n\t/**\n\t * The DOM element associated with this container.\n\t * @example\n\t * \n\t */\n\tget element(): HTMLElement;\n\t/**\n\t * Destroys this DOM container.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that\n\t * @example\n\t * domContainer.destroy();\n\t * domContainer.destroy(true);\n\t */\n\tdestroy(options?: boolean): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tdom: DOMPipe;\n\t\t}\n\t}\n}\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * \n */\nexport declare class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent {\n\t/**\n\t * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n\t * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n\t */\n\tdeltaMode: number;\n\t/** Horizontal scroll amount */\n\tdeltaX: number;\n\t/** Vertical scroll amount */\n\tdeltaY: number;\n\t/** z-axis scroll amount. */\n\tdeltaZ: number;\n}\ntype EmitterListener = {\n\tfn(...args: any[]): any;\n\tcontext: any;\n\tonce: boolean;\n};\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * \n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n */\nexport type Cursor = \"auto\" | \"default\" | \"none\" | \"context-menu\" | \"help\" | \"pointer\" | \"progress\" | \"wait\" | \"cell\" | \"crosshair\" | \"text\" | \"vertical-text\" | \"alias\" | \"copy\" | \"move\" | \"no-drop\" | \"not-allowed\" | \"e-resize\" | \"n-resize\" | \"ne-resize\" | \"nw-resize\" | \"s-resize\" | \"se-resize\" | \"sw-resize\" | \"w-resize\" | \"ns-resize\" | \"ew-resize\" | \"nesw-resize\" | \"col-resize\" | \"nwse-resize\" | \"row-resize\" | \"all-scroll\" | \"zoom-in\" | \"zoom-out\" | \"grab\" | \"grabbing\";\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * \n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n */\nexport interface IHitArea {\n\t/**\n\t * Checks if the given coordinates are inside this hit area.\n\t * @param {number} x - The x coordinate to check\n\t * @param {number} y - The y coordinate to check\n\t * @returns True if the coordinates are inside the hit area\n\t */\n\tcontains(x: number, y: number): boolean;\n}\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * \n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n */\nexport type EventMode = \"none\" | \"passive\" | \"auto\" | \"static\" | \"dynamic\";\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * \n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n */\nexport interface FederatedOptions {\n\t/**\n\t * The cursor style to display when the mouse pointer is hovering over the object.\n\t * Accepts any valid CSS cursor value or custom cursor URL.\n\t * @example\n\t * \n\t * @type {Cursor | string}\n\t * @default undefined\n\t */\n\tcursor?: Cursor | (string & {});\n\t/**\n\t * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n\t * @example\n\t * \n\t *\n\t * Available modes:\n\t *\n\t * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n\t * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n\t * children. Interactive children will still emit events.\n\t * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n\t * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n\t * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n\t *\n\t * Performance tips:\n\t * - Use `'none'` for pure visual elements\n\t * - Use `'passive'` for containers with some interactive children\n\t * - Use `'static'` for standard UI elements\n\t * - Use `'dynamic'` only when needed for moving/animated elements\n\t * @since 7.2.0\n\t */\n\teventMode?: EventMode;\n\t/**\n\t * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n\t * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n\t * Setting it to false will disable all interaction events on this object.\n\t * @example\n\t * \n\t */\n\tinteractive?: boolean;\n\t/**\n\t * Controls whether children of this container can receive pointer events.\n\t *\n\t * Setting this to false allows PixiJS to skip hit testing on all children,\n\t * improving performance for containers with many non-interactive children.\n\t * @default true\n\t * @example\n\t * \n\t */\n\tinteractiveChildren?: boolean;\n\t/**\n\t * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n\t * for hit testing instead of the container's standard bounds.\n\t * @example\n\t * \n\t * @remarks\n\t * - Takes precedence over the container's bounds for hit testing\n\t * - Can improve performance by simplifying collision checks\n\t * - Useful for irregular shapes or precise click areas\n\t */\n\thitArea?: IHitArea | null;\n\t/**\n\t * Property-based event handler for the `click` event.\n\t * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonclick?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mousedown` event.\n\t * Fired when a mouse button is pressed while the pointer is over the object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmousedown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseenter` event.\n\t * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseenter?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseleave` event.\n\t * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseleave?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mousemove` event.\n\t * Fired when the pointer moves while over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmousemove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globalmousemove` event.\n\t *\n\t * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * \n\t * @default null\n\t * @remarks\n\t * - Fires even when the mouse is outside the object's bounds\n\t * - Useful for drag operations or global mouse tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n\t */\n\tonglobalmousemove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseout` event.\n\t * Fired when the pointer moves out of the bounds of the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseout?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseover` event.\n\t * Fired when the pointer moves onto the bounds of the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseover?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseup` event.\n\t * Fired when a mouse button is released over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `mouseupoutside` event.\n\t * Fired when a mouse button is released outside the display object that initially\n\t * registered a mousedown.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonmouseupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointercancel` event.\n\t * Fired when a pointer device interaction is canceled or lost.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointercancel?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerdown` event.\n\t * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerdown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerenter` event.\n\t * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerenter?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerleave` event.\n\t * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerleave?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointermove` event.\n\t * Fired when a pointer device moves while over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointermove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globalpointermove` event.\n\t *\n\t * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * \n\t * @default null\n\t * @remarks\n\t * - Fires even when the mouse is outside the object's bounds\n\t * - Useful for drag operations or global mouse tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n\t */\n\tonglobalpointermove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerout` event.\n\t * Fired when the pointer moves out of the bounds of the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerout?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerover` event.\n\t * Fired when the pointer moves over the bounds of the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerover?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointertap` event.\n\t * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointertap?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerup` event.\n\t * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `pointerupoutside` event.\n\t * Fired when a pointer device button is released outside the bounds of the display object\n\t * that initially registered a pointerdown.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonpointerupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightclick` event.\n\t * Fired when a right-click (context menu) action is performed on the object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonrightclick?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightdown` event.\n\t * Fired when a right mouse button is pressed down over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonrightdown?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightup` event.\n\t * Fired when a right mouse button is released over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonrightup?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `rightupoutside` event.\n\t * Fired when a right mouse button is released outside the bounds of the display object\n\t * that initially registered a rightdown.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonrightupoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `tap` event.\n\t * Fired when a tap action (touch) is completed on the object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontap?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchcancel` event.\n\t * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontouchcancel?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchend` event.\n\t * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontouchend?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchendoutside` event.\n\t * Fired when a touch interaction ends outside the bounds of the display object\n\t * that initially registered a touchstart.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontouchendoutside?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchmove` event.\n\t * Fired when a touch interaction moves while over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontouchmove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `globaltouchmove` event.\n\t *\n\t * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n\t * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n\t * @example\n\t * \n\t * @default null\n\t * @remarks\n\t * - Fires even when the touch is outside the object's bounds\n\t * - Useful for drag operations or global touch tracking\n\t * - Must have `eventMode` set appropriately to receive events\n\t * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n\t */\n\tonglobaltouchmove?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `touchstart` event.\n\t * Fired when a touch interaction starts, such as when a finger touches the screen.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tontouchstart?: FederatedEventHandler | null;\n\t/**\n\t * Property-based event handler for the `wheel` event.\n\t * Fired when the mouse wheel is scrolled while over the display object.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * \n */\nexport interface PixiTouch extends Touch {\n\t/** The button being pressed (0: left, 1: middle, 2: right) */\n\tbutton: number;\n\t/** Bitmap of currently pressed buttons */\n\tbuttons: number;\n\t/** Whether this is the primary touch point */\n\tisPrimary: boolean;\n\t/** The width of the touch contact area */\n\twidth: number;\n\t/** The height of the touch contact area */\n\theight: number;\n\t/** The angle of tilt along the x-axis (in degrees) */\n\ttiltX: number;\n\t/** The angle of tilt along the y-axis (in degrees) */\n\ttiltY: number;\n\t/** The type of pointer that triggered this event */\n\tpointerType: string;\n\t/** Unique identifier for this touch point */\n\tpointerId: number;\n\t/** The normalized pressure of the pointer (0 to 1) */\n\tpressure: number;\n\t/** The rotation angle of the pointer (e.g., pen) */\n\ttwist: number;\n\t/** The normalized tangential pressure of the pointer */\n\ttangentialPressure: number;\n\t/** The x coordinate relative to the current layer */\n\tlayerX: number;\n\t/** The y coordinate relative to the current layer */\n\tlayerY: number;\n\t/** The x coordinate relative to the target's offset parent */\n\toffsetX: number;\n\t/** The y coordinate relative to the target's offset parent */\n\toffsetY: number;\n\t/** Whether the event was normalized by PixiJS */\n\tisNormalized: boolean;\n\t/** The type of touch event */\n\ttype: string;\n}\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * \n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n */\nexport declare class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent {\n\t/** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n\tbubbles: boolean;\n\t/** @deprecated since 7.0.0 */\n\tcancelBubble: boolean;\n\t/**\n\t * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n\t * false (for now).\n\t */\n\treadonly cancelable = false;\n\t/** The listeners of the event target that are being notified. */\n\tcurrentTarget: Container;\n\t/** Flags whether the default response of the user agent was prevent through this event. */\n\tdefaultPrevented: boolean;\n\t/**\n\t * The propagation phase.\n\t * @default {@link FederatedEvent.NONE}\n\t */\n\teventPhase: number;\n\t/** Flags whether this is a user-trusted event */\n\tisTrusted: boolean;\n\t/** @deprecated since 7.0.0 */\n\treturnValue: boolean;\n\t/** @deprecated since 7.0.0 */\n\tsrcElement: EventTarget;\n\t/** The event target that this will be dispatched to. */\n\ttarget: Container;\n\t/** The timestamp of when the event was created. */\n\ttimeStamp: number;\n\t/** The type of event, e.g. `\"mouseup\"`. */\n\ttype: string;\n\t/** The native event that caused the foremost original event. */\n\tnativeEvent: N;\n\t/** The original event that caused this event, if any. */\n\toriginalEvent: FederatedEvent<N>;\n\t/** Flags whether propagation was stopped. */\n\tpropagationStopped: boolean;\n\t/** Flags whether propagation was immediately stopped. */\n\tpropagationImmediatelyStopped: boolean;\n\t/** The composed path of the event's propagation. The `target` is at the end. */\n\tpath: Container[];\n\t/** The {@link EventBoundary} that manages this event. Null for root events. */\n\treadonly manager: EventBoundary;\n\t/** Event-specific detail */\n\tdetail: number;\n\t/** The global Window object. */\n\tview: WindowProxy;\n\t/** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n\tlayer: Point;\n\t/** @readonly */\n\tget layerX(): number;\n\t/** @readonly */\n\tget layerY(): number;\n\t/** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n\tpage: Point;\n\t/** @readonly */\n\tget pageX(): number;\n\t/** @readonly */\n\tget pageY(): number;\n\t/**\n\t * @param manager - The event boundary which manages this event. Propagation can only occur\n\t *  within the boundary's jurisdiction.\n\t */\n\tconstructor(manager: EventBoundary);\n\t/**\n\t * Fallback for the deprecated `InteractionEvent.data`.\n\t * @deprecated since 7.0.0\n\t */\n\tget data(): this;\n\t/**\n\t * Prevent default behavior of both PixiJS and the user agent.\n\t * @example\n\t * \n\t * @remarks\n\t * - Only works if the native event is cancelable\n\t * - Does not stop event propagation\n\t */\n\tpreventDefault(): void;\n\t/**\n\t * Stop this event from propagating to any additional listeners, including those\n\t * on the current target and any following targets in the propagation path.\n\t * @example\n\t * \n\t * @remarks\n\t * - Immediately stops all event propagation\n\t * - Prevents other listeners on same target from being called\n\t * - More aggressive than stopPropagation()\n\t */\n\tstopImmediatePropagation(): void;\n\t/**\n\t * Stop this event from propagating to the next target in the propagation path.\n\t * The rest of the listeners on the current target will still be notified.\n\t * @example\n\t * \n\t * @remarks\n\t * - Stops event bubbling to parent containers\n\t * - Does not prevent other listeners on same target\n\t * - Less aggressive than stopImmediatePropagation()\n\t */\n\tstopPropagation(): void;\n}\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * \n */\nexport declare class FederatedMouseEvent extends FederatedEvent<MouseEvent | PointerEvent | PixiTouch> implements MouseEvent {\n\t/** Whether the \"alt\" key was pressed when this mouse event occurred. */\n\taltKey: boolean;\n\t/** The specific button that was pressed in this mouse event. */\n\tbutton: number;\n\t/** The button depressed when this event occurred. */\n\tbuttons: number;\n\t/** Whether the \"control\" key was pressed when this mouse event occurred. */\n\tctrlKey: boolean;\n\t/** Whether the \"meta\" key was pressed when this mouse event occurred. */\n\tmetaKey: boolean;\n\t/** This is currently not implemented in the Federated Events API. */\n\trelatedTarget: EventTarget;\n\t/** Whether the \"shift\" key was pressed when this mouse event occurred. */\n\tshiftKey: boolean;\n\t/** The coordinates of the mouse event relative to the canvas. */\n\tclient: Point;\n\t/** @readonly */\n\tget clientX(): number;\n\t/** @readonly */\n\tget clientY(): number;\n\t/**\n\t * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n\t */\n\tget x(): number;\n\t/**\n\t * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n\t */\n\tget y(): number;\n\t/** This is the number of clicks that occurs in 200ms/click of each other. */\n\tdetail: number;\n\t/** The movement in this pointer relative to the last `mousemove` event. */\n\tmovement: Point;\n\t/** @readonly */\n\tget movementX(): number;\n\t/** @readonly */\n\tget movementY(): number;\n\t/** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n\toffset: Point;\n\t/** @readonly */\n\tget offsetX(): number;\n\t/** @readonly */\n\tget offsetY(): number;\n\t/** The pointer coordinates in world space. */\n\tglobal: Point;\n\t/** @readonly */\n\tget globalX(): number;\n\t/** @readonly */\n\tget globalY(): number;\n\t/**\n\t * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n\t * different semantics than native PointerEvent screenX/screenY.\n\t */\n\tscreen: Point;\n\t/**\n\t * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n\t */\n\tget screenX(): number;\n\t/**\n\t * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n\t */\n\tget screenY(): number;\n\t/**\n\t * Converts global coordinates into container-local coordinates.\n\t *\n\t * This method transforms coordinates from world space to a container's local space,\n\t * useful for precise positioning and hit testing.\n\t * @param container - The Container to get local coordinates for\n\t * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n\t * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n\t * @returns The local coordinates as a Point object\n\t * @example\n\t * \n\t */\n\tgetLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P;\n\t/**\n\t * Whether the modifier key was pressed when this event natively occurred.\n\t * @param key - The modifier key.\n\t */\n\tgetModifierState(key: string): boolean;\n}\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * \n */\nexport declare class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent {\n\t/**\n\t * The unique identifier of the pointer.\n\t */\n\tpointerId: number;\n\t/**\n\t * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n\t * radiusX of TouchEvents will be represented by this value.\n\t */\n\twidth: number;\n\t/**\n\t * The angle in radians of a pointer or stylus measuring the vertical angle between\n\t * the device's surface to the pointer or stylus.\n\t * A stylus at 0 degrees would be directly parallel whereas at Ï€/2 degrees it would be perpendicular.\n\t */\n\taltitudeAngle: number;\n\t/**\n\t * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n\t * the pointer or stylus projected onto the screen's plane.\n\t * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at Ï€/2 degrees it would be pointing at \"6 o'clock\".\n\t */\n\tazimuthAngle: number;\n\t/**\n\t * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n\t * radiusY of TouchEvents will be represented by this value.\n\t */\n\theight: number;\n\t/**\n\t * Indicates whether or not the pointer device that created the event is the primary pointer.\n\t */\n\tisPrimary: boolean;\n\t/**\n\t * The type of pointer that triggered the event.\n\t */\n\tpointerType: string;\n\t/**\n\t * Pressure applied by the pointing device during the event.\n\t *s\n\t * A Touch's force property will be represented by this value.\n\t */\n\tpressure: number;\n\t/**\n\t * Barrel pressure on a stylus pointer.\n\t */\n\ttangentialPressure: number;\n\t/**\n\t * The angle, in degrees, between the pointer device and the screen.\n\t */\n\ttiltX: number;\n\t/**\n\t * The angle, in degrees, between the pointer device and the screen.\n\t */\n\ttiltY: number;\n\t/**\n\t * Twist of a stylus pointer.\n\t */\n\ttwist: number;\n\t/** This is the number of clicks that occurs in 200ms/click of each other. */\n\tdetail: number;\n}\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * \n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n */\nexport declare class EventSystem implements System<EventSystemOptions> {\n\t/**\n\t * The event features that are enabled by the EventSystem\n\t * @since 7.2.0\n\t * @example\n\t * \n\t */\n\tstatic defaultEventFeatures: EventSystemFeatures;\n\t/**\n\t * The default interaction mode for all display objects.\n\t * @type {EventMode}\n\t * @since 7.2.0\n\t */\n\tstatic get defaultEventMode(): EventMode;\n\t/**\n\t * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n\t * This is used to determine the appropriate event handling strategy.\n\t * @default 'ontouchstart' in globalThis\n\t */\n\treadonly supportsTouchEvents: boolean;\n\t/**\n\t * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n\t * Used to optimize event handling and provide more consistent cross-device interaction.\n\t * @default !!globalThis.PointerEvent\n\t */\n\treadonly supportsPointerEvents: boolean;\n\t/**\n\t * Controls whether default browser actions are automatically prevented on pointer events.\n\t * When true, prevents default browser actions from occurring on pointer events.\n\t * @remarks\n\t * - Does not apply to pointer events for backwards compatibility\n\t * - preventDefault on pointer events stops mouse events from firing\n\t * - For every pointer event, there will always be either a mouse or touch event alongside it\n\t * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n\t * @example\n\t * \n\t * @default true\n\t */\n\tautoPreventDefault: boolean;\n\t/**\n\t * Dictionary of custom cursor styles that can be used across the application.\n\t * Used to define how different cursor modes are handled when interacting with display objects.\n\t * @example\n\t * \n\t * @remarks\n\t * - Strings are treated as CSS cursor values\n\t * - Objects are applied as CSS styles to the DOM element\n\t * - Functions are called directly for custom cursor handling\n\t * - Default styles for 'default' and 'pointer' are provided\n\t * @default\n\t * \n\t */\n\tcursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\t/**\n\t * The DOM element to which the root event listeners are bound. This is automatically set to\n\t * the renderer's {@link Renderer#view view}.\n\t */\n\tdomElement: HTMLElement;\n\t/** The resolution used to convert between the DOM client space into world space. */\n\tresolution: number;\n\t/** The renderer managing this {@link EventSystem}. */\n\trenderer: Renderer;\n\t/**\n\t * The event features that are enabled by the EventSystem\n\t * @since 7.2.0\n\t * @example\n\t * const app = new Application()\n\t * app.renderer.events.features.globalMove = false\n\t *\n\t * // to override all features use Object.assign\n\t * Object.assign(app.renderer.events.features, {\n\t *  move: false,\n\t *  globalMove: false,\n\t *  click: false,\n\t *  wheel: false,\n\t * })\n\t */\n\treadonly features: EventSystemFeatures;\n\t/**\n\t * @param {Renderer} renderer\n\t */\n\tconstructor(renderer: Renderer);\n\t/** Destroys all event listeners and detaches the renderer. */\n\tdestroy(): void;\n\t/**\n\t * Sets the current cursor mode, handling any callbacks or CSS style changes.\n\t * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n\t * @param mode - Cursor mode to set. Can be:\n\t * - A CSS cursor string (e.g., 'pointer', 'grab')\n\t * - A key from the cursorStyles dictionary\n\t * - null/undefined to reset to default\n\t * @example\n\t * \n\t * @remarks\n\t * - Has no effect on OffscreenCanvas except for callback-based cursors\n\t * - Caches current cursor to avoid unnecessary DOM updates\n\t * - Supports CSS cursor values, style objects, and callback functions\n\t */\n\tsetCursor(mode: string): void;\n\t/**\n\t * The global pointer event instance containing the most recent pointer state.\n\t * This is useful for accessing pointer information without listening to events.\n\t * @example\n\t * \n\t * @since 7.2.0\n\t */\n\tget pointer(): Readonly<FederatedPointerEvent>;\n\t/**\n\t * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n\t * This method manages the DOM event bindings for the event system, allowing you to\n\t * change or remove the target element that receives input events.\n\t * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n\t * > should not need to call this unless you are using a custom element.\n\t * @param element - The new DOM element to bind events to, or null to remove all event bindings\n\t * @example\n\t * \n\t * @remarks\n\t * - Automatically removes event listeners from previous element\n\t * - Required for the event system to function\n\t * - Safe to call multiple times\n\t */\n\tsetTargetElement(element: HTMLElement): void;\n\t/**\n\t * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n\t * This takes into account the current scale, position, and resolution of the DOM element.\n\t * @param point - The point to store the mapped coordinates in\n\t * @param x - The x coordinate in DOM/client space\n\t * @param y - The y coordinate in DOM/client space\n\t * @example\n\t * \n\t * @remarks\n\t * - Accounts for element scaling and positioning\n\t * - Adjusts for device pixel ratio/resolution\n\t */\n\tmapPositionToPoint(point: PointData, x: number, y: number): void;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Container extends IFederatedContainer {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerOptions extends FederatedOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ContainerEvents extends FederatedEventEmitterTypes {\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\t/**\n\t\t\t * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n\t\t\t * @example\n\t\t\t * \n\t\t\t *\n\t\t\t * Available modes:\n\t\t\t * - `'none'`: Ignores all interaction events, even on its children\n\t\t\t * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and\n\t\t\t * non-interactive children. Interactive children will still emit events.\n\t\t\t * - `'auto'`: Does not emit events but is hit tested if parent is interactive.\n\t\t\t * Same as `interactive = false` in v7\n\t\t\t * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n\t\t\t * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n\t\t\t * a ticker to allow for interaction when the mouse isn't moving\n\t\t\t *\n\t\t\t * Performance tips:\n\t\t\t * - Use `'none'` for pure visual elements\n\t\t\t * - Use `'passive'` for containers with some interactive children\n\t\t\t * - Use `'static'` for standard buttons/controls\n\t\t\t * - Use `'dynamic'` only for moving/animated interactive elements\n\t\t\t * @since 7.2.0\n\t\t\t */\n\t\t\teventMode?: EventMode;\n\t\t\t/**\n\t\t\t * Configuration for enabling/disabling specific event features.\n\t\t\t * Use this to optimize performance by turning off unused functionality.\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @since 7.2.0\n\t\t\t */\n\t\t\teventFeatures?: EventSystemOptions[\"eventFeatures\"];\n\t\t}\n\t\tinterface RendererSystems {\n\t\t\tevents: EventSystem;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tfilter: FilterSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\tfilter: FilterPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface Point extends Vector2Math {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ObservablePoint extends Vector2Math {\n\t\t}\n\t\tinterface Rectangle {\n\t\t\t/**\n\t\t\t * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @param {Rectangle} other - The Rectangle to compare with `this`\n\t\t\t * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n\t\t\t */\n\t\t\tequals(other: Rectangle): boolean;\n\t\t\t/**\n\t\t\t * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n\t\t\t * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n\t\t\t * with its properties set to zero.\n\t\t\t *\n\t\t\t * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n\t\t\t * and will always return an empty rectangle with its properties set to zero.\n\t\t\t *\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @param {Rectangle} other - The Rectangle to intersect with `this`.\n\t\t\t * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n\t\t\t * optional (otherwise will create a new Rectangle).\n\t\t\t * @returns {Rectangle} The intersection of `this` and `other`.\n\t\t\t */\n\t\t\tintersection<T extends Rectangle = Rectangle>(other: Rectangle, outRect?: T): T;\n\t\t\t/**\n\t\t\t * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n\t\t\t * the horizontal and vertical space between the two rectangles.\n\t\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t\t * @example\n\t\t\t * \n\t\t\t * @param {Rectangle} other - The Rectangle to unite with `this`\n\t\t\t * @param {Rectangle} [outRect] - Optional Rectangle to store the result\n\t\t\t * @returns The union of `this` and `other`\n\t\t\t */\n\t\t\tunion<T extends Rectangle = Rectangle>(other: Rectangle, outRect?: T): T;\n\t\t}\n\t}\n\tinterface Vector2Math {\n\t\t/**\n\t\t * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {PointData} other - The point to add to `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with addition result\n\t\t */\n\t\tadd<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {PointData} other - The point to subtract from `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with subtraction result\n\t\t */\n\t\tsubtract<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {PointData} other - The point to multiply with `this`\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with multiplication result\n\t\t */\n\t\tmultiply<T extends PointData = Point>(other: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {number} scalar - The number to multiply both components with\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with multiplication result\n\t\t */\n\t\tmultiplyScalar<T extends PointData = Point>(scalar: number, outPoint?: T): T;\n\t\t/**\n\t\t * Computes the dot product of `other` with `this` point.\n\t\t * The dot product is the sum of the products of the corresponding components of two vectors.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {PointData} other - The other point to calculate the dot product with\n\t\t * @returns The scalar result of the dot product\n\t\t */\n\t\tdot(other: PointData): number;\n\t\t/**\n\t\t * Computes the cross product of `other` with `this` point.\n\t\t * Returns the z-component of the 3D cross product, assuming z=0 for both vectors.\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @remarks\n\t\t * - Returns z-component only (x,y assumed in 2D plane)\n\t\t * - Positive result means counter-clockwise angle from this to other\n\t\t * - Magnitude equals area of parallelogram formed by vectors\n\t\t * @param {PointData} other - The other point to calculate the cross product with\n\t\t * @returns The z-component of the cross product\n\t\t */\n\t\tcross(other: PointData): number;\n\t\t/**\n\t\t * Computes a normalized version of `this` point.\n\t\t *\n\t\t * A normalized vector is a vector of magnitude (length) 1\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The normalized point\n\t\t */\n\t\tnormalize<T extends PointData = Point>(outPoint?: T): T;\n\t\t/**\n\t\t * Computes the magnitude (length) of this point as Euclidean distance from origin.\n\t\t *\n\t\t * Defined as the square root of the sum of the squares of each component.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @returns The magnitude (length) of the vector\n\t\t */\n\t\tmagnitude(): number;\n\t\t/**\n\t\t * Computes the squared magnitude of this point.\n\t\t * More efficient than magnitude() for length comparisons.\n\t\t *\n\t\t * Defined as the sum of the squares of each component.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @returns The squared magnitude of the vector\n\t\t */\n\t\tmagnitudeSquared(): number;\n\t\t/**\n\t\t * Computes vector projection of `this` on `onto`.\n\t\t * Projects one vector onto another, creating a parallel vector with the length of the projection.\n\t\t *\n\t\t * Imagine a light source, parallel to `onto`, above `this`.\n\t\t * The light would cast rays perpendicular to `onto`.\n\t\t * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @remarks\n\t\t * - Results in zero vector if projecting onto zero vector\n\t\t * - Length depends on angle between vectors\n\t\t * - Result is parallel to `onto` vector\n\t\t * - Useful for physics and collision responses\n\t\t * @param {PointData} onto - Vector to project onto (should be non-zero)\n\t\t * @param {PointData} [outPoint] - Optional Point-like object to store result\n\t\t * @returns The projection of `this` onto `onto`\n\t\t */\n\t\tproject<T extends PointData = Point>(onto: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Reflects `this` vector off of a plane orthogonal to `normal`.\n\t\t *\n\t\t * Like a light ray bouncing off a mirror surface.\n\t\t * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n\t\t * `this.reflect(normal)` is the reflection of `this` on that mirror.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @remarks\n\t\t * - Normal vector should be normalized for accurate results\n\t\t * - Preserves vector magnitude\n\t\t * - Useful for physics simulations\n\t\t * - Common in light/particle effects\n\t\t * @param {PointData} normal - The normal vector of the reflecting plane\n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The reflection of `this` off the plane\n\t\t */\n\t\treflect<T extends PointData = Point>(normal: PointData, outPoint?: T): T;\n\t\t/**\n\t\t * Rotates `this` vector.\n\t\t *\n\t\t * Like a light ray bouncing off a mirror surface.\n\t\t * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n\t\t * `this.reflect(normal)` is the reflection of `this` on that mirror.\n\t\t *\n\t\t * > [!IMPORTANT] Only available with **pixi.js/math-extras**.\n\t\t * @example\n\t\t * \n\t\t * @remarks\n\t\t * convert degrees to radians with const radians = degrees * (Math.PI / 180)\n\t\t * @param {PointData} radians - The rotation angle in radians\n\t\t * @param {PointData} outPoint - Optional Point-like object to store result\n\t\t * @returns The outPoint or a new Point with rotated result\n\t\t */\n\t\trotate<T extends PointData = Point>(radians: number, outPoint?: T): T;\n\t}\n}\n/**\n * Data structure for points with optional radius.\n */\nexport type RoundedPoint = PointData & {\n\tradius?: number;\n};\n/**\n * The line cap styles for strokes.\n *\n * It can be:\n * - `butt`: The ends of the stroke are squared off at the endpoints.\n * - `round`: The ends of the stroke are rounded.\n */\nexport type LineCap = \"butt\" | \"round\" | \"square\";\n/**\n * The line join styles for strokes.\n *\n * It can be:\n * - `round`: The corners of the stroke are rounded.\n * - `bevel`: The corners of the stroke are squared off.\n * - `miter`: The corners of the stroke are extended to meet at a point.\n */\nexport type LineJoin = \"round\" | \"bevel\" | \"miter\";\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n */\nexport type GradientType = \"linear\" | \"radial\";\n/**\n * Represents the style options for a linear gradient fill.\n */\nexport interface BaseGradientOptions {\n\t/** The type of gradient */\n\ttype?: GradientType;\n\t/** Array of colors stops to use in the gradient */\n\tcolorStops?: {\n\t\toffset: number;\n\t\tcolor: ColorSource;\n\t}[];\n\t/** Whether coordinates are 'global' or 'local' */\n\ttextureSpace?: TextureSpace;\n\t/**\n\t * The size of the texture to use for the gradient - this is for advanced usage.\n\t * The texture size does not need to match the size of the object being drawn.\n\t * Due to GPU interpolation, gradient textures can be relatively small!\n\t * Consider using a larger texture size if your gradient has a lot of very tight color steps\n\t */\n\ttextureSize?: number;\n\t/**\n\t * The wrap mode of the gradient.\n\t * This can be 'clamp-to-edge' or 'repeat'.\n\t * @default 'clamp-to-edge'\n\t */\n\twrapMode?: WRAP_MODE;\n}\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n */\nexport interface LinearGradientOptions extends BaseGradientOptions {\n\t/** The type of gradient. Must be 'linear' for linear gradients. */\n\ttype?: \"linear\";\n\t/**\n\t * The start point of the gradient.\n\t * This point defines where the gradient begins.\n\t * It is represented as a PointData object containing x and y coordinates.\n\t * The coordinates are in local space by default (0-1), but can be in global space if specified.\n\t */\n\tstart?: PointData;\n\t/**\n\t * The end point of the gradient.\n\t * This point defines where the gradient ends.\n\t * It is represented as a PointData object containing x and y coordinates.\n\t * The coordinates are in local space by default (0-1), but can be in global space if specified.\n\t */\n\tend?: PointData;\n}\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n */\nexport interface RadialGradientOptions extends BaseGradientOptions {\n\t/** The type of gradient. Must be 'radial' for radial gradients. */\n\ttype?: \"radial\";\n\t/** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n\tcenter?: PointData;\n\t/** The radius of the inner circle where the gradient begins. */\n\tinnerRadius?: number;\n\t/** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n\touterCenter?: PointData;\n\t/** The radius of the outer circle where the gradient ends. */\n\touterRadius?: number;\n\t/**\n\t * The y scale of the gradient, use this to make the gradient elliptical.\n\t * NOTE: Only applied to radial gradients used with Graphics.\n\t */\n\tscale?: number;\n\t/**\n\t * The rotation of the gradient in radians, useful for making the gradient elliptical.\n\t * NOTE: Only applied to radial gradients used with Graphics.\n\t */\n\trotation?: number;\n}\n/**\n * Options for creating a gradient fill.\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * \n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n */\nexport declare class FillGradient implements CanvasGradient {\n\t/** Default options for creating a gradient fill */\n\tstatic readonly defaultLinearOptions: LinearGradientOptions;\n\t/** Default options for creating a radial gradient fill */\n\tstatic readonly defaultRadialOptions: RadialGradientOptions;\n\t/** Type of gradient - currently only supports 'linear' */\n\treadonly type: GradientType;\n\t/** Internal texture used to render the gradient */\n\ttexture: Texture;\n\t/** Transform matrix for positioning the gradient */\n\ttransform: Matrix;\n\t/** Array of color stops defining the gradient */\n\tcolorStops: Array<{\n\t\toffset: number;\n\t\tcolor: string;\n\t}>;\n\t/** Whether gradient coordinates are in local or global space */\n\ttextureSpace: TextureSpace;\n\t/** The start point of the linear gradient */\n\tstart: PointData;\n\t/** The end point of the linear gradient */\n\tend: PointData;\n\t/** The center point of the inner circle of the radial gradient */\n\tcenter: PointData;\n\t/** The center point of the outer circle of the radial gradient */\n\touterCenter: PointData;\n\t/** The radius of the inner circle of the radial gradient */\n\tinnerRadius: number;\n\t/** The radius of the outer circle of the radial gradient */\n\touterRadius: number;\n\t/** The scale of the radial gradient */\n\tscale: number;\n\t/** The rotation of the radial gradient */\n\trotation: number;\n\t/**\n\t * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n\t * @param {GradientOptions} options - The options for the gradient\n\t */\n\tconstructor(options: GradientOptions);\n\t/**\n\t * Adds a color stop to the gradient\n\t * @param offset - Position of the stop (0-1)\n\t * @param color - Color of the stop\n\t * @returns This gradient instance for chaining\n\t */\n\taddColorStop(offset: number, color: ColorSource): this;\n\t/** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n\tdestroy(): void;\n\t/**\n\t * Returns a unique key for this gradient instance.\n\t * This key is used for caching and texture management.\n\t * @returns {string} Unique key for the gradient\n\t */\n\tget styleKey(): string;\n}\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n */\nexport type PatternRepetition = \"repeat\" | \"repeat-x\" | \"repeat-y\" | \"no-repeat\";\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport declare class FillPattern implements CanvasPattern {\n\t/** The transform matrix applied to the pattern */\n\ttransform: Matrix;\n\tconstructor(texture: Texture, repetition?: PatternRepetition);\n\t/**\n\t * Sets the transform for the pattern\n\t * @param transform - The transform matrix to apply to the pattern.\n\t * If not provided, the pattern will use the default transform.\n\t */\n\tsetTransform(transform?: Matrix): void;\n\t/** Internal texture used to render the gradient */\n\tget texture(): Texture;\n\tset texture(value: Texture);\n\t/**\n\t * Returns a unique key for this instance.\n\t * This key is used for caching.\n\t * @returns {string} Unique key for the instance\n\t */\n\tget styleKey(): string;\n\t/** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n\tdestroy(): void;\n}\n/**\n * Defines the style properties used for filling shapes in graphics and text operations.\n * This interface provides options for colors, textures, patterns, and gradients.\n * @example\n * \n */\nexport interface FillStyle {\n\t/**\n\t * The color to use for the fill.\n\t * This can be any valid color source, such as a hex value, a Color object, or a string.\n\t * @example\n\t * \n\t */\n\tcolor?: ColorSource;\n\t/**\n\t * The alpha value to use for the fill.\n\t * This value should be between 0 (fully transparent) and 1 (fully opaque).\n\t * @example\n\t * \n\t * @default 1\n\t */\n\talpha?: number;\n\t/**\n\t * The texture to use for the fill.\n\t * @example\n\t * \n\t */\n\ttexture?: Texture | null;\n\t/**\n\t * The transformation matrix to apply to the fill pattern or texture.\n\t * Used to scale, rotate, translate, or skew the fill.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tmatrix?: Matrix | null;\n\t/**\n\t * The fill pattern or gradient to use. This can be either a FillPattern for\n\t * repeating textures or a FillGradient for color transitions.\n\t * @example\n\t * \n\t */\n\tfill?: FillPattern | FillGradient | null;\n\t/**\n\t * Determines how texture coordinates are calculated across shapes.\n\t * - 'local': Texture coordinates are relative to each shape's bounds\n\t * - 'global': Texture coordinates are in world space\n\t * @example\n\t * \n\t * @default 'local'\n\t */\n\ttextureSpace?: TextureSpace;\n}\n/**\n * A stroke attribute object that defines how lines and shape outlines are drawn.\n * Controls properties like width, alignment, line caps, joins, and more.\n * @example\n * \n */\nexport interface StrokeAttributes {\n\t/**\n\t * The width of the stroke in pixels.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\twidth?: number;\n\t/**\n\t * The alignment of the stroke relative to the path.\n\t * - 1: Inside the shape\n\t * - 0.5: Centered on the path (default)\n\t * - 0: Outside the shape\n\t * @example\n\t * \n\t * @default 0.5\n\t */\n\talignment?: number;\n\t/**\n\t * The style to use for the ends of open paths.\n\t * - 'butt': Ends at path end\n\t * - 'round': Rounds past path end\n\t * - 'square': Squares past path end\n\t * @example\n\t * \n\t * @default 'butt'\n\t */\n\tcap?: LineCap;\n\t/**\n\t * The style to use where paths connect.\n\t * - 'miter': Sharp corner\n\t * - 'round': Rounded corner\n\t * - 'bevel': Beveled corner\n\t * @example\n\t * \n\t * @default 'miter'\n\t */\n\tjoin?: LineJoin;\n\t/**\n\t * Controls how far miter joins can extend. Only applies when join is 'miter'.\n\t * Higher values allow sharper corners.\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tmiterLimit?: number;\n\t/**\n\t * When true, ensures crisp 1px lines by aligning to pixel boundaries.\n\t * > [!NOTE] Only available for Graphics fills.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tpixelLine?: boolean;\n}\n/**\n * A stroke style object that combines fill properties with stroke attributes to define\n * both the visual style and stroke behavior of lines, shape outlines, and text strokes.\n * @example\n * \n */\nexport interface StrokeStyle extends FillStyle, StrokeAttributes {\n}\n/**\n * These can be directly used as a fill or a stroke\n * \n */\nexport type FillInput = ColorSource | FillGradient | FillPattern | FillStyle | Texture;\n/**\n * These can be directly used as a stroke\n * \n */\nexport type StrokeInput = ColorSource | FillGradient | FillPattern | StrokeStyle;\n/**\n * @deprecated since v8.1.6\n */\nexport type FillStyleInputs = ColorSource | FillGradient | FillPattern | FillStyle | ConvertedFillStyle | StrokeStyle | ConvertedStrokeStyle;\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n */\nexport declare class GraphicsContext extends EventEmitter<{\n\tupdate: GraphicsContext;\n\tdestroy: GraphicsContext;\n}> {\n\t/** The default fill style to use when none is provided. */\n\tstatic defaultFillStyle: ConvertedFillStyle;\n\t/** The default stroke style to use when none is provided. */\n\tstatic defaultStrokeStyle: ConvertedStrokeStyle;\n\t/** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n\tbatchMode: BatchMode;\n\t/**\n\t * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n\t * including the current drawing state, transformations, styles, and instructions.\n\t * @returns A new GraphicsContext instance with the same properties and state as this one.\n\t */\n\tclone(): GraphicsContext;\n\t/**\n\t * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n\t */\n\tget fillStyle(): ConvertedFillStyle;\n\tset fillStyle(value: FillInput);\n\t/**\n\t * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n\t */\n\tget strokeStyle(): ConvertedStrokeStyle;\n\tset strokeStyle(value: FillInput);\n\t/**\n\t * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n\t * pattern, or a more complex style defined by a FillStyle object.\n\t * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n\t *                or a FillStyle or ConvertedFillStyle object.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetFillStyle(style: FillInput): this;\n\t/**\n\t * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n\t * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n\t * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n\t *                or a StrokeStyle or ConvertedStrokeStyle object.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetStrokeStyle(style: StrokeInput): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n\t * If only a texture is provided, it uses the texture's width and height for drawing.\n\t * @param texture - The Texture object to use.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttexture(texture: Texture): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n\t * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n\t * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n\t * @param texture - The Texture object to use.\n\t * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n\t * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n\t * the source image.\n\t * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n\t * the source image.\n\t * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n\t * If not provided, uses the texture's frame width.\n\t * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n\t * If not provided, uses the texture's frame height.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttexture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n\t/**\n\t * Resets the current path. Any previous path and its commands are discarded and a new path is\n\t * started. This is typically called before beginning a new shape or series of drawing commands.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tbeginPath(): this;\n\t/**\n\t * Fills the current or given path with the current fill style. This method can optionally take\n\t * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n\t * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tfill(style?: FillInput): this;\n\t/** @deprecated 8.0.0 */\n\tfill(color: ColorSource, alpha: number): this;\n\t/**\n\t * Strokes the current path with the current stroke style. This method can take an optional\n\t * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n\t * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tstroke(style?: StrokeInput): this;\n\t/**\n\t * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n\t * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n\t * fail to cut correctly!\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tcut(): this;\n\t/**\n\t * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n\t * starting and ending angles, and direction.\n\t * @param x - The x-coordinate of the arc's center.\n\t * @param y - The y-coordinate of the arc's center.\n\t * @param radius - The arc's radius.\n\t * @param startAngle - The starting angle, in radians.\n\t * @param endAngle - The ending angle, in radians.\n\t * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n\t/**\n\t * Adds an arc to the current path with the given control points and radius, connected to the previous point\n\t * by a straight line if necessary.\n\t * @param x1 - The x-coordinate of the first control point.\n\t * @param y1 - The y-coordinate of the first control point.\n\t * @param x2 - The x-coordinate of the second control point.\n\t * @param y2 - The y-coordinate of the second control point.\n\t * @param radius - The arc's radius.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * @param rx - The x-radius of the ellipse.\n\t * @param ry - The y-radius of the ellipse.\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n\t * to the x-axis of the coordinate system, in degrees.\n\t * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n\t * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n\t * @param x - The x-coordinate of the arc's end point.\n\t * @param y - The y-coordinate of the arc's end point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic Bezier curve to the path.\n\t * It requires three points: the first two are control points and the third one is the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cp1x - The x-coordinate of the first control point.\n\t * @param cp1y - The y-coordinate of the first control point.\n\t * @param cp2x - The x-coordinate of the second control point.\n\t * @param cp2y - The y-coordinate of the second control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start.\n\t * If the shape is already closed or there are no points in the path, this method does nothing.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tclosePath(): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @param x - The x-coordinate of the center of the ellipse.\n\t * @param y - The y-coordinate of the center of the ellipse.\n\t * @param radiusX - The horizontal radius of the ellipse.\n\t * @param radiusY - The vertical radius of the ellipse.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n\t/**\n\t * Draws a circle shape. This method adds a new circle path to the current drawing.\n\t * @param x - The x-coordinate of the center of the circle.\n\t * @param y - The y-coordinate of the center of the circle.\n\t * @param radius - The radius of the circle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tcircle(x: number, y: number, radius: number): this;\n\t/**\n\t * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n\t * @param path - The `GraphicsPath` to add.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tpath(path: GraphicsPath): this;\n\t/**\n\t * Connects the current point to a new point with a straight line. This method updates the current path.\n\t * @param x - The x-coordinate of the new point to connect to.\n\t * @param y - The y-coordinate of the new point to connect to.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n\t * @param x - The x-coordinate for the starting point.\n\t * @param y - The y-coordinate for the starting point.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @param cpx - The x-coordinate of the control point.\n\t * @param cpy - The y-coordinate of the control point.\n\t * @param x - The x-coordinate of the end point.\n\t * @param y - The y-coordinate of the end point.\n\t * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tquadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @returns The instance of the current object for chaining.\n\t */\n\trect(x: number, y: number, w: number, h: number): this;\n\t/**\n\t * Draws a rectangle with rounded corners.\n\t * The corner radius can be specified to determine how rounded the corners should be.\n\t * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n\t * @param x - The x-coordinate of the top-left corner of the rectangle.\n\t * @param y - The y-coordinate of the top-left corner of the rectangle.\n\t * @param w - The width of the rectangle.\n\t * @param h - The height of the rectangle.\n\t * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n\t/**\n\t * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n\t * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n\t * rotated, or translated as needed.\n\t * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n\t * representing the x and y coordinates, of the polygon's vertices, in sequence.\n\t * @param close - A boolean indicating whether to close the polygon path. True by default.\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n\t * @returns The instance of the current object for chaining.\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @param x - The x-coordinate of the center of the polygon.\n\t * @param y - The y-coordinate of the center of the polygon.\n\t * @param radius - The radius of the circumscribed circle of the polygon.\n\t * @param sides - The number of sides of the polygon. Must be 3 or more.\n\t * @param corner - The radius of the rounding of the corners.\n\t * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n\t * A minimum of 3 points is required.\n\t * @param radius - The default radius for the corners.\n\t * This radius is applied to all corners unless overridden in `points`.\n\t * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n\t *  method instead of an arc method. Defaults to false.\n\t * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n\t * Higher values make the curve smoother.\n\t * @returns The instance of the current object for chaining.\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draw Rectangle with fillet corners. This is much like rounded rectangle\n\t * however it support negative numbers as well for the corner radius.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param fillet - accept negative or positive values\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draw Rectangle with chamfer corners. These are angled corners.\n\t * @param x - Upper left corner of rect\n\t * @param y - Upper right corner of rect\n\t * @param width - Width of rect\n\t * @param height - Height of rect\n\t * @param chamfer - non-zero real number, size of corner cutout\n\t * @param transform\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws a star shape centered at a specified location. This method allows for the creation\n\t *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n\t * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n\t * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n\t * @param x - The x-coordinate of the center of the star.\n\t * @param y - The y-coordinate of the center of the star.\n\t * @param points - The number of points of the star.\n\t * @param radius - The outer radius of the star (distance from the center to the outer points).\n\t * @param innerRadius - Optional. The inner radius of the star\n\t * (distance from the center to the inner points between the outer points).\n\t * If not provided, defaults to half of the `radius`.\n\t * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n\t * Defaults to 0, meaning one point is directly upward.\n\t * @returns The instance of the current object for chaining further drawing commands.\n\t */\n\tstar(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n\t/**\n\t * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n\t * defined in SVG format to be drawn within the graphics context.\n\t * @param svg - The SVG string to be parsed and rendered.\n\t */\n\tsvg(svg: string): this;\n\t/**\n\t * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n\t * This includes transformations, fill styles, and stroke styles.\n\t */\n\trestore(): this;\n\t/** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n\tsave(): this;\n\t/**\n\t * Returns the current transformation matrix of the graphics context.\n\t * @returns The current transformation matrix.\n\t */\n\tgetTransform(): Matrix;\n\t/**\n\t * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tresetTransform(): this;\n\t/**\n\t * Applies a rotation transformation to the graphics context around the current origin.\n\t * @param angle - The angle of rotation in radians.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\trotate(angle: number): this;\n\t/**\n\t * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n\t * @param x - The scale factor in the horizontal direction.\n\t * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param transform - The matrix to set as the current transformation matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(transform: Matrix): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param transform - The matrix to apply to the current transformation.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(transform: Matrix): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\t/**\n\t * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n\t * @param x - The amount to translate in the horizontal direction.\n\t * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttranslate(x: number, y?: number): this;\n\t/**\n\t * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n\t * and optionally resetting transformations to the identity matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tclear(): this;\n\t/** The bounds of the graphic shape. */\n\tget bounds(): Bounds;\n\t/**\n\t * Check to see if a point is contained within this geometry.\n\t * @param point - Point to check if it's contained.\n\t * @returns {boolean} `true` if the point is contained within geometry.\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys the GraphicsData object.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * context.destroy();\n\t * context.destroy(true);\n\t * context.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: TypeOrBool<TextureDestroyOptions>): void;\n}\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * \n */\nexport type TextStyleAlign = \"left\" | \"center\" | \"right\" | \"justify\";\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * \n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * \n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n */\nexport type TextStyleFontStyle = \"normal\" | \"italic\" | \"oblique\";\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * \n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n */\nexport type TextStyleFontVariant = \"normal\" | \"small-caps\";\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * \n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n */\nexport type TextStyleFontWeight = \"normal\" | \"bold\" | \"bolder\" | \"lighter\" | \"100\" | \"200\" | \"300\" | \"400\" | \"500\" | \"600\" | \"700\" | \"800\" | \"900\";\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * \n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n */\nexport type TextStyleLineJoin = \"miter\" | \"round\" | \"bevel\";\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n */\nexport type TextStyleTextBaseline = \"alphabetic\" | \"top\" | \"hanging\" | \"middle\" | \"ideographic\" | \"bottom\";\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * \n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n */\nexport type TextStyleWhiteSpace = \"normal\" | \"pre\" | \"pre-line\";\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * \n */\nexport type TextDropShadow = {\n\t/**\n\t * The opacity of the drop shadow.\n\t * - Range: 0 to 1\n\t * - 0 = fully transparent\n\t * - 1 = fully opaque\n\t * @example\n\t * \n\t * @default 1\n\t */\n\talpha: number;\n\t/**\n\t * The angle of the drop shadow in radians.\n\t * - 0 = right\n\t * - Math.PI/2 = down\n\t * - Math.PI = left\n\t * - Math.PI*1.5 = up\n\t * @example\n\t * \n\t * @default Math.PI/6 (30 degrees)\n\t */\n\tangle: number;\n\t/**\n\t * The blur radius of the shadow.\n\t * - 0 = sharp shadow\n\t * - Higher values = softer shadow\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tblur: number;\n\t/**\n\t * The color of the drop shadow.\n\t * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n\t * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n\t * @default 'black'\n\t */\n\tcolor: ColorSource;\n\t/**\n\t * The distance of the drop shadow from the text.\n\t * Measured in pixels.\n\t * @example\n\t * \n\t * @default 5\n\t */\n\tdistance: number;\n};\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * \n */\nexport interface TextStyleOptions {\n\t/**\n\t * Alignment for multiline text, does not affect single line text\n\t * @default 'left'\n\t */\n\talign?: TextStyleAlign;\n\t/**\n\t * Whether to allow line breaks within words.\n\t * Requires wordWrap to be true.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tbreakWords?: boolean;\n\t/**\n\t * Drop shadow configuration for the text.\n\t * Can be boolean or a TextDropShadow object.\n\t * @default null\n\t */\n\tdropShadow?: boolean | Partial<TextDropShadow>;\n\t/**\n\t * Fill style for the text.\n\t * Can be a color, gradient, or pattern.\n\t * @default 'black'\n\t */\n\tfill?: FillInput;\n\t/**\n\t * Font family or families to use.\n\t * Can be single name or array of fallbacks.\n\t * @example\n\t * \n\t * @default 'Arial'\n\t */\n\tfontFamily?: string | string[];\n\t/**\n\t * Font size in pixels or as string.\n\t *\n\t * Equivalents are '26px','20pt','160%' or '1.6em')\n\t * @example\n\t * ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ts\n\t * // Customize default settings globally\n\t * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n\t * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n\t * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n\t * ts\n\t * // Customize default text style globally\n\t * TextStyle.defaultTextStyle.fontSize = 16;\n\t * TextStyle.defaultTextStyle.fill = 0x333333;\n\t * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n\t * ts\n * // Basic HTML text style\n * const text = new HTMLText({\n *     text: '<p>Hello World</p>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#ff0000',\n *         fontFamily: 'Arial',\n *         align: 'center'\n *     }\n * });\n *\n * // Custom tag styling\n * const taggedText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontSize: 16,\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n * });\n * ts\n\t * const text = new HTMLText({\n\t *     text: `\n\t *         <red>Main Title</red>\n\t *         <grey>The subtitle</grey>\n\t *         <blue>Regular content text</blue>\n\t *     `,\n\t *     style: {\n\t *         tagStyles: {\n\t *             red: {\n\t *                 fill: '#ff0000',\n\t *             },\n\t *             grey: {\n\t *                 fill: '#666666',\n\t *             },\n\t *             blue: {\n\t *                 fill: 'blue',\n\t *             }\n\t *         }\n\t *     }\n\t * });\n\t * ts\n\t * // Create original style\n\t * const originalStyle = new HTMLTextStyle({\n\t *     fontSize: 24,\n\t *     fill: '#ff0000',\n\t *     tagStyles: {\n\t *         header: { fontSize: 32, fill: '#00ff00' }\n\t *     }\n\t * });\n\t *\n\t * // Clone the style\n\t * const clonedStyle = originalStyle.clone();\n\t *\n\t * // Modify cloned style independently\n\t * clonedStyle.fontSize = 36;\n\t * clonedStyle.fill = '#0000ff';\n\t *\n\t * // Original style remains unchanged\n\t * console.log(originalStyle.fontSize); // Still 24\n\t * console.log(originalStyle.fill); // Still '#ff0000'\n\t * ts\n\t * // Using hex colors\n\t * const text = new HTMLText({\n\t *     text: 'Colored Text',\n\t *     style: {\n\t *         fill: 0xff0000 // Red color\n\t *     }\n\t * });\n\t *\n\t * // Using CSS color strings\n\t * text.style.fill = '#00ff00';     // Hex string (Green)\n\t * text.style.fill = 'blue';        // Named color\n\t * text.style.fill = 'rgb(255,0,0)' // RGB\n\t * text.style.fill = '#f0f';        // Short hex\n\t *\n\t * // Invalid usage (will trigger warning in debug)\n\t * text.style.fill = {\n\t *     type: 'pattern',\n\t *     texture: Texture.from('pattern.png')\n\t * }; // Not supported, falls back to default\n\t * ts\n\t * // Using hex colors\n\t * const text = new HTMLText({\n\t *     text: 'Outlined Text',\n\t *     style: {\n\t *         stroke: 0xff0000 // Red outline\n\t *     }\n\t * });\n\t *\n\t * // Using CSS color strings\n\t * text.style.stroke = '#00ff00';     // Hex string (Green)\n\t * text.style.stroke = 'blue';        // Named color\n\t * text.style.stroke = 'rgb(255,0,0)' // RGB\n\t * text.style.stroke = '#f0f';        // Short hex\n\t *\n\t * // Using stroke width\n\t * text.style = {\n\t *     stroke: {\n\t *         color: '#ff0000',\n\t *         width: 2\n\t *     }\n\t * };\n\t *\n\t * // Remove stroke\n\t * text.style.stroke = null;\n\t *\n\t * // Invalid usage (will trigger warning in debug)\n\t * text.style.stroke = {\n\t *     type: 'pattern',\n\t *     texture: Texture.from('pattern.png')\n\t * }; // Not supported, falls back to default\n\t * ts\n * const text: TextString = 'Hello Pixi!';\n * const text2: TextString = 12345;\n * const text3: TextString = { toString: () => 'Hello Pixi!' };\n * ts\n * import { TextStyle, HTMLTextStyle } from 'pixi.js';\n * const style: AnyTextStyle = new TextStyle({ fontSize: 24 });\n * const htmlStyle: AnyTextStyle = new HTMLTextStyle({ fontSize: '24px' });\n * ts\n * import { TextStyleOptions, HTMLTextStyleOptions } from 'pixi.js';\n * const styleOptions: AnyTextStyleOptions = { fontSize: 24 } as TextStyleOptions;\n * const htmlStyleOptions: AnyTextStyleOptions = { fontSize: '24px' } as HTMLTextStyleOptions;\n * ts\n * // Create basic text with minimal options\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Create text with advanced styling\n * const styledText = new Text({\n *     text: 'Styled Text',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: new FillGradient({\n *             end: { x: 1, y: 1 },\n *             stops: [\n *                 { color: 0xff0000, offset: 0 }, // Red at start\n *                 { color: 0x0000ff, offset: 1 }, // Blue at end\n *             ]\n *         }),\n *         stroke: { color: '#4a1850', width: 5 },\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6\n *         },\n *         align: 'center'\n *     },\n *     anchor: 0.5,\n *     resolution: window.devicePixelRatio\n * });\n *\n * // Create multiline text with word wrap\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will wrap onto multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30\n *     },\n *     resolution: 2,\n *     roundPixels: true\n * });\n * ts\n\t * // Set anchor to center\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n\t * });\n\t * // Set anchor to top-left\n\t * const text2 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 0, y: 0 } // Top-left corner\n\t * });\n\t * // Set anchor to bottom-right\n\t * const text3 = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     anchor: { x: 1, y: 1 } // Bottom-right corner\n\t * });\n\t * ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t * });\n\t * const multilineText = new Text({\n\t *     text: 'Line 1\\nLine 2\\nLine 3',\n\t * });\n\t * const numberText = new Text({\n\t *     text: 12345, // Will be converted to '12345'\n\t * });\n\t * const objectText = new Text({\n\t *     text: { toString: () => 'Object Text' }, // Custom toString\n\t * });\n\t * ts\n\t * const text = new Text({\n\t *     text: 'Hello Pixi!',\n\t *     resolution: 2 // High DPI for sharper text\n\t * });\n\t * const autoResText = new Text({\n\t *     text: 'Auto Resolution',\n\t *     resolution: null // Use device's pixel ratio\n\t * });\n\t * ts\n\t * const text = new Text({\n\t *     text: 'Styled Text',\n\t *     style: {\n\t *         fontSize: 24,\n\t *         fill: 0xff1010, // Red color\n\t *         fontFamily: 'Arial',\n\t *         align: 'center', // Center alignment\n\t *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n\t *         dropShadow: {\n\t *             color: '#000000', // Black shadow\n\t *             blur: 4, // Shadow blur\n\t *             distance: 6 // Shadow distance\n\t *         }\n\t *     }\n\t * });\n\t * const htmlText = new HTMLText({\n\t *     text: 'HTML Styled Text',\n\t *     style: {\n\t *         fontSize: '20px',\n\t *         fill: 'blue',\n\t *         fontFamily: 'Verdana',\n\t *     }\n\t * });\n\t * const bitmapText = new BitmapText({\n\t *     text: 'Bitmap Styled Text',\n\t *     style: {\n\t *         fontName: 'Arial',\n\t *         fontSize: 32,\n\t *     }\n\t * })\n\t */\n\tstyle?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n\t/**\n\t * Whether to round the x/y position to whole pixels.\n\t * Enabling can prevent anti-aliasing of text edges but may cause slight position shifting.\n\t * @example\n\t * ts\n * // Create basic canvas text\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010,\n *     }\n * });\n *\n * // Create text with custom texture style\n * const customText = new Text({\n *     text: 'Custom Text',\n *     style: {\n *         fontSize: 32,\n *         fill: 0x4a4a4a\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n * ts\n * import { Text } from 'pixi.js';\n *\n * // Basic text creation\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Rich text with multiple styles\n * const richText = new Text({\n *     text: 'Styled\\nMultiline\\nText',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 36,\n *         fill: 'red',\n *         stroke: { color: '#4a1850', width: 5 },\n *         align: 'center',\n *         lineHeight: 45,\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6,\n *         }\n *     },\n *     anchor: 0.5,\n * });\n *\n * // Text with custom texture settings\n * const crispText = new Text({\n *     text: 'High Quality Text',\n *     style: {\n *         fontSize: 24,\n *         fill: 0x4a4a4a,\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n *\n * // Word-wrapped text\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will automatically wrap to multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30,\n *     }\n * });\n * ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ts\n\t * const sharedContext = new GraphicsContext();\n\t * const graphics1 = new Graphics({ context: sharedContext });\n\t * const graphics2 = new Graphics({ context: sharedContext });\n\t * ts\n\t * const graphics = new Graphics({ roundPixels: true });\n\t * ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ts\n\t * // Create a shared context\n\t * const sharedContext = new GraphicsContext();\n\t *\n\t * // Create graphics objects sharing the same context\n\t * const graphics1 = new Graphics();\n\t * const graphics2 = new Graphics();\n\t *\n\t * // Assign shared context\n\t * graphics1.context = sharedContext;\n\t * graphics2.context = sharedContext;\n\t *\n\t * // Both graphics will show the same shapes\n\t * sharedContext\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a shape\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Get bounds information\n\t * const bounds = graphics.bounds;\n\t * console.log(bounds.width);  // 100\n\t * console.log(bounds.height); // 100\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a shape\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Check point intersection\n\t * if (graphics.containsPoint({ x: 50, y: 50 })) {\n\t *     console.log('Point is inside rectangle!');\n\t * }\n\t * ts\n\t * // Destroy the graphics and its context\n\t * graphics.destroy();\n\t * graphics.destroy(true);\n\t * graphics.destroy({ context: true, texture: true, textureSource: true });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color fill\n\t * graphics\n\t *     .setFillStyle({ color: 0xff0000 }) // Red fill\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill();\n\t *\n\t * // Gradient fill\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    colorStops: [\n\t *         { offset: 0, color: 0xff0000 }, // Red at start\n\t *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *         { offset: 1, color: 0x0000ff }, // Blue at end\n\t *    ],\n\t * });\n\t *\n\t * graphics\n\t *     .setFillStyle(gradient)\n\t *     .circle(100, 100, 50)\n\t *     .fill();\n\t *\n\t * // Pattern fill\n\t * const pattern = new FillPattern(texture);\n\t * graphics\n\t *     .setFillStyle({\n\t *         fill: pattern,\n\t *         alpha: 0.5\n\t *     })\n\t *     .rect(0, 0, 200, 200)\n\t *     .fill();\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color stroke\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 2,\n\t *         color: 0x000000\n\t *     })\n\t *     .rect(0, 0, 100, 100)\n\t *     .stroke();\n\t *\n\t * // Complex stroke style\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 4,\n\t *         color: 0xff0000,\n\t *         alpha: 0.5,\n\t *         join: 'round',\n\t *         cap: 'round',\n\t *         alignment: 0.5\n\t *     })\n\t *     .circle(100, 100, 50)\n\t *     .stroke();\n\t *\n\t * // Gradient stroke\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    colorStops: [\n\t *         { offset: 0, color: 0xff0000 }, // Red at start\n\t *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *         { offset: 1, color: 0x0000ff }, // Blue at end\n\t *    ],\n\t * });\n\t *\n\t * graphics\n\t *     .setStrokeStyle({\n\t *         width: 10,\n\t *         fill: gradient\n\t *     })\n\t *     .poly([0,0, 100,50, 0,100])\n\t *     .stroke();\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Fill with direct color\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .fill('red'); // Red fill\n\t *\n\t * // Fill with texture\n\t * graphics\n\t *    .rect(0, 0, 100, 100)\n\t *    .fill(myTexture); // Fill with texture\n\t *\n\t * // Fill with complex style\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .fill({\n\t *         color: 0x00ff00,\n\t *         alpha: 0.5,\n\t *         texture: myTexture,\n\t *         matrix: new Matrix()\n\t *     });\n\t *\n\t * // Fill with gradient\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *         { offset: 0, color: 0xff0000 },\n\t *         { offset: 0.5, color: 0x00ff00 },\n\t *         { offset: 1, color: 0x0000ff },\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill(gradient);\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Stroke with direct color\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .stroke({\n\t *         width: 2,\n\t *         color: 0xff0000\n\t *     }); // 2px red stroke\n\t *\n\t * // Fill with texture\n\t * graphics\n\t *    .rect(0, 0, 100, 100)\n\t *    .stroke(myTexture); // Fill with texture\n\t *\n\t * // Stroke with gradient\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *         { offset: 0, color: 0xff0000 },\n\t *         { offset: 0.5, color: 0x00ff00 },\n\t *         { offset: 1, color: 0x0000ff },\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .rect(0, 0, 100, 100)\n\t *     .stroke({\n\t *         width: 4,\n\t *         fill: gradient,\n\t *         alignment: 0.5,\n\t *         join: 'round'\n\t *     });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic texture drawing\n\t * graphics.texture(myTexture);\n\t *\n\t * // Tinted texture with position\n\t * graphics.texture(myTexture, 0xff0000); // Red tint\n\t *\n\t * // Texture with custom position and dimensions\n\t * graphics\n\t *     .texture(\n\t *         myTexture,    // texture\n\t *         0xffffff,     // white tint\n\t *         100, 100,     // position\n\t *         200, 150      // dimensions\n\t *     );\n\t * ts\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .circle(150, 150, 50)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .beginPath() // Starts a new path\n\t *     .circle(250, 150, 50)\n\t *     .fill({ color: 0x0000ff });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw outer circle\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *     .circle(100, 100, 25) // Inner circle\n\t *     .cut() // Cuts out the inner circle from the outer circle\n\t * ts\n\t * // Draw a simple arc (quarter circle)\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .arc(100, 100, 50, 0, Math.PI/2)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Draw a full circle using an arc\n\t * graphics\n\t *     .arc(200, 200, 30, 0, Math.PI * 2)\n\t *     .stroke({ color: 0x00ff00 });\n\t *\n\t * // Draw a counterclockwise arc\n\t * graphics\n\t *     .arc(150, 150, 40, Math.PI, 0, true)\n\t *     .stroke({ width: 2, color: 0x0000ff });\n\t * ts\n\t * // Draw a simple curved corner\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create a rounded rectangle using arcTo\n\t * graphics\n\t *     .moveTo(150, 150)\n\t *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n\t *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n\t *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n\t *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n\t *     .fill({ color: 0x00ff00 });\n\t * ts\n\t * // Draw a simple elliptical arc\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(100, 100)\n\t *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create a complex path with rotated elliptical arc\n\t * graphics\n\t *     .moveTo(150, 150)\n\t *     .arcToSvg(\n\t *         60,    // rx\n\t *         30,    // ry\n\t *         45,    // x-axis rotation (45 degrees)\n\t *         1,     // large arc flag\n\t *         0,     // sweep flag\n\t *         250,   // end x\n\t *         200    // end y\n\t *     )\n\t *     .stroke({ width: 4, color: 0x00ff00 });\n\t *\n\t * // Chain multiple arcs for complex shapes\n\t * graphics\n\t *     .moveTo(300, 100)\n\t *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n\t *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ts\n\t * // Draw a simple curved line\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .bezierCurveTo(\n\t *         100, 25,   // First control point\n\t *         150, 75,   // Second control point\n\t *         200, 50    // End point\n\t *     )\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Adjust curve smoothness\n\t * graphics\n\t *     .moveTo(50, 200)\n\t *     .bezierCurveTo(\n\t *         100, 150,\n\t *         200, 250,\n\t *         250, 200,\n\t *         0.5         // Smoothness factor\n\t *     )\n\t *     .stroke({ width: 4, color: 0x0000ff });\n\t * ts\n\t * // Create a triangle with closed path\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 100)\n\t *     .lineTo(0, 100)\n\t *     .closePath()\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic ellipse\n\t * graphics\n\t *     .ellipse(100, 100, 50, 30)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw an ellipse with stroke\n\t * graphics\n\t *     .ellipse(200, 100, 70, 40)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple filled circle\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a circle with gradient fill\n\t * const gradient = new FillGradient({\n\t *     end: { x: 1, y: 0 },\n\t *     colorStops: [\n\t *           { offset: 0, color: 0xff0000 }, // Red at start\n\t *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n\t *           { offset: 1, color: 0x0000ff }, // Blue at end\n\t *     ],\n\t * });\n\t *\n\t * graphics\n\t *     .circle(250, 100, 40)\n\t *     .fill({ fill: gradient });\n\t * ts\n\t * const graphics = new Graphics();\n\t * // Create a reusable path\n\t * const heartPath = new GraphicsPath()\n\t *     .moveTo(0, 0)\n\t *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n\t *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n\t *\n\t * // Use the path multiple times\n\t * graphics\n\t *     .path(heartPath)\n\t *     .fill({ color: 0xff0000 })\n\t *     .translateTransform(200, 200)\n\t *     .path(heartPath)\n\t *     .fill({ color: 0xff0000, alpha: 0.5 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a triangle\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 100)\n\t *     .lineTo(0, 100)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Create a complex shape with multiple lines\n\t * graphics\n\t *     .moveTo(200, 50)\n\t *     .lineTo(250, 50)\n\t *     .lineTo(250, 100)\n\t *     .lineTo(200, 100)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Create multiple separate lines\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(100, 50)\n\t *     .moveTo(50, 100)    // Start a new line\n\t *     .lineTo(100, 100)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Create disconnected shapes\n\t * graphics\n\t *     .moveTo(150, 50)\n\t *     .rect(150, 50, 50, 50)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .moveTo(250, 50)    // Start a new shape\n\t *     .circle(250, 75, 25)\n\t *     .fill({ color: 0x0000ff });\n\t *\n\t * // Position before curved paths\n\t * graphics\n\t *     .moveTo(300, 50)\n\t *     .bezierCurveTo(\n\t *         350, 25,   // Control point 1\n\t *         400, 75,   // Control point 2\n\t *         450, 50    // End point\n\t *     )\n\t *     .stroke({ width: 3, color: 0xff00ff });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple curve\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .quadraticCurveTo(100, 25, 150, 50)\n\t *     .stroke({ width: 2, color: 0xff0000 });\n\t *\n\t * // Adjust curve smoothness\n\t * graphics\n\t *     .moveTo(50, 200)\n\t *     .quadraticCurveTo(\n\t *         150, 150,   // Control point\n\t *         250, 200,   // End point\n\t *         0.5         // Smoothness factor\n\t *     )\n\t *     .stroke({\n\t *         width: 4,\n\t *         color: 0x0000ff,\n\t *         alpha: 0.7\n\t *     });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple filled rectangle\n\t * graphics\n\t *     .rect(50, 50, 100, 75)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Rectangle with stroke\n\t * graphics\n\t *     .rect(200, 50, 100, 75)\n\t *     .stroke({ width: 2, color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic rounded rectangle\n\t * graphics\n\t *     .roundRect(50, 50, 100, 75, 15)\n\t *     .fill({ color: 0xff0000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n\t * graphics\n\t *     .poly([50,50, 100,100, 0,100], true)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a polygon using point objects\n\t * graphics\n\t *     .poly([\n\t *         { x: 200, y: 50 },\n\t *         { x: 250, y: 100 },\n\t *         { x: 200, y: 150 },\n\t *         { x: 150, y: 100 }\n\t *     ])\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Draw an open polygon with stroke\n\t * graphics\n\t *     .poly([300,50, 350,50, 350,100, 300,100], false)\n\t *     .stroke({\n\t *         width: 2,\n\t *         color: 0x0000ff,\n\t *         join: 'round'\n\t *     });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a simple triangle (3 sides)\n\t * graphics\n\t *     .regularPoly(100, 100, 50, 3)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a hexagon (6 sides) with rotation\n\t * graphics\n\t *     .regularPoly(\n\t *         250, 100,    // center position\n\t *         40,          // radius\n\t *         6,           // sides\n\t *         Math.PI / 6  // rotation (30 degrees)\n\t *     )\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t *\n\t * // Draw an octagon (8 sides) with transform\n\t * const transform = new Matrix()\n\t *     .scale(1.5, 1)      // stretch horizontally\n\t *     .rotate(Math.PI/4); // rotate 45 degrees\n\t *\n\t * graphics\n\t *     .regularPoly(400, 100, 30, 8, 0, transform)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic rounded triangle\n\t * graphics\n\t *     .roundPoly(100, 100, 50, 3, 10)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a rounded hexagon with rotation\n\t * graphics\n\t *     .roundPoly(\n\t *         250, 150,     // center position\n\t *         40,           // radius\n\t *         6,            // sides\n\t *         8,            // corner radius\n\t *         Math.PI / 6   // rotation (30 degrees)\n\t *     )\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a custom shape with rounded corners\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 100, y: 100, radius: 20 },\n\t *         { x: 200, y: 100, radius: 10 },\n\t *         { x: 200, y: 200, radius: 15 },\n\t *         { x: 100, y: 200, radius: 5 }\n\t *     ], 10)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using quadratic curves for corners\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 250, y: 100 },\n\t *         { x: 350, y: 100 },\n\t *         { x: 350, y: 200 },\n\t *         { x: 250, y: 200 }\n\t *     ], 15, true, 0.5)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t *\n\t * // Shape with varying corner radii\n\t * graphics\n\t *     .roundShape([\n\t *         { x: 400, y: 100, radius: 30 },\n\t *         { x: 500, y: 100, radius: 5 },\n\t *         { x: 450, y: 200, radius: 15 }\n\t *     ], 10)\n\t *     .fill({ color: 0x0000ff, alpha: 0.5 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a rectangle with internal fillets\n\t * graphics\n\t *     .filletRect(50, 50, 100, 80, 15)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Draw a rectangle with external fillets\n\t * graphics\n\t *     .filletRect(200, 50, 100, 80, -20)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic chamfered rectangle\n\t * graphics\n\t *     .chamferRect(50, 50, 100, 80, 15)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Add transform and stroke\n\t * const transform = new Matrix()\n\t *     .rotate(Math.PI / 4); // 45 degrees\n\t *\n\t * graphics\n\t *     .chamferRect(200, 50, 100, 80, 20, transform)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw a basic 5-pointed star\n\t * graphics\n\t *     .star(100, 100, 5, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Star with custom inner radius\n\t * graphics\n\t *     .star(250, 100, 6, 50, 20)\n\t *     .fill({ color: 0x00ff00 })\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t * graphics\n\t *     .svg(`\n\t *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n\t *               fill=\"blue\" />\n\t *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n\t *               fill=\"green\" />\n\t *     `)\n\t *     .stroke({ width: 2, color: 0x000000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Save current state\n\t * graphics.save();\n\t *\n\t * // Make temporary changes\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .setFillStyle({ color: 0xff0000 })\n\t *     .circle(0, 0, 50)\n\t *     .fill();\n\t *\n\t * // Restore to previous state\n\t * graphics.restore();\n\t *\n\t * // Draw with original transform and styles\n\t * graphics\n\t *     .circle(50, 50, 30)\n\t *     .fill();\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Save state before complex operations\n\t * graphics.save();\n\t *\n\t * // Create transformed and styled shape\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .rotateTransform(Math.PI / 4)\n\t *     .setFillStyle({\n\t *         color: 0xff0000,\n\t *         alpha: 0.5\n\t *     })\n\t *     .rect(-25, -25, 50, 50)\n\t *     .fill();\n\t *\n\t * // Restore to original state\n\t * graphics.restore();\n\t *\n\t * // Continue drawing with previous state\n\t * graphics\n\t *     .circle(50, 50, 25)\n\t *     .fill();\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Apply some transformations\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .rotateTransform(Math.PI / 4);\n\t *\n\t * // Get the current transform matrix\n\t * const matrix = graphics.getTransform();\n\t * console.log(matrix.tx, matrix.ty); // 100, 100\n\t *\n\t * // Use the matrix for other operations\n\t * graphics\n\t *     .setTransform(matrix)\n\t *     .circle(0, 0, 50)\n\t *     .fill({ color: 0xff0000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Apply transformations\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .scaleTransform(2, 2)\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t * // Reset transform to default state\n\t * graphics\n\t *     .resetTransform()\n\t *     .circle(50, 50, 25) // Will draw at actual coordinates\n\t *     .fill({ color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Rotate 45 degrees clockwise\n\t * graphics\n\t *     .rotateTransform(Math.PI / 4)\n\t *     .rect(-25, -25, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Uniform scaling\n\t * graphics\n\t *     .scaleTransform(2)  // Scale both dimensions by 2\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Non-uniform scaling\n\t * graphics\n\t *     .scaleTransform(0.5, 2)  // Half width, double height\n\t *     .rect(100, 100, 50, 50)\n\t *     .fill({ color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Using a Matrix object\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4);\n\t *\n\t * graphics\n\t *     .setTransform(matrix)\n\t *     .rect(0, 0, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using individual transform values\n\t * graphics\n\t *     .setTransform(\n\t *         2, 0,     // scale x by 2\n\t *         0, 1,     // no skew\n\t *         100, 100  // translate x,y by 100\n\t *     )\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Using a Matrix object\n\t * const matrix = new Matrix()\n\t *     .scale(2, 1)      // Scale horizontally\n\t *     .rotate(Math.PI/6); // Rotate 30 degrees\n\t *\n\t * graphics\n\t *     .transform(matrix)\n\t *     .rect(0, 0, 50, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Using individual transform values\n\t * graphics\n\t *     .transform(\n\t *         1, 0.5,    // Skew horizontally\n\t *         0, 1,      // No vertical skew\n\t *         100, 100   // Translate\n\t *     )\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0x00ff00 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic translation\n\t * graphics\n\t *     .translateTransform(100, 100)\n\t *     .circle(0, 0, 25)\n\t *     .fill({ color: 0xff0000 });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Draw some shapes\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 })\n\t *     .rect(200, 100, 100, 50)\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Clear all graphics\n\t * graphics.clear();\n\t *\n\t * // Start fresh with new shapes\n\t * graphics\n\t *     .circle(150, 150, 30)\n\t *     .fill({ color: 0x0000ff });\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic color fill\n\t * graphics.fillStyle = {\n\t *     color: 0xff0000,  // Red\n\t *     alpha: 1\n\t * };\n\t *\n\t * // Using gradients\n\t * const gradient = new FillGradient({\n\t *     end: { x: 0, y: 1 }, // Vertical gradient\n\t *     stops: [\n\t *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n\t *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n\t *     ]\n\t * });\n\t *\n\t * graphics.fillStyle = {\n\t *     fill: gradient,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // Using patterns\n\t * graphics.fillStyle = {\n\t *     texture: myTexture,\n\t *     alpha: 1,\n\t *     matrix: new Matrix()\n\t *         .scale(0.5, 0.5)\n\t *         .rotate(Math.PI / 4)\n\t * };\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Basic stroke style\n\t * graphics.strokeStyle = {\n\t *     width: 2,\n\t *     color: 0xff0000,\n\t *     alpha: 1\n\t * };\n\t *\n\t * // Using with gradients\n\t * const gradient = new FillGradient({\n\t *   end: { x: 0, y: 1 },\n\t *   stops: [\n\t *       { offset: 0, color: 0xff0000, alpha: 1 },\n\t *       { offset: 1, color: 0x0000ff, alpha: 1 }\n\t *   ]\n\t * });\n\t *\n\t * graphics.strokeStyle = {\n\t *     width: 4,\n\t *     fill: gradient,\n\t *     alignment: 0.5,\n\t *     join: 'round',\n\t *     cap: 'round'\n\t * };\n\t *\n\t * // Complex stroke settings\n\t * graphics.strokeStyle = {\n\t *     width: 6,\n\t *     color: 0x00ff00,\n\t *     alpha: 0.5,\n\t *     join: 'miter',\n\t *     miterLimit: 10,\n\t * };\n\t * ts\n\t * const graphics = new Graphics();\n\t *\n\t * // Create original graphics content\n\t * graphics\n\t *     .circle(100, 100, 50)\n\t *     .fill({ color: 0xff0000 });\n\t *\n\t * // Create a shallow clone (shared context)\n\t * const shallowClone = graphics.clone();\n\t *\n\t * // Changes to original affect the clone\n\t * graphics\n\t *     .circle(200, 100, 30)\n\t *     .fill({ color: 0x00ff00 });\n\t *\n\t * // Create a deep clone (independent context)\n\t * const deepClone = graphics.clone(true);\n\t *\n\t * // Modify deep clone independently\n\t * deepClone\n\t *     .translateTransform(100, 100)\n\t *     .circle(0, 0, 40)\n\t *     .fill({ color: 0x0000ff });\n\t * ts\n * // Using a Container as a mask\n * const maskContainer: Mask = new Graphics();\n * // Using a mask ID\n * const maskId: Mask = 123;\n * // No mask applied\n * const noMask: Mask = null;\n * ts\n * // Basic mask inversion\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true\n * });\n * ts\n\t * // Invert the mask\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: true\n\t * });\n\t * ts\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true,\n * });\n *\n * // Clear existing mask\n * sprite.setMask({\n *     mask: null,\n *     inverse: false,\n * });\n * ts\n\t * // Set a mask\n\t * sprite.setMask({\n\t *     mask: graphics,\n\t *     inverse: false,\n\t * });\n\t */\n\tmask: Mask;\n}\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * \n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n */\nexport declare class Circle implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the center of this circle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the center of this circle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The radius of the circle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tradius: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks.\n\t * @example\n\t * \n\t * @remarks\n\t * - Used for shape type checking\n\t * - More efficient than instanceof\n\t * - Read-only property\n\t * @default 'circle'\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * @param x - The X coordinate of the center of this circle\n\t * @param y - The Y coordinate of the center of this circle\n\t * @param radius - The radius of the circle\n\t */\n\tconstructor(x?: number, y?: number, radius?: number);\n\t/**\n\t * Creates a clone of this Circle instance.\n\t * @example\n\t * \n\t * @returns A copy of the Circle\n\t */\n\tclone(): Circle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this circle.\n\t *\n\t * Uses the distance formula to determine if a point is inside the circle's radius.\n\t *\n\t * Commonly used for hit testing in PixiJS events and graphics.\n\t * @example\n\t * \n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Circle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n\t * @example\n\t * \n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param width - The width of the line to check\n\t * @param alignment - The alignment of the stroke, 0.5 by default\n\t * @returns Whether the x/y coordinates are within this Circle's stroke\n\t */\n\tstrokeContains(x: number, y: number, width: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the circle as a Rectangle object.\n\t * @example\n\t * \n\t * @param out - Optional Rectangle object to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another circle to this one.\n\t * @example\n\t * \n\t * @param circle - The circle to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(circle: Circle): this;\n\t/**\n\t * Copies this circle to another one.\n\t * @example\n\t * \n\t * @param circle - The circle to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(circle: Circle): Circle;\n\ttoString(): string;\n}\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * \n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n */\nexport declare class Ellipse implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the center of this ellipse\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the center of this ellipse\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The half width of this ellipse\n\t * @example\n\t * \n\t * @default 0\n\t */\n\thalfWidth: number;\n\t/**\n\t * The half height of this ellipse\n\t * @example\n\t * \n\t * @default 0\n\t */\n\thalfHeight: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * \n\t * @default 'ellipse'\n\t */\n\treadonly type = \"ellipse\";\n\t/**\n\t * @param x - The X coordinate of the center of this ellipse\n\t * @param y - The Y coordinate of the center of this ellipse\n\t * @param halfWidth - The half width of this ellipse\n\t * @param halfHeight - The half height of this ellipse\n\t */\n\tconstructor(x?: number, y?: number, halfWidth?: number, halfHeight?: number);\n\t/**\n\t * Creates a clone of this Ellipse instance.\n\t * @example\n\t * \n\t * @returns A copy of the ellipse\n\t */\n\tclone(): Ellipse;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this ellipse.\n\t * Uses normalized coordinates and the ellipse equation to determine containment.\n\t * @example\n\t * \n\t * @remarks\n\t * - Uses ellipse equation (xÂ²/aÂ² + yÂ²/bÂ² â‰¤ 1)\n\t * - Returns false if dimensions are 0 or negative\n\t * - Normalized to center (0,0) for calculation\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coords are within this ellipse\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n\t * @example\n\t * \n\t * @remarks\n\t * - Uses normalized ellipse equations\n\t * - Considers stroke alignment\n\t * - Returns false if dimensions are 0\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coords are within this ellipse's stroke\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the ellipse as a Rectangle object.\n\t * @example\n\t * \n\t * @remarks\n\t * - Creates Rectangle if none provided\n\t * - Top-left is (x-halfWidth, y-halfHeight)\n\t * - Width is halfWidth * 2\n\t * - Height is halfHeight * 2\n\t * @param out - Optional Rectangle object to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another ellipse to this one.\n\t * @example\n\t * \n\t * @param ellipse - The ellipse to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(ellipse: Ellipse): this;\n\t/**\n\t * Copies this ellipse to another one.\n\t * @example\n\t * \n\t * @param ellipse - The ellipse to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(ellipse: Ellipse): Ellipse;\n\ttoString(): string;\n}\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * \n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n */\nexport declare class RoundedRectangle implements ShapePrimitive {\n\t/**\n\t * The X coordinate of the upper-left corner of the rounded rectangle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the upper-left corner of the rounded rectangle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The overall width of this rounded rectangle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\twidth: number;\n\t/**\n\t * The overall height of this rounded rectangle\n\t * @example\n\t * \n\t * @default 0\n\t */\n\theight: number;\n\t/**\n\t * Controls the radius of the rounded corners\n\t * @example\n\t * \n\t * @remarks\n\t * - Automatically clamped to half of smallest dimension\n\t * - Common values: 0-20 for UI elements\n\t * - Higher values create more rounded corners\n\t * @default 20\n\t */\n\tradius: number;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * \n\t * @default 'roundedRectangle'\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n\t * @param width - The overall width of this rounded rectangle\n\t * @param height - The overall height of this rounded rectangle\n\t * @param radius - Controls the radius of the rounded corners\n\t */\n\tconstructor(x?: number, y?: number, width?: number, height?: number, radius?: number);\n\t/**\n\t * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n\t * @example\n\t * \n\t * @remarks\n\t * - Rectangle matches outer dimensions\n\t * - Ignores corner radius\n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Creates a clone of this Rounded Rectangle.\n\t * @example\n\t * \n\t * @returns A copy of the rounded rectangle\n\t */\n\tclone(): RoundedRectangle;\n\t/**\n\t * Copies another rectangle to this one.\n\t * @example\n\t * \n\t * @param rectangle - The rectangle to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(rectangle: RoundedRectangle): this;\n\t/**\n\t * Copies this rectangle to another one.\n\t * @example\n\t * \n\t * @param rectangle - The rectangle to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(rectangle: RoundedRectangle): RoundedRectangle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n\t * @example\n\t * \n\t * @remarks\n\t * - Returns false if width/height is 0 or negative\n\t * - Handles rounded corners with radius check\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Rounded Rectangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n\t * @example\n\t * \n\t * @param pX - The X coordinate of the point to test\n\t * @param pY - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this rectangle's stroke\n\t */\n\tstrokeContains(pX: number, pY: number, strokeWidth: number, alignment?: number): boolean;\n\ttoString(): string;\n}\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * \n */\nexport declare class Polygon implements ShapePrimitive {\n\t/**\n\t * An array of the points of this polygon stored as a flat array of numbers.\n\t * @example\n\t * \n\t * @remarks\n\t * - Stored as [x1, y1, x2, y2, ...]\n\t * - Each pair represents a vertex\n\t * - Length is always even\n\t * - Can be modified directly\n\t */\n\tpoints: number[];\n\t/**\n\t * Indicates if the polygon path is closed.\n\t * @example\n\t * \n\t * @remarks\n\t * - True by default\n\t * - False after moveTo\n\t * - True after closePath\n\t * @default true\n\t */\n\tclosePath: boolean;\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * \n\t * @default 'polygon'\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\tconstructor(points: PointData[] | number[]);\n\tconstructor(...points: PointData[] | number[]);\n\t/**\n\t * Determines whether the polygon's points are arranged in a clockwise direction.\n\t * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n\t *\n\t * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n\t *\n\t * The formula sums up the cross products of adjacent vertices:\n\t * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n\t * The final sum divided by 2 gives the signed area - positive for clockwise.\n\t * @example\n\t * \n\t * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n\t */\n\tisClockwise(): boolean;\n\t/**\n\t * Checks if this polygon completely contains another polygon.\n\t * Used for detecting holes in shapes, like when parsing SVG paths.\n\t * @example\n\t * \n\t * @remarks\n\t * - Uses bounds check for quick rejection\n\t * - Tests all points for containment\n\t * @param polygon - The polygon to test for containment\n\t * @returns True if this polygon completely contains the other polygon\n\t */\n\tcontainsPolygon(polygon: Polygon): boolean;\n\t/**\n\t * Creates a clone of this polygon.\n\t * @example\n\t * \n\t * @returns A copy of the polygon\n\t */\n\tclone(): Polygon;\n\t/**\n\t * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n\t * Uses raycasting algorithm for point-in-polygon testing.\n\t * @example\n\t * \n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this polygon\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n\t * @example\n\t * \n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this polygon's stroke\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Returns the framing rectangle of the polygon as a Rectangle object.\n\t * @example\n\t * \n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Copies another polygon to this one.\n\t * @example\n\t * \n\t * @param polygon - The polygon to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(polygon: Polygon): this;\n\t/**\n\t * Copies this polygon to another one.\n\t * @example\n\t * \n\t * @param polygon - The polygon to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(polygon: Polygon): Polygon;\n\ttoString(): string;\n\t/**\n\t * Get the last X coordinate of the polygon.\n\t * @example\n\t * \n\t * @returns The x-coordinate of the last vertex\n\t */\n\tget lastX(): number;\n\t/**\n\t * Get the last Y coordinate of the polygon.\n\t * @example\n\t * \n\t * @returns The y-coordinate of the last vertex\n\t */\n\tget lastY(): number;\n\t/**\n\t * Get the last X coordinate of the polygon.\n\t * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n\t */\n\tget x(): number;\n\t/**\n\t * Get the last Y coordinate of the polygon.\n\t * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n\t */\n\tget y(): number;\n\t/**\n\t * Get the first X coordinate of the polygon.\n\t * @example\n\t * \n\t * @returns The x-coordinate of the first vertex\n\t */\n\tget startX(): number;\n\t/**\n\t * Get the first Y coordinate of the polygon.\n\t * @example\n\t * \n\t * @returns The y-coordinate of the first vertex\n\t */\n\tget startY(): number;\n}\n/**\n * A class to define a shape of a triangle via user defined coordinates.\n *\n * Used for creating triangular shapes and hit areas with three points (x,y), (x2,y2), (x3,y3).\n * Points are stored in counter-clockwise order.\n * @example\n * \n */\nexport declare class Triangle implements ShapePrimitive {\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t * \n\t * @default 'triangle'\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * The X coordinate of the first point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the first point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The X coordinate of the second point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx2: number;\n\t/**\n\t * The Y coordinate of the second point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty2: number;\n\t/**\n\t * The X coordinate of the third point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx3: number;\n\t/**\n\t * The Y coordinate of the third point of the triangle.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty3: number;\n\t/**\n\t * @param x - The X coord of the first point.\n\t * @param y - The Y coord of the first point.\n\t * @param x2 - The X coord of the second point.\n\t * @param y2 - The Y coord of the second point.\n\t * @param x3 - The X coord of the third point.\n\t * @param y3 - The Y coord of the third point.\n\t */\n\tconstructor(x?: number, y?: number, x2?: number, y2?: number, x3?: number, y3?: number);\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this triangle\n\t * @example\n\t * \n\t * @remarks\n\t * - Uses barycentric coordinate system\n\t * - Works with any triangle shape\n\t * @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Triangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this triangle including the stroke.\n\t * @example\n\t * \n\t * @param pointX - The X coordinate of the point to test\n\t * @param pointY - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param _alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this triangle's stroke\n\t */\n\tstrokeContains(pointX: number, pointY: number, strokeWidth: number, _alignment?: number): boolean;\n\t/**\n\t * Creates a clone of this Triangle\n\t * @example\n\t * \n\t * @returns A copy of the triangle\n\t */\n\tclone(): Triangle;\n\t/**\n\t * Copies another triangle to this one.\n\t * @example\n\t * \n\t * @param triangle - The triangle to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(triangle: Triangle): this;\n\t/**\n\t * Copies this triangle to another one.\n\t * @example\n\t * \n\t * @remarks\n\t * - Updates target triangle values\n\t * - Copies all point coordinates\n\t * - Returns target for chaining\n\t * - More efficient than clone()\n\t * @param triangle - The triangle to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(triangle: Triangle): Triangle;\n\t/**\n\t * Returns the framing rectangle of the triangle as a Rectangle object\n\t * @example\n\t * \n\t * @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n}\n/**\n * Constructor options used for `MeshPlane` instances. Defines how a texture is mapped\n * onto a plane with configurable vertex density.\n * @example\n * \n */\nexport interface MeshPlaneOptions extends Omit<MeshOptions, \"geometry\"> {\n\t/** The texture to use on the plane. */\n\ttexture: Texture;\n\t/**\n\t * Number of vertices along the X axis. More vertices allow for more detailed deformations.\n\t * @default 10\n\t */\n\tverticesX?: number;\n\t/**\n\t * Number of vertices along the Y axis. More vertices allow for more detailed deformations.\n\t * @default 10\n\t */\n\tverticesY?: number;\n}\n/**\n * A mesh that renders a texture mapped to a plane with configurable vertex density.\n * Useful for creating distortion effects, bent surfaces, and animated deformations.\n * @example\n * \n */\nexport declare class MeshPlane extends Mesh {\n\t/**\n\t * Controls whether the mesh geometry automatically updates when the texture dimensions change.\n\t * When true, the mesh will resize to match any texture updates. When false, the mesh maintains\n\t * its original dimensions regardless of texture changes.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tautoResize: boolean;\n\t/**\n\t * @param options - Options to be applied to MeshPlane\n\t */\n\tconstructor(options: MeshPlaneOptions);\n\tset texture(value: Texture);\n\t/**\n\t * The texture that the mesh plane uses for rendering. When changed, automatically updates\n\t * geometry dimensions if autoResize is true and manages texture update event listeners.\n\t * @example\n\t * \n\t */\n\tget texture(): Texture;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * meshPlane.destroy();\n\t * meshPlane.destroy(true);\n\t * meshPlane.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * Constructor options used for `PerspectiveMesh` instances. Defines the geometry and appearance\n * of a 2D mesh with perspective projection.\n * @example\n * \n */\nexport interface PerspectivePlaneOptions extends MeshPlaneOptions {\n\t/** The x-coordinate of the top-left corner */\n\tx0?: number;\n\t/** The y-coordinate of the top-left corner */\n\ty0?: number;\n\t/** The x-coordinate of the top-right corner */\n\tx1?: number;\n\t/** The y-coordinate of the top-right corner */\n\ty1?: number;\n\t/** The x-coordinate of the bottom-right corner */\n\tx2?: number;\n\t/** The y-coordinate of the bottom-right corner */\n\ty2?: number;\n\t/** The x-coordinate of the bottom-left corner */\n\tx3?: number;\n\t/** The y-coordinate of the bottom-left corner */\n\ty3?: number;\n}\n/**\n * A perspective mesh that allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * The calculations is done at the uv level. This means that the more vertices you have the more smooth\n * the perspective will be. If you have a low amount of vertices you may see the texture stretch. Too many vertices\n * could be slower. It is a balance between performance and quality! We leave that to you to decide.\n *\n * > [!IMPORTANT] This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it.\n * @example\n * \n */\nexport declare class PerspectiveMesh extends Mesh<PerspectivePlaneGeometry> {\n\t/**\n\t * Default options for creating a PerspectiveMesh instance.\n\t *\n\t * Creates a 100x100 pixel square mesh\n\t * with a white texture and 10x10 vertex grid for the perspective calculations.\n\t * @example\n\t * \n\t */\n\tstatic defaultOptions: PerspectivePlaneOptions;\n\t/**\n\t * @param options - Options to be applied to PerspectiveMesh\n\t */\n\tconstructor(options: PerspectivePlaneOptions);\n\tset texture(value: Texture);\n\t/**\n\t * The texture that the mesh uses for rendering. When changed, automatically updates\n\t * the geometry to match the new texture dimensions.\n\t * @example\n\t * \n\t */\n\tget texture(): Texture;\n\t/**\n\t * Sets the corners of the mesh to create a perspective transformation. The corners should be\n\t * specified in clockwise order starting from the top-left.\n\t *\n\t * The mesh automatically recalculates the UV coordinates to create the perspective effect.\n\t * @example\n\t * \n\t * @param x0 - x-coordinate of the top-left corner\n\t * @param y0 - y-coordinate of the top-left corner\n\t * @param x1 - x-coordinate of the top-right corner\n\t * @param y1 - y-coordinate of the top-right corner\n\t * @param x2 - x-coordinate of the bottom-right corner\n\t * @param y2 - y-coordinate of the bottom-right corner\n\t * @param x3 - x-coordinate of the bottom-left corner\n\t * @param y3 - y-coordinate of the bottom-left corner\n\t * @returns The PerspectiveMesh instance for method chaining\n\t */\n\tsetCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): void;\n}\ntype Matrix3x3 = ArrayFixed<number, 9>;\n/**\n * Constructor options used for `MeshRope` instances. Allows configuration of a rope-like mesh\n * that follows a series of points with a texture applied.\n * @example\n * \n */\nexport interface MeshRopeOptions extends Omit<MeshOptions, \"geometry\"> {\n\t/** The texture to use on the rope */\n\ttexture: Texture;\n\t/** An array of points that determine the rope's shape and path */\n\tpoints: PointData[];\n\t/**\n\t * Controls how the texture is scaled along the rope.\n\t * - If 0 (default), the texture stretches to fit between points\n\t * - If > 0, texture repeats with preserved aspect ratio\n\t * - Larger textures with textureScale < 1 can reduce artifacts\n\t * @default 0\n\t */\n\ttextureScale?: number;\n}\n/**\n * A specialized mesh that renders a texture along a path defined by points. Perfect for\n * creating snake-like animations, chains, ropes, and other flowing objects.\n * @example\n * \n */\nexport declare class MeshRope extends Mesh {\n\t/**\n\t * Default options for creating a MeshRope instance. These values are used when specific\n\t * options aren't provided in the constructor.\n\t * @example\n\t * \n\t * @property {number} textureScale - Controls texture scaling along the rope (0 = stretch)\n\t */\n\tstatic defaultOptions: Partial<MeshRopeOptions>;\n\t/**\n\t * Controls whether the rope's vertices are automatically recalculated each frame based on\n\t * its points. When true, the rope will update to follow point movements. When false,\n\t * manual updates are required.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tautoUpdate: boolean;\n\t/**\n\t * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n\t * @param options\n\t * @param options.texture - The texture to use on the rope.\n\t * @param options.points - An array of {@link math.Point} objects to construct this rope.\n\t * @param {number} options.textureScale - Optional. Positive values scale rope texture\n\t * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n\t * and downsampling here. If set to zero, texture will be stretched instead.\n\t */\n\tconstructor(options: MeshRopeOptions);\n}\n/**\n * Represents a particle with properties for position, scale, rotation, color, and texture.\n * Particles are lightweight alternatives to sprites, optimized for use in particle systems.\n * @example\n * \n */\nexport interface IParticle {\n\t/** The x-coordinate of the particle position */\n\tx: number;\n\t/** The y-coordinate of the particle position */\n\ty: number;\n\t/**\n\t * The horizontal scale factor of the particle\n\t * @default 1\n\t */\n\tscaleX: number;\n\t/**\n\t * The vertical scale factor of the particle\n\t * @default 1\n\t */\n\tscaleY: number;\n\t/**\n\t * The x-coordinate of the particle's anchor point (0-1 range)\n\t * @default 0\n\t */\n\tanchorX: number;\n\t/**\n\t * The y-coordinate of the particle's anchor point (0-1 range)\n\t * @default 0\n\t */\n\tanchorY: number;\n\t/**\n\t * The rotation of the particle in radians\n\t * @default 0\n\t */\n\trotation: number;\n\t/**\n\t * The color of the particle as a 32-bit RGBA value\n\t * @default 0xffffffff\n\t */\n\tcolor: number;\n\t/** The texture used to render this particle */\n\ttexture: Texture;\n}\n/**\n * Configuration options for creating a new particle. All properties except texture are optional\n * and will use default values if not specified.\n * @example\n * \n */\nexport type ParticleOptions = Omit<Partial<IParticle>, \"color\"> & {\n\t/** The texture used to render this particle */\n\ttexture: Texture;\n\t/** The tint color as a hex number or CSS color string */\n\ttint?: ColorSource;\n\t/** The alpha transparency (0-1) */\n\talpha?: number;\n};\n/**\n * Represents a single particle within a particle container. This class implements the IParticle interface,\n * providing properties and methods to manage the particle's position, scale, rotation, color, and texture.\n *\n * The reason we use a particle over a sprite is that these are much lighter weight and we can create a lot of them\n * without taking on the overhead of a full sprite.\n * @example\n * \n */\nexport declare class Particle implements IParticle {\n\t/**\n\t * Default options used when creating new particles. These values are applied when specific\n\t * options aren't provided in the constructor.\n\t * @example\n\t * \n\t */\n\tstatic defaultOptions: Partial<ParticleOptions>;\n\t/**\n\t * The x-coordinate of the anchor point (0-1).\n\t * Controls the origin point for rotation and scaling.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tanchorX: number;\n\t/**\n\t * The y-coordinate of the anchor point (0-1).\n\t * Controls the origin point for rotation and scaling.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tanchorY: number;\n\t/**\n\t * The x-coordinate of the particle in world space.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tx: number;\n\t/**\n\t * The y-coordinate of the particle in world space.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ty: number;\n\t/**\n\t * The horizontal scale factor of the particle.\n\t * Values greater than 1 increase size, less than 1 decrease size.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tscaleX: number;\n\t/**\n\t * The vertical scale factor of the particle.\n\t * Values greater than 1 increase size, less than 1 decrease size.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tscaleY: number;\n\t/**\n\t * The rotation of the particle in radians.\n\t * Positive values rotate clockwise.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\trotation: number;\n\t/**\n\t * The color of the particle as a 32-bit RGBA value.\n\t * Combines tint and alpha into a single value.\n\t * @example\n\t * \n\t * @default 0xffffffff\n\t */\n\tcolor: number;\n\t/**\n\t * The texture used to render this particle.\n\t * All particles in a container should share the same base texture.\n\t * @example\n\t * \n\t */\n\ttexture: Texture;\n\tconstructor(options: Texture | ParticleOptions);\n\t/**\n\t * The transparency of the particle. Values range from 0 (fully transparent)\n\t * to 1 (fully opaque). Values outside this range are clamped.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n\t/**\n\t * The tint color of the particle. Can be set using hex numbers or CSS color strings.\n\t * The tint is multiplied with the texture color to create the final particle color.\n\t * @example\n\t * \n\t * @type {ColorSource} Hex number or CSS color string\n\t * @default 0xffffff\n\t */\n\tget tint(): number;\n\tset tint(value: ColorSource);\n}\n/**\n * Represents the properties of a particle that can be dynamically updated each frame.\n * These properties control which aspects of particles are recalculated during rendering.\n * Setting a property to true enables per-frame updates, while false only updates when manually triggered.\n * @example\n * \n */\nexport interface ParticleProperties {\n\t/**\n\t * When true, vertex positions are updated each frame.\n\t * Useful for mesh deformation effects.\n\t * @default false\n\t */\n\tvertex?: boolean;\n\t/**\n\t * When true, particle positions are updated each frame.\n\t * Essential for moving particles.\n\t * @default true\n\t */\n\tposition?: boolean;\n\t/**\n\t * When true, rotation values are updated each frame.\n\t * Needed for spinning particles.\n\t * @default false\n\t */\n\trotation?: boolean;\n\t/**\n\t * When true, texture coordinates are updated each frame.\n\t * Required for texture animation.\n\t * @default false\n\t */\n\tuvs?: boolean;\n\t/**\n\t * When true, color values are updated each frame.\n\t * Enables color transitions and alpha changes.\n\t * @default false\n\t */\n\tcolor?: boolean;\n}\n/**\n * Options for configuring a ParticleContainer. Controls how particles are rendered, updated, and managed.\n * @example\n * \n */\nexport interface ParticleContainerOptions extends PixiMixins.ParticleContainerOptions, Omit<ViewContainerOptions, \"children\"> {\n\t/**\n\t * Specifies which particle properties should update each frame.\n\t * Set properties to true for per-frame updates, false for static values.\n\t * @default { position: true, rotation: false, vertex: false, uvs: false, color: false }\n\t */\n\tdynamicProperties?: ParticleProperties & Record<string, boolean>;\n\t/**\n\t * When true, particle positions are rounded to the nearest pixel.\n\t * Helps achieve crisp rendering at the cost of smooth motion.\n\t * @default false\n\t */\n\troundPixels?: boolean;\n\t/**\n\t * The texture used for all particles in this container.\n\t * If not provided, uses the texture of the first particle added.\n\t */\n\ttexture?: Texture;\n\t/** Initial array of particles to add to the container. All particles must share the same base texture. */\n\tparticles?: IParticle[];\n}\nexport interface ParticleContainer extends PixiMixins.ParticleContainer, ViewContainer<ParticleBuffer> {\n}\n/**\n * The ParticleContainer class is a highly optimized container that can render 1000s or particles at great speed.\n *\n * A ParticleContainer is specialized in that it can only contain and render particles. Particles are\n * lightweight objects that use minimal memory, which helps boost performance.\n *\n * It can render particles EXTREMELY fast!\n *\n * The tradeoff of using a ParticleContainer is that most advanced functionality is unavailable. Particles are simple\n * and cannot have children, filters, masks, etc. They possess only the basic properties: position, scale, rotation,\n * and color.\n *\n * All particles must share the same texture source (using something like a sprite sheet works well here).\n *\n * When creating a ParticleContainer, a developer can specify which of these properties are static and which are dynamic.\n * - Static properties are only updated when you add or remove a child, or when the `update` function is called.\n * - Dynamic properties are updated every frame.\n *\n * It is up to the developer to specify which properties are static and which are dynamic. Generally, the more static\n * properties you have (i.e., those that do not change per frame), the faster the rendering.\n *\n * If the developer modifies the children order or any static properties of the particle, they must call the `update` method.\n *\n * By default, only the `position` property is set to dynamic, which makes rendering very fast!\n *\n * Developers can also provide a custom shader to the particle container, allowing them to render particles in a custom way.\n *\n * To help with performance, the particle containers bounds are not calculated.\n * It's up to the developer to set the boundsArea property.\n *\n * It's extremely easy to use. Below is an example of rendering thousands of sprites at lightning speed.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * \n */\nexport declare class ParticleContainer extends ViewContainer<ParticleBuffer> implements Instruction {\n\t/**\n\t * Defines the default options for creating a ParticleContainer.\n\t * @example\n\t * \n\t * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n\t * @property {boolean} roundPixels - Indicates if pixels should be  rounded.\n\t */\n\tstatic defaultOptions: ParticleContainerOptions;\n\t/**\n\t * An array of particles that are children of this ParticleContainer.\n\t * This array can be modified directly for performance, but the 'update' method\n\t * must be called afterwards to ensure the container is rendered correctly.\n\t * @example\n\t * \n\t */\n\tparticleChildren: IParticle[];\n\t/**\n\t * The texture used for rendering particles in this ParticleContainer. All particles\n\t * must share the same base texture for optimal performance.\n\t *\n\t * > [!NOTE]\n\t * > If not set, the texture of the first particle added to this container will be used.\n\t * @example\n\t * \n\t * @default null\n\t */\n\ttexture: Texture;\n\t/**\n\t * @param options - The options for creating the sprite.\n\t */\n\tconstructor(options?: ParticleContainerOptions);\n\t/**\n\t * Adds one or more particles to the container. The particles will be rendered using the container's shared texture\n\t * and properties. When adding multiple particles, they must all share the same base texture.\n\t * @example\n\t * \n\t * @param children - The Particle(s) to add to the container\n\t * @returns The first particle that was added, for method chaining\n\t */\n\taddParticle(...children: IParticle[]): IParticle;\n\t/**\n\t * Removes one or more particles from the container. The particles must already be children\n\t * of this container to be removed.\n\t * @example\n\t * \n\t * @param children - The Particle(s) to remove from the container\n\t * @returns The first particle that was removed, for method chaining\n\t */\n\tremoveParticle(...children: IParticle[]): IParticle;\n\t/**\n\t * Updates the particle container's internal state. Call this method after manually modifying\n\t * the particleChildren array or when changing static properties of particles.\n\t * @example\n\t * \n\t */\n\tupdate(): void;\n\t/**\n\t * Returns a static empty bounds object since ParticleContainer does not calculate bounds automatically\n\t * for performance reasons. Use the `boundsArea` property to manually set container bounds.\n\t * @example\n\t * \n\t * @returns {Bounds} An empty bounds object (0,0,0,0)\n\t */\n\tget bounds(): Bounds;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * particleContainer.destroy();\n\t * particleContainer.destroy(true);\n\t * particleContainer.destroy({ texture: true, textureSource: true, children: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * Removes all particles from this container that are within the begin and end indexes.\n\t * @param beginIndex - The beginning position.\n\t * @param endIndex - The ending position. Default value is size of the container.\n\t * @returns - List of removed particles\n\t */\n\tremoveParticles(beginIndex?: number, endIndex?: number): IParticle[];\n\t/**\n\t * Removes a particle from the specified index position.\n\t * @param index - The index to get the particle from\n\t * @returns The particle that was removed.\n\t */\n\tremoveParticleAt<U extends IParticle>(index: number): U;\n\t/**\n\t * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n\t * If the particle is already in this container, it will be moved to the specified index.\n\t * @param {Container} child - The particle to add.\n\t * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n\t * @returns {Container} The particle that was added.\n\t */\n\taddParticleAt<U extends IParticle>(child: U, index: number): U;\n}\n/**\n * A collection of textures or frame objects that can be used to create an `AnimatedSprite`.\n */\nexport type AnimatedSpriteFrames = Texture[] | FrameObject[];\n/**\n * Constructor options used for `AnimatedSprite` instances. Allows configuration of animation\n * playback, speed, and texture frames.\n * @example\n * \n */\nexport interface AnimatedSpriteOptions extends PixiMixins.AnimatedSpriteOptions, Omit<SpriteOptions, \"texture\"> {\n\t/**\n\t * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tanimationSpeed?: number;\n\t/**\n\t * Whether to start the animation immediately on creation.\n\t * If set to `true`, the animation will start playing as soon as the\n\t * `AnimatedSprite` is created.\n\t * If set to `false`, you will need to call the `play` method to start the animation.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tautoPlay?: boolean;\n\t/**\n\t * Whether to use Ticker.shared to auto update animation time.\n\t * This is useful for animations that need to be updated every frame.\n\t * If set to `false`, you will need to manually call the `update` method\n\t * to update the animation.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tautoUpdate?: boolean;\n\t/**\n\t * Whether or not the animation repeats after playing.\n\t * @default true\n\t */\n\tloop?: boolean;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite finishes playing.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonComplete?: () => void;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonFrameChange?: (currentFrame: number) => void;\n\t/**\n\t * User-assigned function to call when `loop` is true,\n\t * and an AnimatedSprite is played and loops around to start again.\n\t * @example\n\t * \n\t * @default null\n\t */\n\tonLoop?: () => void;\n\t/**\n\t * An array of {@link Texture} or frame objects that make up the animation.\n\t * @example\n\t * \n\t */\n\ttextures: AnimatedSpriteFrames;\n\t/**\n\t * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n\t *\n\t * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n\t * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n\t * of the frame (e.g. left foot).\n\t * > [!NOTE] Enabling this will override any previously set `anchor` on each frame change.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tupdateAnchor?: boolean;\n}\nexport interface AnimatedSprite extends PixiMixins.AnimatedSprite, Sprite {\n}\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n * @example\n * \n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * \n */\nexport declare class AnimatedSprite extends Sprite {\n\t/**\n\t * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n\t * @example\n\t * \n\t * @default 1\n\t */\n\tanimationSpeed: number;\n\t/**\n\t * Whether or not the animation repeats after playing.\n\t * When true, the animation will restart from the beginning after reaching the last frame.\n\t * When false, the animation will stop on the last frame.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tloop: boolean;\n\t/**\n\t * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n\t *\n\t * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n\t * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n\t * of the frame (e.g. left foot).\n\t *\n\t * > [!NOTE] Enabling this will override any previously set `anchor` on each frame change.\n\t * @default false\n\t */\n\tupdateAnchor: boolean;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite finishes playing.\n\t *\n\t * This function is called when the animation reaches the end and stops playing.\n\t * If the animation is set to loop, this function will not be called.\n\t * @example\n\t * \n\t */\n\tonComplete?: () => void;\n\t/**\n\t * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n\t *\n\t * This function is called every time the current frame changes during playback.\n\t * It receives the current frame index as an argument.\n\t * @example\n\t * animation.onFrameChange = () => {\n\t *     // Updated!\n\t * };\n\t */\n\tonFrameChange?: (currentFrame: number) => void;\n\t/**\n\t * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n\t * loops around to start again.\n\t * @example\n\t * animation.onLoop = () => {\n\t *     // Looped!\n\t * };\n\t */\n\tonLoop?: () => void;\n\t/**\n\t * @param frames - Collection of textures or frames to use.\n\t * @param autoUpdate - Whether to use Ticker.shared to auto update animation time.\n\t */\n\tconstructor(frames: AnimatedSpriteFrames, autoUpdate?: boolean);\n\t/**\n\t * @param options - The options for the AnimatedSprite.\n\t */\n\tconstructor(options: AnimatedSpriteOptions);\n\t/**\n\t * Stops the animation playback and freezes the current frame.\n\t * Does not reset the current frame or animation progress.\n\t * @example\n\t * \n\t */\n\tstop(): void;\n\t/**\n\t * Starts or resumes the animation playback.\n\t * If the animation was previously stopped, it will continue from where it left off.\n\t * @example\n\t * \n\t */\n\tplay(): void;\n\t/**\n\t * Stops the AnimatedSprite and sets it to a specific frame.\n\t * @example\n\t * \n\t * @param frameNumber - Frame index to stop at (0-based)\n\t * @throws {Error} If frameNumber is out of bounds\n\t */\n\tgotoAndStop(frameNumber: number): void;\n\t/**\n\t * Goes to a specific frame and begins playing the AnimatedSprite from that point.\n\t * Combines frame navigation and playback start in one operation.\n\t * @example\n\t * \n\t * @param frameNumber - Frame index to start playing from (0-based)\n\t * @throws {Error} If frameNumber is out of bounds\n\t */\n\tgotoAndPlay(frameNumber: number): void;\n\t/**\n\t * Updates the object transform for rendering. This method handles animation timing, frame updates,\n\t * and manages looping behavior.\n\t * @example\n\t * \n\t * @param ticker - The ticker to use for updating the animation timing\n\t */\n\tupdate(ticker: Ticker): void;\n\t/**\n\t * Stops the AnimatedSprite and destroys it.\n\t * This method stops the animation playback, removes it from the ticker,\n\t * and cleans up any resources associated with the sprite.\n\t * @param options - Options for destroying the sprite, such as whether to remove from parent\n\t * @example\n\t * \n\t */\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * A short hand way of creating an AnimatedSprite from an array of frame ids.\n\t * Uses texture frames from the cache to create an animation sequence.\n\t * @example\n\t * \n\t * @param frames - The array of frame ids to use for the animation\n\t * @returns A new animated sprite using the frames\n\t */\n\tstatic fromFrames(frames: string[]): AnimatedSprite;\n\t/**\n\t * A short hand way of creating an AnimatedSprite from an array of image urls.\n\t * Each image will be used as a frame in the animation.\n\t * @example\n\t * \n\t * @param images - The array of image urls to use as frames\n\t * @returns A new animated sprite using the images as frames\n\t */\n\tstatic fromImages(images: string[]): AnimatedSprite;\n\t/**\n\t * The total number of frames in the AnimatedSprite. This is the same as number of textures\n\t * assigned to the AnimatedSprite.\n\t * @example\n\t * \n\t * @returns {number} The total number of frames\n\t */\n\tget totalFrames(): number;\n\t/**\n\t * The array of textures or frame objects used for the animation sequence.\n\t * Can be set to either an array of Textures or an array of FrameObjects with custom timing.\n\t * @example\n\t * \n\t * @type {AnimatedSpriteFrames}\n\t */\n\tget textures(): AnimatedSpriteFrames;\n\tset textures(value: AnimatedSpriteFrames);\n\t/**\n\t * Gets or sets the current frame index of the animation.\n\t * When setting, the value will be clamped between 0 and totalFrames - 1.\n\t * @example\n\t * \n\t * @throws {Error} If attempting to set a frame index out of bounds\n\t */\n\tget currentFrame(): number;\n\tset currentFrame(value: number);\n\t/**\n\t * Indicates if the AnimatedSprite is currently playing.\n\t * This is a read-only property that reflects the current playback state.\n\t * @example\n\t * \n\t * @returns {boolean} True if the animation is currently playing\n\t */\n\tget playing(): boolean;\n\t/**\n\t * Controls whether the animation automatically updates using the shared ticker.\n\t * When enabled, the animation will update on each frame. When disabled, you must\n\t * manually call update() to advance the animation.\n\t * @example\n\t * \n\t * @default true\n\t */\n\tget autoUpdate(): boolean;\n\tset autoUpdate(value: boolean);\n}\n/**\n * Constructor options used for `NineSliceSprite` instances.\n * Defines how the sprite's texture is divided and scaled in nine sections.\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * \n */\nexport interface NineSliceSpriteOptions extends PixiMixins.NineSliceSpriteOptions, ViewContainerOptions {\n\t/**\n\t * The texture to use on the NineSliceSprite.\n\t * \n\t * @default Texture.EMPTY\n\t */\n\ttexture: Texture;\n\t/**\n\t * Width of the left vertical bar (A).\n\t * Controls the size of the left edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tleftWidth?: number;\n\t/**\n\t * Height of the top horizontal bar (C).\n\t * Controls the size of the top edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\ttopHeight?: number;\n\t/**\n\t * Width of the right vertical bar (B).\n\t * Controls the size of the right edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\trightWidth?: number;\n\t/**\n\t * Height of the bottom horizontal bar (D).\n\t * Controls the size of the bottom edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tbottomHeight?: number;\n\t/**\n\t * Width of the NineSliceSprite.\n\t * Modifies the vertices directly rather than UV coordinates\n\t * @example\n\t * \n\t * @default 100\n\t */\n\twidth?: number;\n\t/**\n\t * Height of the NineSliceSprite.\n\t * Modifies the vertices directly rather than UV coordinates\n\t * @example\n\t * \n\t * @default 100\n\t */\n\theight?: number;\n\t/**\n\t * Whether to round the x/y position to whole pixels\n\t * @example\n\t * \n\t * @default false\n\t */\n\troundPixels?: boolean;\n\t/**\n\t * The anchor point of the NineSliceSprite (0-1 range)\n\t *\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @default 0\n\t * @example\n\t * \n\t */\n\tanchor?: PointData | number;\n}\nexport interface NineSliceSprite extends PixiMixins.NineSliceSprite, ViewContainer<NineSliceSpriteGpuData> {\n}\n/**\n * The NineSliceSprite allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @example\n * \n */\nexport declare class NineSliceSprite extends ViewContainer<NineSliceSpriteGpuData> implements View {\n\t/**\n\t * The default options used to override initial values of any options passed in the constructor.\n\t * These values are used as fallbacks when specific options are not provided.\n\t * @example\n\t * \n\t * @type {NineSliceSpriteOptions}\n\t */\n\tstatic defaultOptions: NineSliceSpriteOptions;\n\tconstructor(options: NineSliceSpriteOptions | Texture);\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * \n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n\t * The width affects how the middle sections are scaled.\n\t * @example\n\t * \n\t */\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane.\n\t * The height affects how the middle sections are scaled.\n\t * @example\n\t * \n\t */\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * Sets the size of the NineSliceSprite to the specified width and height.\n\t * This method directly modifies the vertices and UV coordinates of the sprite.\n\t *\n\t * Using this is more efficient than setting width and height separately as it only triggers one update.\n\t * @example\n\t * \n\t * @param value - This can be either a number or a Size object with width/height properties\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.\n\t * This method is more efficient than getting width and height separately.\n\t * @example\n\t * \n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the NineSliceSprite\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Width of the left vertical bar (A).\n\t * Controls the size of the left edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tget leftWidth(): number;\n\tset leftWidth(value: number);\n\t/**\n\t * Height of the top horizontal bar (C).\n\t * Controls the size of the top edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tget topHeight(): number;\n\tset topHeight(value: number);\n\t/**\n\t * Width of the right vertical bar (B).\n\t * Controls the size of the right edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tget rightWidth(): number;\n\tset rightWidth(value: number);\n\t/**\n\t * Height of the bottom horizontal bar (D).\n\t * Controls the size of the bottom edge that remains unscaled\n\t * @example\n\t * \n\t * @default 10\n\t */\n\tget bottomHeight(): number;\n\tset bottomHeight(value: number);\n\t/**\n\t * The texture to use on the NineSliceSprite.\n\t * \n\t * @default Texture.EMPTY\n\t */\n\tget texture(): Texture;\n\tset texture(value: Texture);\n\t/**\n\t * The original width of the texture before any nine-slice scaling.\n\t * This is the width of the source texture used to create the nine-slice sprite.\n\t * @example\n\t * \n\t * @returns The original width of the texture\n\t */\n\tget originalWidth(): number;\n\t/**\n\t * The original height of the texture before any nine-slice scaling.\n\t * This is the height of the source texture used to create the nine-slice sprite.\n\t * @example\n\t * \n\t * @returns The original height of the texture\n\t */\n\tget originalHeight(): number;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * nineSliceSprite.destroy();\n\t * nineSliceSprite.destroy(true);\n\t * nineSliceSprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * Please use the {@link NineSliceSprite} class instead.\n * The NineSlicePlane is deprecated and will be removed in future versions.\n * @deprecated since 8.0.0\n */\nexport declare class NineSlicePlane extends NineSliceSprite {\n\tconstructor(options: NineSliceSpriteOptions | Texture);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(texture: Texture, leftWidth: number, topHeight: number, rightWidth: number, bottomHeight: number);\n}\n/**\n * The Transform class facilitates the manipulation of a 2D transformation matrix through\n * user-friendly properties: position, scale, rotation, skew, and pivot.\n * @example\n * \n * @remarks\n * - Manages 2D transformation properties\n * - Auto-updates matrix on changes\n * - Supports observable changes\n * - Common in display objects\n */\nexport declare class Transform {\n\t/**\n\t * The coordinate of the object relative to the local coordinates of the parent.\n\t * @example\n\t * \n\t */\n\tposition: ObservablePoint;\n\t/**\n\t * The scale factor of the object.\n\t * @example\n\t * \n\t */\n\tscale: ObservablePoint;\n\t/**\n\t * The pivot point of the container that it rotates around.\n\t * @example\n\t * \n\t */\n\tpivot: ObservablePoint;\n\t/**\n\t * The skew amount, on the x and y axis.\n\t * @example\n\t * \n\t */\n\tskew: ObservablePoint;\n\t/**\n\t * @param options - Options for the transform.\n\t * @param options.matrix - The matrix to use.\n\t * @param options.observer - The observer to use.\n\t */\n\tconstructor({ matrix, observer }?: TransformOptions);\n\t/**\n\t * The transformation matrix computed from the transform's properties.\n\t * Combines position, scale, rotation, skew, and pivot into a single matrix.\n\t * @example\n\t * \n\t */\n\tget matrix(): Matrix;\n\ttoString(): string;\n\t/**\n\t * Decomposes a matrix and sets the transforms properties based on it.\n\t * @example\n\t * \n\t * @param matrix - The matrix to decompose\n\t */\n\tsetFromMatrix(matrix: Matrix): void;\n\t/**\n\t * The rotation of the object in radians.\n\t * @example\n\t * \n\t */\n\tget rotation(): number;\n\tset rotation(value: number);\n}\n/**\n * Constructor options used for creating a TilingSprite instance.\n * Defines the texture, tiling behavior, and rendering properties of the sprite.\n * @example\n * \n */\nexport interface TilingSpriteOptions extends PixiMixins.TilingSpriteOptions, ViewContainerOptions {\n\t/**\n\t * The anchor point of the TilingSprite (0-1 range)\n\t *\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tanchor?: PointData | number;\n\t/**\n\t * The offset of the tiling texture.\n\t * Used to scroll or position the repeated pattern.\n\t * @example\n\t * \n\t * @default {x: 0, y: 0}\n\t */\n\ttilePosition?: PointData;\n\t/**\n\t * Scale of the tiling texture.\n\t * Affects the size of each repeated instance of the texture.\n\t * @example\n\t * \n\t * @default {x: 1, y: 1}\n\t */\n\ttileScale?: PointData;\n\t/**\n\t * Rotation of the tiling texture in radians.\n\t * This controls the rotation applied to the texture before tiling.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\ttileRotation?: number;\n\t/**\n\t * The texture to use for tiling.\n\t * This is the image that will be repeated across the sprite.\n\t * @example\n\t * \n\t * @default Texture.WHITE\n\t */\n\ttexture?: Texture;\n\t/**\n\t * The width of the tiling area.\n\t * This defines how wide the tiling sprite will be.\n\t * @example\n\t * \n\t * @default 256\n\t */\n\twidth?: number;\n\t/**\n\t * The height of the tiling area.\n\t * This defines how tall the tiling sprite will be.\n\t * @example\n\t * \n\t * @default 256\n\t */\n\theight?: number;\n\t/**\n\t * Whether the tiling pattern should originate from the anchor point.\n\t * When true, tiling starts from the origin instead of top-left.\n\t *\n\t * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n\t * this, the top-left corner always gets the (0, 0) texture coordinate.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tapplyAnchorToTexture?: boolean;\n\t/**\n\t * Whether to round the sprite's position to whole pixels.\n\t * This can help with crisp rendering, especially for pixel art.\n\t * When true, the sprite's position will be rounded to the nearest pixel.\n\t * @example\n\t * \n\t * @default false\n\t */\n\troundPixels?: boolean;\n}\nexport interface TilingSprite extends PixiMixins.TilingSprite, ViewContainer<TilingSpriteGpuData> {\n}\n/**\n * A TilingSprite is a fast and efficient way to render a repeating texture across a given area.\n * The texture can be scrolled, scaled, and rotated independently of the sprite itself.\n * @example\n * \n */\nexport declare class TilingSprite extends ViewContainer<TilingSpriteGpuData> implements View, Instruction {\n\t/**\n\t * Creates a new tiling sprite based on a source texture or image path.\n\t * This is a convenience method that automatically creates and manages textures.\n\t * @example\n\t * \n\t * @param source - The source to create the sprite from. Can be a path to an image or a texture\n\t * @param options - Additional options for the tiling sprite\n\t * @returns A new tiling sprite based on the source\n\t */\n\tstatic from(source: Texture | string, options?: TilingSpriteOptions): TilingSprite;\n\t/**\n\t * Default options used when creating a TilingSprite instance.\n\t * These values are used as fallbacks when specific options are not provided.\n\t * @example\n\t * \n\t * @type {TilingSpriteOptions}\n\t */\n\tstatic defaultOptions: TilingSpriteOptions;\n\t/**\n\t * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n\t * local space.\n\t *\n\t * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n\t * this, the top-left corner always gets the (0, 0) texture coordinate.\n\t * @example\n\t * \n\t * @default false\n\t */\n\tapplyAnchorToTexture: boolean;\n\t/**\n\t * @param {Texture | TilingSpriteOptions} options - The options for creating the tiling sprite.\n\t */\n\tconstructor(options?: Texture | TilingSpriteOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(texture: Texture, width: number, height: number);\n\t/**\n\t * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n\t * and passed to the constructor.\n\t *\n\t * - The default is `(0,0)`, this means the sprite's origin is the top left.\n\t * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n\t * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n\t *\n\t * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n\t * @example\n\t * \n\t */\n\tget anchor(): ObservablePoint;\n\tset anchor(value: PointData | number);\n\t/**\n\t * The offset of the tiling texture.\n\t * Used to scroll or position the repeated pattern.\n\t * @example\n\t * \n\t * @default {x: 0, y: 0}\n\t */\n\tget tilePosition(): ObservablePoint;\n\tset tilePosition(value: PointData);\n\t/**\n\t * Scale of the tiling texture.\n\t * Affects the size of each repeated instance of the texture.\n\t * @example\n\t * \n\t * @default {x: 1, y: 1}\n\t */\n\tget tileScale(): ObservablePoint;\n\tset tileScale(value: PointData | number);\n\tset tileRotation(value: number);\n\t/**\n\t * Rotation of the tiling texture in radians.\n\t * This controls the rotation applied to the texture before tiling.\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tget tileRotation(): number;\n\tset texture(value: Texture);\n\t/**\n\t * The texture to use for tiling.\n\t * This is the image that will be repeated across the sprite.\n\t * @example\n\t * \n\t * @default Texture.WHITE\n\t */\n\tget texture(): Texture;\n\t/**\n\t * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.\n\t * @example\n\t * \n\t */\n\tset width(value: number);\n\tget width(): number;\n\tset height(value: number);\n\t/**\n\t * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.\n\t * @example\n\t * \n\t */\n\tget height(): number;\n\t/**\n\t * Sets the size of the TilingSprite to the specified width and height.\n\t * This is faster than setting width and height separately as it only triggers one update.\n\t * @example\n\t * \n\t * @param value - This can be either a number for uniform sizing or a Size object with width/height properties\n\t * @param height - The height to set. Defaults to the value of `width` if not provided\n\t */\n\tsetSize(value: number | Optional<Size, \"height\">, height?: number): void;\n\t/**\n\t * Retrieves the size of the TilingSprite as a {@link Size} object.\n\t * This method is more efficient than getting width and height separately as it only allocates one object.\n\t * @example\n\t * \n\t * @param out - Optional object to store the size in, to avoid allocating a new object\n\t * @returns The size of the TilingSprite\n\t */\n\tgetSize(out?: Size): Size;\n\t/**\n\t * Checks if the object contains the given point in local coordinates.\n\t * Takes into account the anchor offset when determining boundaries.\n\t * @example\n\t * \n\t * @param point - The point to check in local coordinates\n\t * @returns True if the point is within the sprite's bounds\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys this sprite renderable and optionally its texture.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * tilingSprite.destroy();\n\t * tilingSprite.destroy(true);\n\t * tilingSprite.destroy({ texture: true, textureSource: true });\n\t */\n\tdestroy(options?: DestroyOptions): void;\n}\ninterface BitmapFontEvents<Type> {\n\tdestroy: [\n\t\tType\n\t];\n}\n/**\n * A fully resolved asset, with all the information needed to load it.\n * This represents an asset that has been processed by the resolver and is ready to be loaded.\n * @example\n * \n */\nexport interface ResolvedAsset<T = any> {\n\t/** Array of alternative names for this asset. Used for looking up the same asset by different keys. */\n\talias?: string[];\n\t/** The URL or relative path to the asset. This is the final, resolved path that will be used for loading. */\n\tsrc?: string;\n\t/**\n\t * Optional data passed to the asset loader.\n\t * Can include texture settings, parser options, or other asset-specific data.\n\t */\n\tdata?: T;\n\t/** File format of the asset, usually the file extension. Used to determine which loader parser to use. */\n\tformat?: string;\n\t/**\n\t * @deprecated Use `parser` instead.\n\t */\n\tloadParser?: LoadParserName;\n\t/** Override to specify which parser should load this asset. Useful when file extensions don't match the content type. */\n\tparser?: AssetParser;\n\t/**\n\t * The amount of progress an asset will contribute to the onProgress event when loading.\n\t * This can be any arbitrary value but typically represents the file size.\n\t * @default 1\n\t */\n\tprogressSize?: number;\n}\n/**\n * A valid asset source specification. This can be a URL string, a {@link ResolvedSrc},\n * or an array of either. The source defines where and how to load an asset.\n * @example\n * \n * @remarks\n * When specifying multiple formats:\n * - The format that is selected will depend on {@link AssetInitOptions.texturePreference}\n * - Resolution is parsed from file names\n * - Custom data can be passed to loaders\n */\nexport type AssetSrc = ArrayOr<string> | (ArrayOr<ResolvedSrc> & {\n\t[key: string]: any;\n});\n/**\n * An asset that has not been resolved yet. This is the initial format used when adding assets\n * to the Assets system before they are processed into a {@link ResolvedAsset}.\n * @example\n * \n * @remarks\n * - Used as input format when adding assets to the system\n * - Can specify multiple aliases for the same asset\n * - Supports format patterns for browser compatibility\n * - Can include loader-specific data and options\n */\nexport type UnresolvedAsset<T = any> = Pick<ResolvedAsset<T>, \"data\" | \"format\" | \"loadParser\" | \"parser\"> & {\n\t/** Aliases associated with asset */\n\talias?: ArrayOr<string>;\n\t/** The URL or relative path to the asset */\n\tsrc?: AssetSrc;\n\t[key: string]: any;\n};\n/**\n * Structure of a bundle found in a {@link AssetsManifest} file. Bundles allow you to\n * group related assets together for easier management and loading.\n * @example\n * \n */\nexport interface AssetsBundle {\n\t/** Unique identifier for the bundle */\n\tname: string;\n\t/** Assets contained in the bundle. Can be an array of assets or a record mapping aliases to sources. */\n\tassets: UnresolvedAsset[] | Record<string, ArrayOr<string> | UnresolvedAsset>;\n}\n/**\n * The manifest format for defining all assets in your application. Manifests provide a\n * structured way to organize and manage your assets through bundles.\n * @example\n * \n */\nexport interface AssetsManifest {\n\t/** Array of asset bundles that make up the manifest */\n\tbundles: AssetsBundle[];\n}\ndeclare class CacheClass {\n\t/** Clear all entries. */\n\treset(): void;\n\t/**\n\t * Check if the key exists\n\t * @param key - The key to check\n\t */\n\thas(key: any): boolean;\n\t/**\n\t * Fetch entry by key\n\t * @param key - The key of the entry to get\n\t */\n\tget<T = any>(key: any): T;\n\t/**\n\t * Set a value by key or keys name\n\t * @param key - The key or keys to set\n\t * @param value - The value to store in the cache or from which cacheable assets will be derived.\n\t */\n\tset<T = any>(key: any | any[], value: T): void;\n\t/**\n\t * Remove entry by key\n\t *\n\t * This function will also remove any associated alias from the cache also.\n\t * @param key - The key of the entry to remove\n\t */\n\tremove(key: any): void;\n}\n/**\n * A prefer order lets the resolver know which assets to prefer depending on the various parameters passed to it.\n */\nexport interface PreferOrder {\n\t/** the importance order of the params */\n\tpriority?: string[];\n\tparams: {\n\t\t[key: string]: any;\n\t};\n}\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * \n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n */\nexport type ProgressCallback = (progress: number) => void;\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n */\nexport interface AssetInitOptions {\n\t/**\n\t * Base path prepended to all asset URLs. Useful for CDN hosting.\n\t * @example\n\t * \n\t */\n\tbasePath?: string;\n\t/**\n\t * A manifest defining all your application's assets.\n\t * Can be a URL to a JSON file or a manifest object.\n\t * @example\n\t * \n\t */\n\tmanifest?: string | AssetsManifest;\n\t/**\n\t * Configure texture loading preferences.\n\t * Useful for optimizing asset delivery based on device capabilities.\n\t * @example\n\t * \n\t */\n\ttexturePreference?: {\n\t\t/** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n\t\tresolution?: number | number[];\n\t\t/** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n\t\tformat?: ArrayOr<string>;\n\t};\n\t/**\n\t * Optional preferences for asset loading behavior.\n\t * @example\n\t * \n\t */\n\tpreferences?: Partial<AssetsPreferences>;\n\t/**\n\t * Options for defining the loading behavior of assets.\n\t * @example\n\t * \n\t * @remarks\n\t * - `onProgress` callback receives values from 0.0 to 1.0\n\t * - `onError` callback is invoked for individual asset load failures\n\t * - `strategy` can be 'throw' (default), 'retry', or 'skip'\n\t * - `retryCount` sets how many times to retry failed assets (default 3)\n\t * - `retryDelay` sets the delay between retries in milliseconds (default 250ms)\n\t */\n\tloadOptions?: Partial<LoadOptions>;\n}\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * \n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n */\nexport declare const Assets: AssetsClass;\n/**\n * Options for loading assets with the Loader\n * @example\n * \n */\nexport interface LoadOptions {\n\t/**\n\t * Callback for progress updates during loading\n\t * @param progress - A number between 0 and 1 indicating the load progress\n\t * @example\n\t * \n\t */\n\tonProgress?: (progress: number) => void;\n\t/**\n\t * Callback for handling errors during loading\n\t * @param error - The error that occurred\n\t * @param url - The URL of the asset that failed to load\n\t * @example\n\t * \n\t */\n\tonError?: (error: Error, url: string | ResolvedAsset) => void;\n\t/**\n\t * Strategy to handle load failures\n\t * - 'throw': Immediately throw an error and stop loading (default)\n\t * - 'skip': Skip the failed asset and continue loading others\n\t * - 'retry': Retry loading the asset a specified number of times\n\t * @default 'throw'\n\t * @example\n\t * \n\t */\n\tstrategy?: \"throw\" | \"skip\" | \"retry\";\n\t/**\n\t * Number of retry attempts if strategy is 'retry'\n\t * @default 3\n\t * @example\n\t * \n\t */\n\tretryCount?: number;\n\t/**\n\t * Delay in milliseconds between retry attempts\n\t * @default 250\n\t * @example\n\t * \n\t */\n\tretryDelay?: number;\n}\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * \n */\nexport interface BitmapFontInstallOptions {\n\t/**\n\t * The name of the font. This will be used as the fontFamily in text styles to access this font.\n\t * Must be unique across all installed bitmap fonts.\n\t * @example\n\t * \n\t */\n\tname?: string;\n\t/**\n\t * Characters included in the font set. You can specify individual characters or ranges.\n\t * Don't forget to include spaces ' ' in your character set!\n\t * @default BitmapFont.ALPHANUMERIC\n\t * @example\n\t * \n\t */\n\tchars?: string | (string | string[])[];\n\t/**\n\t * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n\t * Useful for supporting high-DPI displays.\n\t * @default 1\n\t * @example\n\t * \n\t */\n\tresolution?: number;\n\t/**\n\t * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n\t * - Lower values: More compact, but may have visual artifacts\n\t * - Higher values: Better quality, but uses more texture space\n\t * @default 4\n\t * @example\n\t * \n\t */\n\tpadding?: number;\n\t/**\n\t * Skip generation of kerning information for the BitmapFont.\n\t * - true: Faster generation, but text may have inconsistent spacing\n\t * - false: Better text appearance, but slower generation\n\t * @default false\n\t * @example\n\t * \n\t */\n\tskipKerning?: boolean;\n\t/**\n\t * Style options to render the BitmapFont with.\n\t * Supports all TextStyle properties including fill, stroke, and shadow effects.\n\t * @example\n\t * \n\t */\n\tstyle?: TextStyle | TextStyleOptions;\n\t/**\n\t * Optional texture style to use when creating the font textures.\n\t * Controls how the font textures are rendered and filtered.\n\t * @example\n\t * \n\t */\n\ttextureStyle?: TextureStyle | TextureStyleOptions;\n\t/**\n\t * Whether to allow overriding the fill color with a tint at runtime.\n\t *\n\t * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n\t * allowing a single font to display multiple colors without creating separate font textures.\n\t * This is memory efficient but requires the font to be rendered with white fill color.\n\t *\n\t * When disabled, the fill color is permanently baked into the font texture. This allows\n\t * any fill color but prevents runtime tinting - each color variation requires a separate font.\n\t * @default false (automatically determined based on style)\n\t *\n\t * **Requirements for tinting:**\n\t * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n\t * - No stroke effects\n\t * - No drop shadows (or only black shadows)\n\t * - No gradient or pattern fills\n\t *\n\t * **Performance considerations:**\n\t * - âœ… Enabled: One font texture, multiple colors via tinting (memory efficient)\n\t * - âŒ Disabled: Separate font texture per color (higher memory usage)\n\t * @example\n\t * \n\t * @example\n\t * \n\t * @example\n\t * \n\t */\n\tdynamicFill?: boolean;\n}\ndeclare class BitmapFontManagerClass {\n\t/**\n\t * This character set includes all the letters in the alphabet (both lower- and upper- case).\n\t * @type {string[][]}\n\t * @example\n\t * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n\t */\n\treadonly ALPHA: (string | string[])[];\n\t/**\n\t * This character set includes all decimal digits (from 0 to 9).\n\t * @type {string[][]}\n\t * @example\n\t * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n\t */\n\treadonly NUMERIC: string[][];\n\t/**\n\t * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n\t * @type {string[][]}\n\t */\n\treadonly ALPHANUMERIC: (string | string[])[];\n\t/**\n\t * This character set consists of all the ASCII table.\n\t * @type {string[][]}\n\t */\n\treadonly ASCII: string[][];\n\t/** Default options for installing a new BitmapFont. */\n\tdefaultOptions: Omit<BitmapFontInstallOptions, \"style\">;\n\t/** Cache for measured text layouts to avoid recalculating them multiple times. */\n\treadonly measureCache: import(\"tiny-lru\").LRU<BitmapTextLayoutData>;\n\t/**\n\t * Get a font for the specified text and style.\n\t * @param text - The text to get the font for\n\t * @param style - The style to use\n\t */\n\tgetFont(text: string, style: TextStyle): BitmapFont;\n\t/**\n\t * Get the layout of a text for the specified style.\n\t * @param text - The text to get the layout for\n\t * @param style - The style to use\n\t * @param trimEnd - Whether to ignore whitespaces at the end of each line\n\t */\n\tgetLayout(text: string, style: TextStyle, trimEnd?: boolean): BitmapTextLayoutData;\n\t/**\n\t * Measure the text using the specified style.\n\t * @param text - The text to measure\n\t * @param style - The style to use\n\t * @param trimEnd - Whether to ignore whitespaces at the end of each line\n\t */\n\tmeasureText(text: string, style: TextStyle, trimEnd?: boolean): {\n\t\twidth: number;\n\t\theight: number;\n\t\tscale: number;\n\t\toffsetY: number;\n\t};\n\t/**\n\t * Generates a bitmap-font for the given style and character set\n\t * @param options - Setup options for font generation.\n\t * @returns Font generated by style options.\n\t * @example\n\t * import { BitmapFontManager, BitmapText } from 'pixi.js';\n\t *\n\t * BitmapFontManager.install('TitleFont', {\n\t *     fontFamily: 'Arial',\n\t *     fontSize: 12,\n\t *     strokeThickness: 2,\n\t *     fill: 'purple',\n\t * });\n\t *\n\t * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n\t */\n\tinstall(options: BitmapFontInstallOptions): BitmapFont;\n\t/** @deprecated since 7.0.0 */\n\tinstall(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n\t/**\n\t * Uninstalls a bitmap font from the cache.\n\t * @param {string} name - The name of the bitmap font to uninstall.\n\t */\n\tuninstall(name: string): void;\n}\n/**\n * Options for creating a BitmapFont. Used when loading or creating bitmap fonts from existing textures and data.\n * @example\n * \n */\nexport interface BitmapFontOptions {\n\t/**\n\t * The bitmap font data containing character metrics, layout information,\n\t * and font properties. This includes character positions, dimensions,\n\t * kerning data, and general font settings.\n\t */\n\tdata: BitmapFontData;\n\t/**\n\t * Array of textures containing the font glyphs. Each texture corresponds\n\t * to a page in the font data. For simple fonts this is typically just\n\t * one texture, but complex fonts may split glyphs across multiple textures.\n\t */\n\ttextures: Texture[];\n}\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * This class handles both pre-loaded bitmap fonts and dynamically generated ones.\n * @example\n * \n */\nexport declare class BitmapFont extends AbstractBitmapFont<BitmapFont> {\n\t/**\n\t * The URL from which the font was loaded, if applicable.\n\t * This is useful for tracking font sources and reloading.\n\t * @example\n\t * \n\t */\n\turl?: string;\n\tconstructor(options: BitmapFontOptions, url?: string);\n\t/** Destroys the BitmapFont object. */\n\tdestroy(): void;\n\t/**\n\t * Generates and installs a bitmap font with the specified options.\n\t * The font will be cached and available for use in BitmapText objects.\n\t * @param options - Setup options for font generation\n\t * @returns Installed font instance\n\t * @example\n\t * \n\t */\n\tstatic install(options: BitmapFontInstallOptions): void;\n\t/**\n\t * Uninstalls a bitmap font from the cache.\n\t * This frees up memory and resources associated with the font.\n\t * @param name - The name of the bitmap font to uninstall\n\t * @example\n\t * \n\t */\n\tstatic uninstall(name: string): void;\n}\nexport interface BitmapText extends PixiMixins.BitmapText, AbstractText<TextStyle, TextStyleOptions, TextOptions, BitmapTextGraphics> {\n}\n/**\n * A BitmapText object creates text using pre-rendered bitmap fonts.\n * It supports both loaded bitmap fonts (XML/FNT) and dynamically generated ones.\n *\n * To split a line you can use '\\n' in your text string, or use the `wordWrap` and\n * `wordWrapWidth` style properties.\n *\n * Key Features:\n * - High-performance text rendering using pre-generated textures\n * - Support for both pre-loaded and dynamic bitmap fonts\n * - Compatible with MSDF/SDF fonts for crisp scaling\n * - Automatic font reuse and optimization\n *\n * Performance Benefits:\n * - Faster rendering compared to Canvas/HTML text\n * - Lower memory usage for repeated characters\n * - More efficient text changes\n * - Better batching capabilities\n *\n * Limitations:\n * - Full character set support is impractical due to the number of chars (mainly affects CJK languages)\n * - Initial font generation/loading overhead\n * - Less flexible styling compared to Canvas/HTML text\n * @example\n * \n *\n * Font Types:\n * 1. Pre-loaded Bitmap Fonts:\n *    - Load via Asset Manager (XML/FNT formats)\n *    - Support for MSDF/SDF fonts\n *    - Create using tools like https://msdf-bmfont.donmccurdy.com/\n *\n * 2. Dynamic Bitmap Fonts:\n *    - Generated at runtime from system fonts\n *    - Automatic font reuse and optimization\n *    - Smart scaling for similar font sizes\n *\n * Font Management:\n * - Automatic font generation when needed\n * - Manual pre-installation via `BitmapFont.install`\n * - Smart font reuse to optimize memory\n * - Scale existing fonts instead of generating new ones when possible\n */\nexport declare class BitmapText extends AbstractText<TextStyle, TextStyleOptions, TextOptions, BitmapTextGraphics> implements View {\n\t/**\n\t * **Note:** Our docs parser struggles to properly understand the constructor signature.\n\t * This is the correct signature.\n\t * \n\t * @param { TextOptions } options - The options of the bitmap text.\n\t */\n\tconstructor(options?: TextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<TextStyle>);\n\t/**\n\t * The resolution / device pixel ratio for text rendering.\n\t * Unlike other text types, BitmapText resolution is managed by the BitmapFont.\n\t * Individual resolution changes are not supported.\n\t * @example\n\t * \n\t * @default 1\n\t * @throws {Warning} When attempting to change resolution directly\n\t */\n\tset resolution(value: number);\n\tget resolution(): number;\n}\n/**\n * Contains the output elements from a text split operation.\n * Provides access to the hierarchical structure of split text elements.\n * @example\n * \n */\nexport interface TextSplitOutput<T extends SplitableTextObject> {\n\t/** Array of individual character Text objects */\n\tchars: T[];\n\t/** Array of word containers, each containing character objects */\n\twords: Container[];\n\t/** Array of line containers, each containing word containers */\n\tlines: Container[];\n}\n/**\n * Configuration options for text splitting.\n */\nexport interface AbstractSplitOptions {\n\t/** Text content to be split */\n\ttext: string;\n\t/** Text styling - accepts TextStyle instance or style object */\n\tstyle: TextStyle | Partial<TextStyleOptions>;\n\t/**\n\t * Enables automatic splitting on text/style changes\n\t * @default true\n\t */\n\tautoSplit?: boolean;\n\t/**\n\t * Transform origin for line segments. Range: [0-1]\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tlineAnchor?: number | PointData;\n\t/**\n\t * Transform origin for word segments. Range: [0-1]\n\t * @example\n\t * \n\t * @default 0\n\t */\n\twordAnchor?: number | PointData;\n\t/**\n\t * Transform origin for character segments. Range: [0-1]\n\t * @example\n\t * \n\t * @default 0\n\t */\n\tcharAnchor?: number | PointData;\n}\n/**\n * Configuration options for SplitText, combining container properties with text splitting settings.\n * @example Basic Usage\n * \n * @example Advanced Configuration\n * \n *\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text split options from {@link AbstractSplitOptions}\n */\nexport interface AbstractSplitTextOptions extends ContainerOptions, AbstractSplitOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * @example Basic Usage\n * \n *\n * Features:\n * - Hierarchical text splitting (lines â†’ words â†’ characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * - Support for both canvas text and bitmap text\n * @example Animation Example\n * \n *\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n */\nexport declare abstract class AbstractSplitText<T extends SplitableTextObject> extends Container {\n\t/**\n\t * Individual character segments of the text.\n\t * @example\n\t * \n\t */\n\tchars: T[];\n\t/**\n\t * Word segments of the text, each containing one or more characters.\n\t * @example\n\t * \n\t */\n\twords: Container[];\n\t/**\n\t * Line segments of the text, each containing one or more words.\n\t * @example\n\t * \n\t */\n\tlines: Container[];\n\tconstructor(config: AbstractSplitTextOptions);\n\t/**\n\t * Splits the text into lines, words, and characters.\n\t * Call this manually when autoSplit is false.\n\t * @example Manual Splitting\n\t * \n\t */\n\tsplit(): void;\n\tget text(): string;\n\t/**\n\t * Gets or sets the text content.\n\t * Setting new text triggers splitting if autoSplit is true.\n\t * > [!NOTE] Setting this frequently can have a performance impact, especially with large texts and canvas text.\n\t * @example Dynamic Text Updates\n\t * \n\t */\n\tset text(value: string);\n\t/**\n\t * Gets or sets the transform anchor for line segments.\n\t * The anchor point determines the center of rotation and scaling for each line.\n\t * @example Setting Line Anchors\n\t * \n\t */\n\tget lineAnchor(): number | PointData;\n\tset lineAnchor(value: number | PointData);\n\t/**\n\t * Gets or sets the transform anchor for word segments.\n\t * The anchor point determines the center of rotation and scaling for each word.\n\t * @example\n\t * \n\t */\n\tget wordAnchor(): number | PointData;\n\tset wordAnchor(value: number | PointData);\n\t/**\n\t * Gets or sets the transform anchor for character segments.\n\t * The anchor point determines the center of rotation and scaling for each character.\n\t * @example Setting Character Anchors\n\t * \n\t * @example Animation with Anchors\n\t * \n\t */\n\tget charAnchor(): number | PointData;\n\tset charAnchor(value: number | PointData);\n\tget style(): TextStyle;\n\t/**\n\t * The style configuration for the text.\n\t * Can be a TextStyle instance or a configuration object.\n\t * @example\n\t * ts\n\t * // Clean up everything\n\t * text.destroy({ children: true, texture: true, style: true });\n\t *\n\t * // Remove from parent but keep style\n\t * text.destroy({ children: true, style: false });\n\t * ts\n * const options: SplitTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n * ts\n * const options: SplitTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n * ts\n * const text = new SplitText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n * ts\n * // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n * ts\n\t * // Override defaults globally\n\t * SplitText.defaultOptions = {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,  // Center alignment\n\t *   wordAnchor: { x: 0, y: 0.5 },  // Left-center\n\t *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center\n\t * };\n\t * ts\n\t * const text = new Text({\n\t *   text: 'Bitmap Text',\n\t *   style: { fontFamily: 'Arial' }\n\t * });\n\t *\n\t * const segmented = SplitText.from(text);\n\t *\n\t * // with additional options\n\t * const segmentedWithOptions = SplitText.from(text, {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,\n\t *   wordAnchor: { x: 0, y: 0.5 },\n\t * })\n\t * ts\n * // Basic HTML text\n * const basicText = new HTMLText({\n *     text: '<b>Bold</b> and <i>Italic</i> text',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Rich HTML text with styling\n * const richText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: 0x4a4a4a,\n *         align: 'center',\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n * ts\n * import { HTMLText } from 'pixi.js';\n *\n * // Basic HTML text with tags\n * const text = new HTMLText({\n *     text: '<h1>Title</h1><p>This is a <strong>bold</strong> and <em>italic</em> text.</p>',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Rich HTML text with custom styling\n * const richText = new HTMLText({\n *     text: `\n *         <div class=\"title\">Welcome</div>\n *         <div class=\"content\">\n *             This text supports:\n *             <ul>\n *                 <li>âœ¨ Emojis</li>\n *                 <li>ðŸŽ¨ Custom CSS</li>\n *                 <li>ðŸ“ Auto-sizing</li>\n *             </ul>\n *         </div>\n *     `,\n *     style: {\n *         fontSize: 24,\n *         fill: '#334455',\n *         cssOverrides: [\n *             '.title { font-size: 32px; color: red; }',\n *             '.content { line-height: 1.5; }'\n *         ],\n *         wordWrap: true,\n *         wordWrapWidth: 300,\n *     }\n * });\n *\n * // Text with custom texture settings\n * const crispText = new HTMLText({\n *     text: '<div style=\"padding: 10px\">High Quality Text</div>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#4a4a4a',\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n * ts\n\t * const text = new HTMLText({\n\t *     text: 'Hello Pixi!',\n\t * });\n\t * const multilineText = new HTMLText({\n\t *     text: 'Line 1\\nLine 2\\nLine 3',\n\t * });\n\t * const numberText = new HTMLText({\n\t *     text: 12345, // Will be converted to '12345'\n\t * });\n\t * const objectText = new HTMLText({\n\t *     text: { toString: () => 'Object Text' }, // Custom toString\n\t * });\n\t *\n\t * // Update text dynamically\n\t * text.text = 'Updated Text'; // Re-renders with new text\n\t * text.text = 67890; // Updates to '67890'\n\t * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n\t * // Clear text\n\t * text.text = ''; // Clears the text\n\t * ts\n * const options: SplitBitmapTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n * ts\n * const options: SplitBitmapTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n * ts\n * const text = new SplitBitmapText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n * ts\n * // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n * ts\n\t * // Override defaults globally\n\t * SplitBitmapText.defaultOptions = {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,  // Center alignment\n\t *   wordAnchor: { x: 0, y: 0.5 },  // Left-center\n\t *   charAnchor: { x: 0.5, y: 1 }   // Bottom-center\n\t * };\n\t * ts\n\t * const bitmapText = new BitmapText({\n\t *   text: 'Bitmap Text',\n\t *   style: { fontFamily: 'Arial' }\n\t * });\n\t *\n\t * const segmented = SplitBitmapText.from(bitmapText);\n\t *\n\t * // with additional options\n\t * const segmentedWithOptions = SplitBitmapText.from(bitmapText, {\n\t *   autoSplit: false,\n\t *   lineAnchor: 0.5,\n\t *   wordAnchor: { x: 0, y: 0.5 },\n\t * })\n\t * typescript\n\t * const bitmap = await WorkerManager.loadImageBitmap('image.png');\n\t * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);\n\t * typescript\n\t * // Clean up when shutting down\n\t * WorkerManager.reset();\n\t * ts\n * import { Culler, Container, Rectangle } from 'pixi.js';\n *\n * // Create a culler and container\n * const culler = new Culler();\n * const stage = new Container();\n *\n * // Set up container with culling\n * stage.cullable = true;\n * stage.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Add some sprites that will be culled\n * for (let i = 0; i < 1000; i++) {\n *     const sprite = Sprite.from('texture.png');\n *     sprite.x = Math.random() * 2000;\n *     sprite.y = Math.random() * 2000;\n *     sprite.cullable = true;\n *     stage.addChild(sprite);\n * }\n *\n * // Cull objects outside view\n * culler.cull(stage, {\n *     x: 0,\n *     y: 0,\n *     width: 800,\n *     height: 600\n * });\n *\n * // Only visible objects will be rendered\n * renderer.render(stage);\n * ts\n\t * // Basic culling with view bounds\n\t * const culler = new Culler();\n\t * culler.cull(stage, {\n\t *     x: 0,\n\t *     y: 0,\n\t *     width: 800,\n\t *     height: 600\n\t * });\n\t *\n\t * // Culling to renderer screen\n\t * culler.cull(stage, renderer.screen, false);\n\t * ts\n\t * // Use the shared instance instead of creating a new one\n\t * Culler.shared.cull(stage, {\n\t *     x: 0,\n\t *     y: 0,\n\t *     width: 800,\n\t *     height: 600\n\t * });\n\t * ts\n\t * AlphaFilter.defaultOptions = {\n\t *     alpha: 0.5, // Default alpha value\n\t * };\n\t * // Use default options\n\t * const filter = new AlphaFilter(); // Uses default alpha of 0.5\n\t * ts\n\t * // Create filter with initial alpha\n\t * const filter = new AlphaFilter({ alpha: 0.5 });\n\t *\n\t * // Update alpha value dynamically\n\t * filter.alpha = 0.8;\n\t * ts\n * // Basic blur with default values\n * const filter = new BlurFilter();\n *\n * // Custom blur configuration\n * const filter = new BlurFilter({\n *     strength: 8,        // Overall blur strength\n *     quality: 4,         // Higher quality = better blur\n *     kernelSize: 5      // Size of blur kernel\n * });\n *\n * // Different horizontal/vertical blur\n * const filter = new BlurFilter({\n *     strengthX: 4,      // Horizontal blur only\n *     strengthY: 12,     // Stronger vertical blur\n *     quality: 2         // Lower quality for better performance\n * });\n * ts\n * import { BlurFilter } from 'pixi.js';\n *\n * // Create with default settings\n * const filter = new BlurFilter();\n *\n * // Create with custom settings\n * const filter = new BlurFilter({\n *     strength: 8,      // Overall blur strength\n *     quality: 4,       // Blur quality (higher = better but slower)\n *     kernelSize: 5     // Size of blur kernel matrix\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Update properties\n * filter.strength = 10;          // Set both X and Y blur\n * filter.strengthX = 5;          // Set only horizontal blur\n * filter.strengthY = 15;         // Set only vertical blur\n * filter.quality = 2;            // Adjust quality\n *\n * // Enable edge pixel clamping\n * filter.repeatEdgePixels = true;\n * ts\n\t * // Set default options for all BlurFilters\n\t * BlurFilter.defaultOptions = {\n\t *     strength: 10,       // Default blur strength\n\t *     quality: 2,        // Default blur quality\n\t *     kernelSize: 7      // Default kernel size\n\t * };\n\t * // Create a filter with these defaults\n\t * const filter = new BlurFilter(); // Uses default options\n\t * ts\n\t * // Set equal blur strength for both axes\n\t * filter.strength = 8;\n\t *\n\t * // Will throw error if X and Y are different\n\t * filter.strengthX = 4;\n\t * filter.strengthY = 8;\n\t * filter.strength; // Error: BlurFilter's strengthX and strengthY are different\n\t * ts\n\t * // High quality blur (slower)\n\t * filter.quality = 8;\n\t *\n\t * // Low quality blur (faster)\n\t * filter.quality = 2;\n\t * ts\n\t * // Apply horizontal-only blur\n\t * filter.strengthX = 8;\n\t * filter.strengthY = 0;\n\t *\n\t * // Create motion blur effect\n\t * filter.strengthX = 16;\n\t * filter.strengthY = 2;\n\t * ts\n\t * // Apply vertical-only blur\n\t * filter.strengthX = 0;\n\t * filter.strengthY = 8;\n\t *\n\t * // Create radial blur effect\n\t * filter.strengthX = 8;\n\t * filter.strengthY = 8;\n\t * js\n * import { ColorMatrixFilter } from 'pixi.js';\n *\n * // Create a new color matrix filter\n * const colorMatrix = new ColorMatrixFilter();\n *\n * // Apply it to a container\n * container.filters = [colorMatrix];\n *\n * // Adjust contrast\n * colorMatrix.contrast(2);\n *\n * // Chain multiple effects\n * colorMatrix\n *     .saturate(0.5)     // 50% saturation\n *     .brightness(1.2)    // 20% brighter\n *     .hue(90);          // 90 degree hue rotation\n * ts\n\t * // Create a new color matrix filter\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Darken the image to 50% brightness\n\t * colorMatrix.brightness(0.5, false);\n\t *\n\t * // Chain with other effects by using multiply\n\t * colorMatrix\n\t *     .brightness(1.2, true)  // Brighten by 20%\n\t *     .saturate(1.1, true);   // Increase saturation by 10%\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply a red tint\n\t * colorMatrix.tint(0xff0000);\n\t *\n\t * // Layer a green tint on top of existing effects\n\t * colorMatrix.tint('green', true);\n\t *\n\t * // Chain with other color adjustments\n\t * colorMatrix\n\t *     .tint('blue')       // Blue tint\n\t *     .brightness(1.2, true) // Increase brightness\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to 50% grey\n\t * colorMatrix.greyscale(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .greyscale(0.6, true)    // Add grey tint\n\t *     .brightness(1.2, true);   // Brighten the result\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to 50% grey\n\t * colorMatrix.grayscale(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .grayscale(0.6, true)    // Add grey tint\n\t *     .brightness(1.2, true);   // Brighten the result\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert to black and white\n\t * colorMatrix.blackAndWhite(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .blackAndWhite(true)     // Apply B&W effect\n\t *     .brightness(1.2, true);   // Then increase brightness\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Rotate hue by 90 degrees\n\t * colorMatrix.hue(90, false);\n\t *\n\t * // Chain multiple color adjustments\n\t * colorMatrix\n\t *     .hue(45, true)          // Rotate colors by 45Â°\n\t *     .saturate(1.2, true)    // Increase saturation\n\t *     .brightness(1.1, true); // Slightly brighten\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Increase contrast by 50%\n\t * colorMatrix.contrast(0.75, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .contrast(0.6, true)     // Boost contrast\n\t *     .brightness(1.1, true)   // Slightly brighten\n\t *     .saturate(1.2, true);    // Increase color intensity\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Double the saturation\n\t * colorMatrix.saturate(1, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .saturate(0.5, true)     // Increase saturation by 50%\n\t *     .brightness(1.1, true)    // Slightly brighten\n\t *     .contrast(0.8, true);     // Reduce contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Convert image to grayscale\n\t * colorMatrix.desaturate();\n\t *\n\t * // Can be chained with other effects\n\t * colorMatrix\n\t *     .desaturate()         // Remove all color\n\t *     .brightness(1.2);     // Then increase brightness\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Create negative effect\n\t * colorMatrix.negative(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .negative(true)       // Apply negative effect\n\t *     .brightness(1.2, true) // Increase brightness\n\t *     .contrast(0.8, true);  // Reduce contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply sepia effect\n\t * colorMatrix.sepia(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .sepia(true)           // Add sepia tone\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(0.9, true);   // Reduce contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Technicolor effect\n\t * colorMatrix.technicolor(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .technicolor(true)      // Add Technicolor effect\n\t *     .contrast(1.1, true)    // Boost contrast\n\t *     .brightness(0.9, true); // Slightly darken\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Polaroid effect\n\t * colorMatrix.polaroid(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .polaroid(true)         // Add Polaroid effect\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(1.1, true);   // Boost contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Swap red and blue channels\n\t * colorMatrix.toBGR(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .toBGR(true)           // Swap R and B channels\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(0.9, true);   // Reduce contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply Kodachrome effect\n\t * colorMatrix.kodachrome(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .kodachrome(true)       // Add Kodachrome effect\n\t *     .contrast(1.1, true)    // Boost contrast\n\t *     .brightness(0.9, true); // Slightly darken\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply browni effect\n\t * colorMatrix.browni(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .browni(true)          // Add brown tint\n\t *     .brightness(1.1, true)  // Slightly brighten\n\t *     .contrast(1.2, true);   // Boost contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply vintage effect\n\t * colorMatrix.vintage(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .vintage(true)          // Add vintage look\n\t *     .brightness(0.9, true)  // Slightly darken\n\t *     .contrast(1.1, true);   // Boost contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Create sepia-like effect with custom colors\n\t * colorMatrix.colorTone(\n\t *     0.3,        // Moderate desaturation\n\t *     0.2,        // Moderate toning\n\t *     0xFFE580,   // Warm highlight color\n\t *     0x338000,   // Dark green shadows\n\t *     false\n\t * );\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .colorTone(0.2, 0.15, 0xFFE580, 0x338000, true)\n\t *     .brightness(1.1, true);  // Slightly brighten\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply night vision effect\n\t * colorMatrix.night(0.3, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .night(0.2, true)        // Add night vision\n\t *     .brightness(1.1, true)    // Slightly brighten\n\t *     .contrast(1.2, true);     // Boost contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply thermal vision effect\n\t * colorMatrix.predator(0.5, false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .predator(0.3, true)      // Add thermal effect\n\t *     .contrast(1.2, true)      // Boost contrast\n\t *     .brightness(1.1, true);   // Slightly brighten\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply psychedelic effect\n\t * colorMatrix.lsd(false);\n\t *\n\t * // Chain with other effects\n\t * colorMatrix\n\t *     .lsd(true)             // Add color distortion\n\t *     .brightness(0.9, true)  // Slightly darken\n\t *     .contrast(1.2, true);   // Boost contrast\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply some effects\n\t * colorMatrix\n\t *     .sepia(true)\n\t *     .brightness(1.2, true);\n\t *\n\t * // Reset back to original colors\n\t * colorMatrix.reset();\n\t * ts\n\t * const colorMatrix = new ColorMatrixFilter();\n\t * // Get the current color matrix\n\t * const currentMatrix = colorMatrix.matrix;\n\t * // Modify the matrix\n\t * colorMatrix.matrix = [\n\t *     1, 0, 0, 0, 0,\n\t *     0, 1, 0, 0, 0,\n\t *     0, 0, 1, 0, 0,\n\t *     0, 0, 0, 1, 0\n\t * ];\n\t */\n\tget matrix(): ColorMatrix;\n\tset matrix(value: ColorMatrix);\n\t/**\n\t * The opacity value used to blend between the original and transformed colors.\n\t *\n\t * This value controls how much of the color transformation is applied:\n\t * - 0 = Original color only (no effect)\n\t * - 0.5 = 50% blend of original and transformed colors\n\t * - 1 = Fully transformed color (default)\n\t * @default 1\n\t * @example\n\t * \n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n}\n/**\n * Configuration options for the DisplacementFilter.\n *\n * A displacement filter uses a sprite's texture as a displacement map,\n * moving pixels of the target based on the color values of corresponding\n * pixels in the displacement sprite.\n * @example\n * \n */\nexport interface DisplacementFilterOptions extends FilterOptions {\n\t/**\n\t * The sprite whose texture will be used as the displacement map.\n\t * Red channel = horizontal displacement\n\t * Green channel = vertical displacement\n\t * @example\n\t * \n\t */\n\tsprite: Sprite;\n\t/**\n\t * The scale of the displacement effect. Can be a single number for uniform\n\t * scaling or a point-like object for separate x/y scaling.\n\t * @default 20\n\t * @example\n\t * \n\t */\n\tscale?: number | PointData;\n}\n/**\n * A filter that applies a displacement map effect using a sprite's texture.\n *\n * The DisplacementFilter uses another texture (from a sprite) as a displacement map,\n * where the red and green channels of each pixel in the map determine how the corresponding\n * pixel in the filtered object should be offset:\n * - Red channel controls horizontal displacement\n * - Green channel controls vertical displacement\n *\n * Common use cases:\n * - Creating ripple or wave effects\n * - Distorting images dynamically\n * - Implementing heat haze effects\n * - Creating transition effects\n * @example\n * \n */\nexport declare class DisplacementFilter extends Filter {\n\t/**\n\t * @param {Sprite | DisplacementFilterOptions} options - The sprite or options object.\n\t * @param {Sprite} options.sprite - The texture used for the displacement map.\n\t * @param {number | PointData} options.scale - The scale of the displacement.\n\t */\n\tconstructor(options: Sprite | DisplacementFilterOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(sprite: Sprite, scale?: number | PointData);\n\t/**\n\t * The scale of the displacement effect.\n\t *\n\t * Gets the current x and y scaling values used for the displacement mapping.\n\t * - x: Horizontal displacement scale\n\t * - y: Vertical displacement scale\n\t * @returns {Point} The current scale as a Point object\n\t * @example\n\t * \n\t */\n\tget scale(): Point;\n}\n/**\n * Configuration options for the NoiseFilter.\n *\n * The NoiseFilter adds random noise to the rendered content. The noise effect can be\n * controlled through the noise intensity and an optional seed value for reproducible results.\n * @example\n * \n */\nexport interface NoiseFilterOptions extends FilterOptions {\n\t/**\n\t * The amount of noise to apply. Should be in range (0, 1]:\n\t * - 0.1 = subtle noise\n\t * - 0.5 = moderate noise (default)\n\t * - 1.0 = maximum noise\n\t * @default 0.5\n\t * @example\n\t * \n\t */\n\tnoise?: number;\n\t/**\n\t * A seed value to apply to the random noise generation.\n\t * Using the same seed will generate the same noise pattern.\n\t * @default Math.random()\n\t * @example\n\t * \n\t */\n\tseed?: number;\n}\n/**\n * A filter that adds configurable random noise to rendered content.\n *\n * This filter generates pixel noise based on a noise intensity value and an optional seed.\n * It can be used to create various effects like film grain, static, or texture variation.\n *\n * Based on: https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\n * @example\n * \n */\nexport declare class NoiseFilter extends Filter {\n\t/**\n\t * The default configuration options for the NoiseFilter.\n\t *\n\t * These values will be used when no specific options are provided to the constructor.\n\t * You can override any of these values by passing your own options object.\n\t * @example\n\t * \n\t */\n\tstatic defaultOptions: NoiseFilterOptions;\n\t/**\n\t * @param options - The options of the noise filter.\n\t */\n\tconstructor(options?: NoiseFilterOptions);\n\t/**\n\t * The amount of noise to apply to the filtered content.\n\t *\n\t * This value controls the intensity of the random noise effect:\n\t * - Values close to 0 produce subtle noise\n\t * - Values around 0.5 produce moderate noise\n\t * - Values close to 1 produce strong noise\n\t * @default 0.5\n\t * @example\n\t * \n\t */\n\tget noise(): number;\n\tset noise(value: number);\n\t/**\n\t * The seed value used for random noise generation.\n\t *\n\t * This value determines the noise pattern:\n\t * - Using the same seed will generate identical noise patterns\n\t * - Different seeds produce different but consistent patterns\n\t * - `Math.random()` can be used for random patterns\n\t * @default Math.random()\n\t * @example\n\t * \n\t */\n\tget seed(): number;\n\tset seed(value: number);\n}\ntype GD8Symmetry = number;\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * \n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * \n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * \n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * \n *\n * or:\n *\n * \n */\nexport declare class Spritesheet<S extends SpritesheetData = SpritesheetData> {\n\t/** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n\tlinkedSheets: Spritesheet<S>[];\n\t/** Reference to the source texture. */\n\ttextureSource: TextureSource;\n\t/**\n\t * A map containing all textures of the sprite sheet.\n\t * Can be used to create a {@link Sprite}:\n\t * @example\n\t * import { Sprite } from 'pixi.js';\n\t *\n\t * new Sprite(sheet.textures['image.png']);\n\t */\n\ttextures: Record<keyof S[\"frames\"], Texture>;\n\t/**\n\t * A map containing the textures for each animation.\n\t * Can be used to create an {@link AnimatedSprite}:\n\t * @example\n\t * import { AnimatedSprite } from 'pixi.js';\n\t *\n\t * new AnimatedSprite(sheet.animations['anim_name']);\n\t */\n\tanimations: Record<keyof NonNullable<S[\"animations\"]>, Texture[]>;\n\t/**\n\t * Reference to the original JSON data.\n\t * @type {object}\n\t */\n\tdata: S;\n\t/** The resolution of the spritesheet. */\n\tresolution: number;\n\t/** Prefix string to add to global cache */\n\treadonly cachePrefix: string;\n\t/**\n\t * @param options - Options to use when constructing a new Spritesheet.\n\t */\n\tconstructor(options: SpritesheetOptions<S>);\n\t/**\n\t * @param texture - Reference to the source BaseTexture object.\n\t * @param {object} data - Spritesheet image data.\n\t */\n\tconstructor(texture: BindableTexture, data: S);\n\t/**\n\t * Parser spritesheet from loaded data. This is done asynchronously\n\t * to prevent creating too many Texture within a single process.\n\t */\n\tparse(): Promise<Record<string, Texture>>;\n\t/**\n\t * Destroy Spritesheet and don't use after this.\n\t * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n\t */\n\tdestroy(destroyBase?: boolean): void;\n}\n/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @enum {number}\n */\nexport declare enum UPDATE_PRIORITY {\n\t/**\n\t * Highest priority used for interaction events in {@link EventSystem}\n\t * @default 50\n\t */\n\tINTERACTION = 50,\n\t/**\n\t * High priority updating, used by {@link AnimatedSprite}\n\t * @default 25\n\t */\n\tHIGH = 25,\n\t/**\n\t * Default priority for ticker events, see {@link Ticker#add}.\n\t * @default 0\n\t */\n\tNORMAL = 0,\n\t/**\n\t * Low priority used for {@link Application} rendering.\n\t * @default -25\n\t */\n\tLOW = -25,\n\t/**\n\t * Lowest priority used for {@link PrepareBase} utility.\n\t * @default -50\n\t */\n\tUTILITY = -50\n}\n/**\n * Helper for checking for WebGL support in the current environment.\n *\n * Results are cached after first call for better performance.\n * @example\n * \n * @param failIfMajorPerformanceCaveat - Whether to fail if there is a major performance caveat\n * @returns True if WebGL is supported\n */\nexport declare function isWebGLSupported(failIfMajorPerformanceCaveat?: boolean): boolean;\n/**\n * Helper for checking for WebGPU support in the current environment.\n * Results are cached after first call for better performance.\n * @example\n * \n * @param options - The options for requesting a GPU adapter\n * @returns Promise that resolves to true if WebGPU is supported\n */\nexport declare function isWebGPUSupported(options?: GPURequestAdapterOptions): Promise<boolean>;\ninterface DeprecationOptions {\n\t/**\n\t * When set to true, all deprecation warning messages will be hidden.\n\t * Use this if you want to silence deprecation notifications.\n\t * @default false\n\t */\n\tquiet: boolean;\n\t/**\n\t * When set to true, deprecation messages will be displayed as plain text without color formatting.\n\t * Use this if you want to disable colored console output for deprecation warnings.\n\t * @default false\n\t */\n\tnoColor: boolean;\n}\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * \n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n */\nexport declare const path: Path;\ninterface Cleanable {\n\tclear(): void;\n}\n\nexport {\n\tBuffer$1 as Buffer,\n\tCache$1 as Cache,\n\tEXT_texture_compression_bptc$1 as EXT_texture_compression_bptc,\n\tEXT_texture_compression_rgtc$1 as EXT_texture_compression_rgtc,\n\tExtensionFormat as ExtensionFormatLoose,\n\tGPU$1 as GPU,\n\tPredefinedColorSpace$1 as PredefinedColorSpace,\n\tRenderingContext$1 as RenderingContext,\n\tStrictExtensionFormat as ExtensionFormat,\n\tText$1 as Text,\n\tWEBGL_compressed_texture_etc$1 as WEBGL_compressed_texture_etc,\n\tWEBGL_compressed_texture_etc1$1 as WEBGL_compressed_texture_etc1,\n\tWEBGL_compressed_texture_pvrtc$1 as WEBGL_compressed_texture_pvrtc,\n\tearcut$1 as earcut,\n};\n\nexport as namespace PIXI;",
  "code_samples": [
    {
      "code": "// Generated by dts-bundle-generator v9.5.1\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n */\nexport declare class EventEmitter<EventTypes extends EventEmitter.ValidEventTypes = string | symbol, Context extends any = any> {\n\tstatic prefixed: string | boolean;\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t */\n\teventNames(): Array<EventEmitter.EventNames<EventTypes>>;\n\t/**\n\t * Return the listeners registered for a given event.\n\t */\n\tlisteners<T extends EventEmitter.EventNames<EventTypes>>(event: T): Array<EventEmitter.EventListener<EventTypes, T>>;\n\t/**\n\t * Return the number of listeners listening to a given event.\n\t */\n\tlistenerCount(event: EventEmitter.EventNames<EventTypes>): number;\n\t/**\n\t * Calls each of the listeners registered for a given event.\n\t */\n\temit<T extends EventEmitter.EventNames<EventTypes>>(event: T, ...args: EventEmitter.EventArgs<EventTypes, T>): boolean;\n\t/**\n\t * Add a listener for a given event.\n\t */\n\ton<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\taddListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\t/**\n\t * Add a one-time listener for a given event.\n\t */\n\tonce<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn: EventEmitter.EventListener<EventTypes, T>, context?: Context): this;\n\t/**\n\t * Remove the listeners of a given event.\n\t */\n\tremoveListener<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;\n\toff<T extends EventEmitter.EventNames<EventTypes>>(event: T, fn?: EventEmitter.EventListener<EventTypes, T>, context?: Context, once?: boolean): this;\n\t/**\n\t * Remove all listeners, or those of the specified event.\n\t */\n\tremoveAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;\n}\nexport declare namespace EventEmitter {\n\texport interface ListenerFn<Args extends any[] = any[]> {\n\t\t(...args: Args): void;\n\t}\n\texport interface EventEmitterStatic {\n\t\tnew <EventTypes extends ValidEventTypes = string | symbol, Context = any>(): EventEmitter<EventTypes, Context>;\n\t}\n\t/**\n\t * `object` should be in either of the following forms:\n\t *",
      "language": "typescript"
    },
    {
      "code": "*/\n\texport type ValidEventTypes = string | symbol | object;\n\texport type EventNames<T extends ValidEventTypes> = T extends string | symbol ? T : keyof T;\n\texport type ArgumentMap<T extends object> = {\n\t\t[K in keyof T]: T[K] extends (...args: any[]) => void ? Parameters<T[K]> : T[K] extends any[] ? T[K] : any[];\n\t};\n\texport type EventListener<T extends ValidEventTypes, K extends EventNames<T>> = T extends string | symbol ? (...args: any[]) => void : (...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]) => void;\n\texport type EventArgs<T extends ValidEventTypes, K extends EventNames<T>> = Parameters<EventListener<T, K>>;\n\texport const EventEmitter: EventEmitterStatic;\n}\ndeclare type RgbColor = {\n\tr: number;\n\tg: number;\n\tb: number;\n};\ndeclare type HslColor = {\n\th: number;\n\ts: number;\n\tl: number;\n};\ndeclare type HsvColor = {\n\th: number;\n\ts: number;\n\tv: number;\n};\ndeclare type WithAlpha<O> = O & {\n\ta: number;\n};\ndeclare type RgbaColor = WithAlpha<RgbColor>;\ndeclare type HslaColor = WithAlpha<HslColor>;\ndeclare type HsvaColor = WithAlpha<HsvColor>;\n/**\n * Array of RGBA color components, where each component is a number between 0 and 1.\n * The array must contain exactly 4 numbers in the order: red, green, blue, alpha.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - All components must be between 0 and 1\n * - Array must contain exactly 4 values\n * - Order is [red, green, blue, alpha]\n */\nexport type RgbaArray = [\n\tnumber,\n\tnumber,\n\tnumber,\n\tnumber\n];\n/**\n * Valid color formats supported by PixiJS. These types extend from [colord](https://www.npmjs.com/package/colord)\n * with additional PixiJS-specific formats.\n *\n * Common Formats:\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - All color values are normalized internally to 0-1 range\n * - Alpha is always between 0-1\n * - Invalid colors will throw an error\n * - Original format is preserved when possible\n * @since 7.2.0\n */\nexport type ColorSource = string | number | number[] | Float32Array | Uint8Array | Uint8ClampedArray | HslColor | HslaColor | HsvColor | HsvaColor | RgbColor | RgbaColor | Color | number;\n/**\n * Color utility class for managing colors in various formats. Provides a unified way to work\n * with colors across your PixiJS application.\n *\n * Features:\n * - Accepts multiple color formats (hex, RGB, HSL, etc.)\n * - Automatic format conversion\n * - Color manipulation methods\n * - Component access (r,g,b,a)\n * - Chainable operations\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * The Color class automatically normalizes all color values internally:\n * - RGB components are stored as floats between 0-1\n * - Alpha is always between 0-1\n * - Color operations clamp values to valid ranges\n * - Original input format is preserved when possible\n * @since 7.2.0\n */\nexport declare class Color {\n\t/**\n\t * Static shared Color instance used for utility operations. This is a singleton color object\n\t * that can be reused to avoid creating unnecessary Color instances.\n\t * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be\n\t * > changed by any code that uses it.\n\t * >\n\t * > It is best used for one-off color operations or temporary transformations.\n\t * > For persistent colors, create your own Color instance instead.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - This is a shared instance - be careful about multiple code paths using it simultaneously\n\t * - Use for temporary color operations to avoid allocating new Color instances\n\t * - The value is preserved between operations, so reset if needed\n\t * - For persistent colors, create your own Color instance instead\n\t */\n\tstatic readonly shared: Color;\n\t/**\n\t * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n\t */\n\tconstructor(value?: ColorSource);\n\t/**\n\t * Get the red component of the color, normalized between 0 and 1.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget red(): number;\n\t/**\n\t * Get the green component of the color, normalized between 0 and 1.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget green(): number;\n\t/**\n\t * Get the blue component of the color, normalized between 0 and 1.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget blue(): number;\n\t/**\n\t * Get the alpha component of the color, normalized between 0 and 1.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget alpha(): number;\n\t/**\n\t * Sets the color value and returns the instance for chaining.\n\t *\n\t * This is a chainable version of setting the `value` property.\n\t * @param value - The color to set. Accepts various formats:\n\t * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n\t * - RGB/RGBA values (arrays, objects)\n\t * - CSS color names\n\t * - HSL/HSLA values\n\t * - HSV/HSVA values\n\t * @returns The Color instance for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @throws {Error} If the color value is invalid or null\n\t */\n\tsetValue(value: ColorSource): this;\n\t/**\n\t * The current color source. This property allows getting and setting the color value\n\t * while preserving the original format where possible.\n\t * @remarks\n\t * When setting:\n\t * - Setting to a `Color` instance copies its source and components\n\t * - Setting to other valid sources normalizes and stores the value\n\t * - Setting to `null` throws an Error\n\t * - The color remains unchanged if normalization fails\n\t *\n\t * When getting:\n\t * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}\n\t * - Otherwise returns the original color source\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @throws {Error} When attempting to set `null`\n\t */\n\tset value(value: ColorSource | null);\n\tget value(): Exclude<ColorSource, Color> | null;\n\t/**\n\t * Convert to a RGBA color object with normalized components (0-1).\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns An RGBA object with normalized components\n\t */\n\ttoRgba(): RgbaColor;\n\t/**\n\t * Convert to a RGB color object with normalized components (0-1).\n\t *\n\t * Alpha component is omitted in the output.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns An RGB object with normalized components\n\t */\n\ttoRgb(): RgbColor;\n\t/**\n\t * Convert to a CSS-style rgba string representation.\n\t *\n\t * RGB components are scaled to 0-255 range, alpha remains 0-1.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A CSS-compatible rgba string\n\t */\n\ttoRgbaString(): string;\n\t/**\n\t * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n\t * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGB components as integers between 0-255\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Output values are always clamped between 0-255\n\t * - Alpha component is not included in output\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray = number[]>(out?: T): T;\n\t/**\n\t * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n\t * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGBA components as floats between 0-1\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Output values are normalized between 0-1\n\t * - Includes alpha component as the fourth value\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoArray<T extends number[] | Float32Array = number[]>(out?: T): T;\n\t/**\n\t * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n\t * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n\t * a cached array will be used and returned.\n\t * @returns Array containing RGB components as floats between 0-1\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Output values are normalized between 0-1\n\t * - Alpha component is omitted from output\n\t * - Reuses internal cache array if no output array provided\n\t */\n\ttoRgbArray<T extends number[] | Float32Array = number[]>(out?: T): T;\n\t/**\n\t * Convert to a hexadecimal number.\n\t * @returns The color as a 24-bit RGB integer\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttoNumber(): number;\n\t/**\n\t * Convert to a BGR number.\n\t *\n\t * Useful for platforms that expect colors in BGR format.\n\t * @returns The color as a 24-bit BGR integer\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * This swaps the red and blue channels compared to the normal RGB format:\n\t * - RGB 0xRRGGBB becomes BGR 0xBBGGRR\n\t */\n\ttoBgrNumber(): number;\n\t/**\n\t * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n\t *\n\t * Useful for platforms that expect colors in little endian byte order.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Swaps R and B channels in the color value\n\t * - RGB 0xRRGGBB becomes 0xBBGGRR\n\t * - Useful for systems that use little endian byte order\n\t * - Can be used to convert back and forth between formats\n\t * @returns The color as a number in little endian format (BBGGRR)\n\t */\n\ttoLittleEndianNumber(): number;\n\t/**\n\t * Multiply with another color.\n\t *\n\t * This action is destructive and modifies the original color.\n\t * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:\n\t * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n\t * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])\n\t * - Color objects ({ r: 1, g: 0, b: 0 })\n\t * - CSS color names ('red', 'blue')\n\t * @returns this - The Color instance for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Multiplies each RGB component and alpha separately\n\t * - Values are clamped between 0-1\n\t * - Original color format is lost (value becomes null)\n\t * - Operation cannot be undone\n\t */\n\tmultiply(value: ColorSource): this;\n\t/**\n\t * Converts color to a premultiplied alpha format.\n\t *\n\t * This action is destructive and modifies the original color.\n\t * @param alpha - The alpha value to multiply by (0-1)\n\t * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n\t * @returns {Color} The Color instance for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - RGB channels are multiplied by alpha when applyToRGB is true\n\t * - Alpha is always set to the provided value\n\t * - Values are clamped between 0-1\n\t * - Original color format is lost (value becomes null)\n\t * - Operation cannot be undone\n\t */\n\tpremultiply(alpha: number, applyToRGB?: boolean): this;\n\t/**\n\t * Returns the color as a 32-bit premultiplied alpha integer.\n\t *\n\t * Format: 0xAARRGGBB\n\t * @param {number} alpha - The alpha value to multiply by (0-1)\n\t * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n\t * @returns {number} The premultiplied color as a 32-bit integer\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Returns full opacity (0xFF000000) when alpha is 1.0\n\t * - Returns 0 when alpha is 0.0 and applyToRGB is true\n\t * - RGB values are rounded during premultiplication\n\t */\n\ttoPremultiplied(alpha: number, applyToRGB?: boolean): number;\n\t/**\n\t * Convert to a hexadecimal string (6 characters).\n\t * @returns A CSS-compatible hex color string (e.g., \"#ff0000\")\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Always returns a 6-character hex string\n\t * - Includes leading \"#\" character\n\t * - Alpha channel is ignored\n\t * - Values are rounded to nearest hex value\n\t */\n\ttoHex(): string;\n\t/**\n\t * Convert to a hexadecimal string with alpha (8 characters).\n\t * @returns A CSS-compatible hex color string with alpha (e.g., \"#ff0000ff\")\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Returns an 8-character hex string\n\t * - Includes leading \"#\" character\n\t * - Alpha is encoded in last two characters\n\t * - Values are rounded to nearest hex value\n\t */\n\ttoHexa(): string;\n\t/**\n\t * Set alpha (transparency) value while preserving color components.\n\t *\n\t * Provides a chainable interface for setting alpha.\n\t * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)\n\t * @returns The Color instance for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Alpha value is clamped between 0-1\n\t * - Can be chained with other color operations\n\t */\n\tsetAlpha(alpha: number): this;\n\t/**\n\t * Check if a value can be interpreted as a valid color format.\n\t * Supports all color formats that can be used with the Color class.\n\t * @param value - Value to check\n\t * @returns True if the value can be used as a color\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * Checks for the following formats:\n\t * - Numbers (0x000000 to 0xffffff)\n\t * - CSS color strings\n\t * - RGB/RGBA arrays and objects\n\t * - HSL/HSLA objects\n\t * - HSV/HSVA objects\n\t * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)\n\t * - Color instances\n\t */\n\tstatic isColorLike(value: unknown): value is ColorSource;\n}\n/**\n * Common interface for points. Both Point and ObservablePoint implement it.\n * Provides a standard way to represent 2D coordinates.\n *\n * Many PixiJS methods accept PointData for transformations,\n * making it easy to work with different point types interchangeably.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Basic x,y coordinate interface\n * - Used by Point and ObservablePoint\n */\nexport interface PointData {\n\t/** X coordinate */\n\tx: number;\n\t/** Y coordinate */\n\ty: number;\n}\n/**\n * Common interface for points with manipulation methods.\n *\n * Extends PointData to add operations for copying, comparison and setting values.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface PointLike extends PointData {\n\t/**\n\t * Copies x and y from the given point\n\t * @param {PointData} p - The point to copy from\n\t * @returns {this} Returns itself.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcopyFrom: (p: PointData) => this;\n\t/**\n\t * Copies x and y into the given point\n\t * @param {PointLike} p - The point to copy.\n\t * @returns {PointLike} Given point with values updated\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcopyTo: <T extends PointLike>(p: T) => T;\n\t/**\n\t * Returns true if the given point is equal to this point\n\t * @param {PointData} p - The point to check\n\t * @returns {boolean} Whether the given point equal to this point\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tequals: (p: PointData) => boolean;\n\t/**\n\t * Sets the point to a new x and y position.\n\t * If y is omitted, both x and y will be set to x.\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=x] - position of the point on the y axis\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tset: (x?: number, y?: number) => void;\n}\nexport interface Point extends PixiMixins.Point {\n}\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class Point implements PointLike {\n\t/**\n\t * Position of the point on the x axis\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tx: number;\n\t/**\n\t * Position of the point on the y axis\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ty: number;\n\t/**\n\t * Creates a new `Point`\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=0] - position of the point on the y axis\n\t */\n\tconstructor(x?: number, y?: number);\n\t/**\n\t * Creates a clone of this point, which is a new instance with the same `x` and `y` values.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Creates new Point instance\n\t * - Deep copies x and y values\n\t * - Independent from original\n\t * - Useful for preserving values\n\t * @returns A clone of this point\n\t */\n\tclone(): Point;\n\t/**\n\t * Copies x and y from the given point into this point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to copy from\n\t * @returns The point instance itself\n\t */\n\tcopyFrom(p: PointData): this;\n\t/**\n\t * Copies this point's x and y into the given point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to copy to. Can be any type that is or extends `PointLike`\n\t * @returns The point (`p`) with values updated\n\t */\n\tcopyTo<T extends PointLike>(p: T): T;\n\t/**\n\t * Checks if another point is equal to this point.\n\t *\n\t * Compares x and y values using strict equality.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to check\n\t * @returns `true` if both `x` and `y` are equal\n\t */\n\tequals(p: PointData): boolean;\n\t/**\n\t * Sets the point to a new x and y position.\n\t *\n\t * If y is omitted, both x and y will be set to x.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - Position on the x axis\n\t * @param y - Position on the y axis, defaults to x\n\t * @returns The point instance itself\n\t */\n\tset(x?: number, y?: number): this;\n\ttoString(): string;\n\t/**\n\t * A static Point object with `x` and `y` values of `0`.\n\t *\n\t * This shared instance is reset to zero values when accessed.\n\t *\n\t * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A fresh zeroed point for temporary use\n\t */\n\tstatic get shared(): Point;\n}\n/**\n * A fast matrix for 2D transformations.\n * Represents a 3x3 transformation matrix:\n *\n *",
      "language": "unknown"
    },
    {
      "code": "* @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Used for transform hierarchies\n * - Supports scale, rotation, position\n * - Can be concatenated with append/prepend\n * - Efficient for batched transformations\n */\nexport declare class Matrix {\n\t/**\n\t * Scale on the x axis.\n\t * @default 1\n\t */\n\ta: number;\n\t/**\n\t * Shear on the y axis.\n\t * @default 0\n\t */\n\tb: number;\n\t/**\n\t * Shear on the x axis.\n\t * @default 0\n\t */\n\tc: number;\n\t/**\n\t * Scale on the y axis.\n\t * @default 1\n\t */\n\td: number;\n\t/**\n\t * Translation on the x axis.\n\t * @default 0\n\t */\n\ttx: number;\n\t/**\n\t * Translation on the y axis.\n\t * @default 0\n\t */\n\tty: number;\n\t/**\n\t * Array representation of the matrix.\n\t * Only populated when `toArray()` is called.\n\t * @default null\n\t */\n\tarray: Float32Array | null;\n\t/**\n\t * @param a - x scale\n\t * @param b - y skew\n\t * @param c - x skew\n\t * @param d - y scale\n\t * @param tx - x translation\n\t * @param ty - y translation\n\t */\n\tconstructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);\n\t/**\n\t * Creates a Matrix object based on the given array.\n\t * Populates matrix components from a flat array in column-major order.\n\t *\n\t * > [!NOTE] Array mapping order:\n\t * >",
      "language": "unknown"
    },
    {
      "code": "* @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param array - The array to populate the matrix from\n\t */\n\tfromArray(array: number[]): void;\n\t/**\n\t * Sets the matrix properties directly.\n\t * All matrix components can be set in one call.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param a - Scale on x axis\n\t * @param b - Shear on y axis\n\t * @param c - Shear on x axis\n\t * @param d - Scale on y axis\n\t * @param tx - Translation on x axis\n\t * @param ty - Translation on y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tset(a: number, b: number, c: number, d: number, tx: number, ty: number): this;\n\t/**\n\t * Creates an array from the current Matrix object.\n\t *\n\t * > [!NOTE] The array format is:\n\t * >",
      "language": "unknown"
    },
    {
      "code": "* @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param transpose - Whether to transpose the matrix\n\t * @param out - Optional Float32Array to store the result\n\t * @returns The array containing the matrix values\n\t */\n\ttoArray(transpose?: boolean, out?: Float32Array): Float32Array;\n\t/**\n\t * Get a new position with the current transformation applied.\n\t *\n\t * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param pos - The origin point to transform\n\t * @param newPos - Optional point to store the result\n\t * @returns The transformed point\n\t */\n\tapply<P extends PointData = Point>(pos: PointData, newPos?: P): P;\n\t/**\n\t * Get a new position with the inverse of the current transformation applied.\n\t *\n\t * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param pos - The origin point to inverse-transform\n\t * @param newPos - Optional point to store the result\n\t * @returns The inverse-transformed point\n\t */\n\tapplyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P;\n\t/**\n\t * Translates the matrix on the x and y axes.\n\t * Adds to the position values while preserving scale, rotation and skew.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - How much to translate on the x axis\n\t * @param y - How much to translate on the y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\ttranslate(x: number, y: number): this;\n\t/**\n\t * Applies a scale transformation to the matrix.\n\t * Multiplies the scale values with existing matrix components.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The amount to scale horizontally\n\t * @param y - The amount to scale vertically\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tscale(x: number, y: number): this;\n\t/**\n\t * Applies a rotation transformation to the matrix.\n\t *\n\t * Rotates around the origin (0,0) by the given angle in radians.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Rotates around origin point (0,0)\n\t * - Affects position if translation was set\n\t * - Uses counter-clockwise rotation\n\t * - Order of operations matters when chaining\n\t * @param angle - The angle in radians\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\trotate(angle: number): this;\n\t/**\n\t * Appends the given Matrix to this Matrix.\n\t * Combines two matrices by multiplying them together: this = this * matrix\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Order matters: A.append(B) !== B.append(A)\n\t * - Modifies current matrix\n\t * - Preserves transformation order\n\t * - Commonly used for combining transforms\n\t * @param matrix - The matrix to append\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tappend(matrix: Matrix): this;\n\t/**\n\t * Appends two matrices and sets the result to this matrix.\n\t * Performs matrix multiplication: this = A * B\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Order matters: A * B !== B * A\n\t * - Creates a new transformation from two others\n\t * - More efficient than append() for multiple operations\n\t * - Does not modify input matrices\n\t * @param a - The first matrix to multiply\n\t * @param b - The second matrix to multiply\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tappendFrom(a: Matrix, b: Matrix): this;\n\t/**\n\t * Sets the matrix based on all the available properties.\n\t * Combines position, scale, rotation, skew and pivot in a single operation.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Updates all matrix components at once\n\t * - More efficient than separate transform calls\n\t * - Uses radians for rotation and skew\n\t * - Pivot affects rotation center\n\t * @param x - Position on the x axis\n\t * @param y - Position on the y axis\n\t * @param pivotX - Pivot on the x axis\n\t * @param pivotY - Pivot on the y axis\n\t * @param scaleX - Scale on the x axis\n\t * @param scaleY - Scale on the y axis\n\t * @param rotation - Rotation in radians\n\t * @param skewX - Skew on the x axis\n\t * @param skewY - Skew on the y axis\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tsetTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number, scaleY: number, rotation: number, skewX: number, skewY: number): this;\n\t/**\n\t * Prepends the given Matrix to this Matrix.\n\t * Combines two matrices by multiplying them together: this = matrix * this\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Order matters: A.prepend(B) !== B.prepend(A)\n\t * - Modifies current matrix\n\t * - Reverses transformation order compared to append()\n\t * @param matrix - The matrix to prepend\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tprepend(matrix: Matrix): this;\n\t/**\n\t * Decomposes the matrix into its individual transform components.\n\t * Extracts position, scale, rotation and skew values from the matrix.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Handles combined transformations\n\t * - Accounts for pivot points\n\t * - Chooses between rotation/skew based on transform type\n\t * - Uses radians for rotation and skew\n\t * @param transform - The transform object to store the decomposed values\n\t * @returns The transform with the newly applied properties\n\t */\n\tdecompose(transform: TransformableObject): TransformableObject;\n\t/**\n\t * Inverts this matrix.\n\t * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Modifies the current matrix\n\t * - Useful for reversing transformations\n\t * - Cannot invert matrices with zero determinant\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tinvert(): this;\n\t/**\n\t * Checks if this matrix is an identity matrix.\n\t *\n\t * An identity matrix has no transformations applied (default state).\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Verifies a = 1, d = 1 (no scale)\n\t * - Verifies b = 0, c = 0 (no skew)\n\t * - Verifies tx = 0, ty = 0 (no translation)\n\t * @returns True if matrix has no transformations\n\t */\n\tisIdentity(): boolean;\n\t/**\n\t * Resets this Matrix to an identity (default) matrix.\n\t * Sets all components to their default values: scale=1, no skew, no translation.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Sets a=1, d=1 (default scale)\n\t * - Sets b=0, c=0 (no skew)\n\t * - Sets tx=0, ty=0 (no translation)\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tidentity(): this;\n\t/**\n\t * Creates a new Matrix object with the same values as this one.\n\t * @returns A copy of this matrix. Good for chaining method calls.\n\t */\n\tclone(): Matrix;\n\t/**\n\t * Creates a new Matrix object with the same values as this one.\n\t * @param matrix\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A copy of this matrix. Good for chaining method calls.\n\t */\n\tcopyTo(matrix: Matrix): Matrix;\n\t/**\n\t * Changes the values of the matrix to be the same as the ones in given matrix.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param matrix - The matrix to copy from\n\t * @returns This matrix. Good for chaining method calls.\n\t */\n\tcopyFrom(matrix: Matrix): this;\n\t/**\n\t * Checks if this matrix equals another matrix.\n\t * Compares all components for exact equality.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param matrix - The matrix to compare to\n\t * @returns True if matrices are identical\n\t */\n\tequals(matrix: Matrix): boolean;\n\ttoString(): string;\n\t/**\n\t * A default (identity) matrix with no transformations applied.\n\t *\n\t * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A read-only identity matrix\n\t */\n\tstatic get IDENTITY(): Readonly<Matrix>;\n\t/**\n\t * A static Matrix that can be used to avoid creating new objects.\n\t * Will always ensure the matrix is reset to identity when requested.\n\t *\n\t * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Always returns identity matrix\n\t * - Safe to modify temporarily\n\t * - Not safe to store references\n\t * - Useful for one-off calculations\n\t * @returns A fresh identity matrix for temporary use\n\t */\n\tstatic get shared(): Matrix;\n}\nexport interface ObservablePoint extends PixiMixins.ObservablePoint {\n}\n/**\n * Observer used to listen for observable point changes.\n * Provides callback mechanism for point value updates.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Used internally by ObservablePoint\n * - Triggered on x/y changes\n * - Can track multiple points\n * - Useful for change detection\n * @typeParam T - The type of point being observed\n */\nexport interface Observer<T> {\n\t/**\n\t * Callback to call when the point has updated.\n\t * Triggered whenever x or y coordinates change.\n\t * @param point - The point that was updated\n\t */\n\t_onUpdate: (point?: T) => void;\n}\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system.\n * Triggers a callback when its position changes.\n *\n * The x and y properties represent the position on the horizontal and vertical axes, respectively.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class ObservablePoint implements PointLike {\n\t/**\n\t * Creates a new `ObservablePoint`\n\t * @param observer - Observer to pass to listen for change events.\n\t * @param {number} [x=0] - position of the point on the x axis\n\t * @param {number} [y=0] - position of the point on the y axis\n\t */\n\tconstructor(observer: Observer<ObservablePoint>, x?: number, y?: number);\n\t/**\n\t * Creates a clone of this point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param observer - Optional observer to pass to the new observable point\n\t * @returns A copy of this observable point\n\t */\n\tclone(observer?: Observer<ObservablePoint>): ObservablePoint;\n\t/**\n\t * Sets the point to a new x and y position.\n\t *\n\t * If y is omitted, both x and y will be set to x.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - Position on the x axis\n\t * @param y - Position on the y axis, defaults to x\n\t * @returns The point instance itself\n\t */\n\tset(x?: number, y?: number): this;\n\t/**\n\t * Copies x and y from the given point into this point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to copy from\n\t * @returns The point instance itself\n\t */\n\tcopyFrom(p: PointData): this;\n\t/**\n\t * Copies this point's x and y into the given point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to copy to. Can be any type that is or extends `PointLike`\n\t * @returns The point (`p`) with values updated\n\t */\n\tcopyTo<T extends PointLike>(p: T): T;\n\t/**\n\t * Checks if another point is equal to this point.\n\t *\n\t * Compares x and y values using strict equality.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param p - The point to check\n\t * @returns `true` if both `x` and `y` are equal\n\t */\n\tequals(p: PointData): boolean;\n\ttoString(): string;\n\t/**\n\t * Position of the observable point on the x axis.\n\t * Triggers observer callback when value changes.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * Position of the observable point on the y axis.\n\t * Triggers observer callback when value changes.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\tget y(): number;\n\tset y(value: number);\n}\ndeclare function earcut(vertices: ArrayLike<number>, holes?: ArrayLike<number>, dimensions?: number): number[];\n/**\n * A simple axis-aligned bounding box (AABB) data structure used to define rectangular boundaries.\n * Provides a clearer alternative to array-based bounds representation [minX, minY, maxX, maxY].\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface BoundsData {\n\t/** The minimum X coordinate of the bounds */\n\tminX: number;\n\t/** The minimum Y coordinate of the bounds */\n\tminY: number;\n\t/** The maximum X coordinate of the bounds */\n\tmaxX: number;\n\t/** The maximum Y coordinate of the bounds */\n\tmaxY: number;\n}\n/**\n * A representation of an axis-aligned bounding box (AABB) used for efficient collision detection and culling.\n * Stores minimum and maximum coordinates to define a rectangular boundary.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class Bounds {\n\t/**\n\t * The minimum X coordinate of the bounds.\n\t * Represents the leftmost edge of the bounding box.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default Infinity\n\t */\n\tminX: number;\n\t/**\n\t * The minimum Y coordinate of the bounds.\n\t * Represents the topmost edge of the bounding box.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default Infinity\n\t */\n\tminY: number;\n\t/**\n\t * The maximum X coordinate of the bounds.\n\t * Represents the rightmost edge of the bounding box.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default -Infinity\n\t */\n\tmaxX: number;\n\t/**\n\t * The maximum Y coordinate of the bounds.\n\t * Represents the bottommost edge of the bounding box.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default -Infinity\n\t */\n\tmaxY: number;\n\t/**\n\t * Creates a new Bounds object.\n\t * @param minX - The minimum X coordinate of the bounds.\n\t * @param minY - The minimum Y coordinate of the bounds.\n\t * @param maxX - The maximum X coordinate of the bounds.\n\t * @param maxY - The maximum Y coordinate of the bounds.\n\t */\n\tconstructor(minX?: number, minY?: number, maxX?: number, maxY?: number);\n\t/**\n\t * Checks if bounds are empty, meaning either width or height is zero or negative.\n\t * Empty bounds occur when min values exceed max values on either axis.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns True if bounds are empty (have no area)\n\t */\n\tisEmpty(): boolean;\n\t/**\n\t * The bounding rectangle representation of these bounds.\n\t * Lazily creates and updates a Rectangle instance based on the current bounds.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget rectangle(): Rectangle;\n\t/**\n\t * Clears the bounds and resets all coordinates to their default values.\n\t * Resets the transformation matrix back to identity.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns This bounds object for chaining\n\t */\n\tclear(): this;\n\t/**\n\t * Sets the bounds directly using coordinate values.\n\t * Provides a way to set all bounds values at once.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x0 - Left X coordinate of frame\n\t * @param y0 - Top Y coordinate of frame\n\t * @param x1 - Right X coordinate of frame\n\t * @param y1 - Bottom Y coordinate of frame\n\t */\n\tset(x0: number, y0: number, x1: number, y1: number): void;\n\t/**\n\t * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n\t * Updates the bounds to encompass the new frame coordinates.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x0 - Left X coordinate of frame\n\t * @param y0 - Top Y coordinate of frame\n\t * @param x1 - Right X coordinate of frame\n\t * @param y1 - Bottom Y coordinate of frame\n\t * @param matrix - Optional transformation matrix\n\t */\n\taddFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void;\n\t/**\n\t * Adds a rectangle to the bounds, optionally transformed by a matrix.\n\t * Updates the bounds to encompass the given rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rect - The rectangle to be added\n\t * @param matrix - Optional transformation matrix\n\t */\n\taddRect(rect: Rectangle, matrix?: Matrix): void;\n\t/**\n\t * Adds another bounds object to this one, optionally transformed by a matrix.\n\t * Expands the bounds to include the given bounds' area.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param bounds - The bounds to be added\n\t * @param matrix - Optional transformation matrix\n\t */\n\taddBounds(bounds: BoundsData, matrix?: Matrix): void;\n\t/**\n\t * Adds other Bounds as a mask, creating an intersection of the two bounds.\n\t * Only keeps the overlapping region between current bounds and mask bounds.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param mask - The Bounds to use as a mask\n\t */\n\taddBoundsMask(mask: Bounds): void;\n\t/**\n\t * Applies a transformation matrix to the bounds, updating its coordinates.\n\t * Transforms all corners of the bounds using the given matrix.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param matrix - The matrix to apply to the bounds\n\t */\n\tapplyMatrix(matrix: Matrix): void;\n\t/**\n\t * Resizes the bounds object to fit within the given rectangle.\n\t * Clips the bounds if they extend beyond the rectangle's edges.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rect - The rectangle to fit within\n\t * @returns This bounds object for chaining\n\t */\n\tfit(rect: Rectangle): this;\n\t/**\n\t * Resizes the bounds object to include the given bounds.\n\t * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param left - The left value of the bounds\n\t * @param right - The right value of the bounds\n\t * @param top - The top value of the bounds\n\t * @param bottom - The bottom value of the bounds\n\t * @returns This bounds object for chaining\n\t */\n\tfitBounds(left: number, right: number, top: number, bottom: number): this;\n\t/**\n\t * Pads bounds object, making it grow in all directions.\n\t * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param paddingX - The horizontal padding amount\n\t * @param paddingY - The vertical padding amount\n\t * @returns This bounds object for chaining\n\t */\n\tpad(paddingX: number, paddingY?: number): this;\n\t/**\n\t * Ceils the bounds by rounding up max values and rounding down min values.\n\t * Useful for pixel-perfect calculations and avoiding fractional pixels.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns This bounds object for chaining\n\t */\n\tceil(): this;\n\t/**\n\t * Creates a new Bounds instance with the same values.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A new Bounds instance with the same values\n\t */\n\tclone(): Bounds;\n\t/**\n\t * Scales the bounds by the given values, adjusting all edges proportionally.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The X value to scale by\n\t * @param y - The Y value to scale by (defaults to x)\n\t * @returns This bounds object for chaining\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * The x position of the bounds in local space.\n\t * Setting this value will move the bounds while maintaining its width.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget x(): number;\n\tset x(value: number);\n\t/**\n\t * The y position of the bounds in local space.\n\t * Setting this value will move the bounds while maintaining its height.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget y(): number;\n\tset y(value: number);\n\t/**\n\t * The width value of the bounds.\n\t * Represents the distance between minX and maxX coordinates.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget width(): number;\n\tset width(value: number);\n\t/**\n\t * The height value of the bounds.\n\t * Represents the distance between minY and maxY coordinates.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget height(): number;\n\tset height(value: number);\n\t/**\n\t * The left edge coordinate of the bounds.\n\t * Alias for minX.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget left(): number;\n\t/**\n\t * The right edge coordinate of the bounds.\n\t * Alias for maxX.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget right(): number;\n\t/**\n\t * The top edge coordinate of the bounds.\n\t * Alias for minY.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget top(): number;\n\t/**\n\t * The bottom edge coordinate of the bounds.\n\t * Alias for maxY.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget bottom(): number;\n\t/**\n\t * Whether the bounds has positive width and height.\n\t * Checks if both dimensions are greater than zero.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget isPositive(): boolean;\n\t/**\n\t * Whether the bounds has valid coordinates.\n\t * Checks if the bounds has been initialized with real values.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget isValid(): boolean;\n\t/**\n\t * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n\t * Used for efficiently updating bounds from raw vertex data.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param vertexData - The array of vertices to add\n\t * @param beginOffset - Starting index in the vertex array\n\t * @param endOffset - Ending index in the vertex array (excluded)\n\t * @param matrix - Optional transformation matrix\n\t */\n\taddVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void;\n\t/**\n\t * Checks if a point is contained within the bounds.\n\t * Returns true if the point's coordinates fall within the bounds' area.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - x coordinate to check\n\t * @param y - y coordinate to check\n\t * @returns True if the point is inside the bounds\n\t */\n\tcontainsPoint(x: number, y: number): boolean;\n\t/**\n\t * Returns a string representation of the bounds.\n\t * Useful for debugging and logging bounds information.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A string describing the bounds\n\t */\n\ttoString(): string;\n\t/**\n\t * Copies the bounds from another bounds object.\n\t * Useful for reusing bounds objects and avoiding allocations.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param bounds - The bounds to copy from\n\t * @returns This bounds object for chaining\n\t */\n\tcopyFrom(bounds: Bounds): this;\n}\n/**\n * Two Pi.\n * @type {number}\n */\nexport declare const PI_2: number;\n/**\n * Conversion factor for converting radians to degrees.\n * @type {number} RAD_TO_DEG\n */\nexport declare const RAD_TO_DEG: number;\n/**\n * Conversion factor for converting degrees to radians.\n * @type {number}\n */\nexport declare const DEG_TO_RAD: number;\nexport interface Rectangle extends PixiMixins.Rectangle {\n}\n/**\n * The `Rectangle` object represents a rectangular area defined by its position and dimensions.\n * Used for hit testing, bounds calculation, and general geometric operations.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Position defined by top-left corner (x,y)\n * - Dimensions defined by width and height\n * - Supports point and rectangle containment\n * - Common in UI and layout calculations\n */\nexport declare class Rectangle implements ShapePrimitive {\n\t/**\n\t * The type of the object, mainly used to avoid `instanceof` checks\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 'rectangle'\n\t */\n\treadonly type: SHAPE_PRIMITIVE;\n\t/**\n\t * The X coordinate of the upper-left corner of the rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\tx: number;\n\t/**\n\t * The Y coordinate of the upper-left corner of the rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\ty: number;\n\t/**\n\t * The overall width of this rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\twidth: number;\n\t/**\n\t * The overall height of this rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 0\n\t */\n\theight: number;\n\t/**\n\t * @param x - The X coordinate of the upper-left corner of the rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rectangle\n\t * @param width - The overall width of the rectangle\n\t * @param height - The overall height of the rectangle\n\t */\n\tconstructor(x?: string | number, y?: string | number, width?: string | number, height?: string | number);\n\t/**\n\t * Returns the left edge (x-coordinate) of the rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The x-coordinate of the left edge\n\t */\n\tget left(): number;\n\t/**\n\t * Returns the right edge (x + width) of the rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The x-coordinate of the right edge\n\t */\n\tget right(): number;\n\t/**\n\t * Returns the top edge (y-coordinate) of the rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The y-coordinate of the top edge\n\t */\n\tget top(): number;\n\t/**\n\t * Returns the bottom edge (y + height) of the rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The y-coordinate of the bottom edge\n\t */\n\tget bottom(): number;\n\t/**\n\t * Determines whether the Rectangle is empty (has no area).\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns True if the rectangle has no area\n\t */\n\tisEmpty(): boolean;\n\t/**\n\t * A constant empty rectangle. This is a new object every time the property is accessed.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A new empty rectangle instance\n\t */\n\tstatic get EMPTY(): Rectangle;\n\t/**\n\t * Creates a clone of this Rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns A copy of the rectangle\n\t */\n\tclone(): Rectangle;\n\t/**\n\t * Converts a Bounds object to a Rectangle object.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param bounds - The bounds to copy and convert to a rectangle\n\t * @returns Returns itself\n\t */\n\tcopyFromBounds(bounds: Bounds): this;\n\t/**\n\t * Copies another rectangle to this one.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rectangle - The rectangle to copy from\n\t * @returns Returns itself\n\t */\n\tcopyFrom(rectangle: Rectangle): Rectangle;\n\t/**\n\t * Copies this rectangle to another one.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rectangle - The rectangle to copy to\n\t * @returns Returns given parameter\n\t */\n\tcopyTo(rectangle: Rectangle): Rectangle;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this Rectangle\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @returns Whether the x/y coordinates are within this Rectangle\n\t */\n\tcontains(x: number, y: number): boolean;\n\t/**\n\t * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The X coordinate of the point to test\n\t * @param y - The Y coordinate of the point to test\n\t * @param strokeWidth - The width of the line to check\n\t * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n\t * @returns Whether the x/y coordinates are within this rectangle's stroke\n\t */\n\tstrokeContains(x: number, y: number, strokeWidth: number, alignment?: number): boolean;\n\t/**\n\t * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n\t * Returns true only if the area of the intersection is >0, this means that Rectangles\n\t * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n\t * (width or height equal to zero) can't intersect any other rectangle.\n\t * @param {Rectangle} other - The Rectangle to intersect with `this`.\n\t * @param {Matrix} transform - The transformation matrix of `other`.\n\t * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n\t */\n\t/**\n\t * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n\t *\n\t * Returns true only if the area of the intersection is greater than 0.\n\t * This means that rectangles sharing only a side are not considered intersecting.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Returns true only if intersection area is > 0\n\t * - Rectangles sharing only a side are not intersecting\n\t * - Zero-area rectangles cannot intersect anything\n\t * - Supports optional transformation matrix\n\t * @param other - The Rectangle to intersect with `this`\n\t * @param transform - Optional transformation matrix of `other`\n\t * @returns True if the transformed `other` Rectangle intersects with `this`\n\t */\n\tintersects(other: Rectangle, transform?: Matrix): boolean;\n\t/**\n\t * Pads the rectangle making it grow in all directions.\n\t *\n\t * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Adjusts x/y by subtracting padding\n\t * - Increases width/height by padding * 2\n\t * - Common in UI layout calculations\n\t * - Chainable with other methods\n\t * @param paddingX - The horizontal padding amount\n\t * @param paddingY - The vertical padding amount\n\t * @returns Returns itself\n\t */\n\tpad(paddingX?: number, paddingY?: number): this;\n\t/**\n\t * Fits this rectangle around the passed one.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rectangle - The rectangle to fit around\n\t * @returns Returns itself\n\t */\n\tfit(rectangle: Rectangle): this;\n\t/**\n\t * Enlarges rectangle so that its corners lie on a grid defined by resolution.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param resolution - The grid size to align to (1 = whole pixels)\n\t * @param eps - Small number to prevent floating point errors\n\t * @returns Returns itself\n\t */\n\tceil(resolution?: number, eps?: number): this;\n\t/**\n\t * Scales the rectangle's dimensions and position by the specified factors.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The factor by which to scale the horizontal properties (x, width).\n\t * @param y - The factor by which to scale the vertical properties (y, height).\n\t * @returns Returns itself\n\t */\n\tscale(x: number, y?: number): this;\n\t/**\n\t * Enlarges this rectangle to include the passed rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rectangle - The rectangle to include\n\t * @returns Returns itself\n\t */\n\tenlarge(rectangle: Rectangle): this;\n\t/**\n\t * Returns the framing rectangle of the rectangle as a Rectangle object\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param out - Optional rectangle to store the result\n\t * @returns The framing rectangle\n\t */\n\tgetBounds(out?: Rectangle): Rectangle;\n\t/**\n\t * Determines whether another Rectangle is fully contained within this Rectangle.\n\t *\n\t * Rectangles that occupy the same space are considered to be containing each other.\n\t *\n\t * Rectangles without area (width or height equal to zero) can't contain anything,\n\t * not even other arealess rectangles.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param other - The Rectangle to check for containment\n\t * @returns True if other is fully contained within this Rectangle\n\t */\n\tcontainsRect(other: Rectangle): boolean;\n\t/**\n\t * Sets the position and dimensions of the rectangle.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The X coordinate of the upper-left corner of the rectangle\n\t * @param y - The Y coordinate of the upper-left corner of the rectangle\n\t * @param width - The overall width of the rectangle\n\t * @param height - The overall height of the rectangle\n\t * @returns Returns itself for method chaining\n\t */\n\tset(x: number, y: number, width: number, height: number): this;\n\ttoString(): string;\n}\n/**\n * Base options for destroying display objects.\n * Controls how deep the destruction process should go through the display tree.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface BaseDestroyOptions {\n\t/**\n\t * Whether to destroy children recursively.\n\t * When true, runs destroy() on all children in the display tree.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tchildren?: boolean;\n}\n/**\n * Options when destroying textures through `.destroy()` calls.\n * Controls how thoroughly textures and their sources are cleaned up.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface TextureDestroyOptions {\n\t/**\n\t * Whether to destroy the texture for the display object.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttexture?: boolean;\n\t/**\n\t * Whether to destroy the underlying texture source.\n\t * Use carefully with shared texture sources.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttextureSource?: boolean;\n}\n/**\n * Options when destroying a graphics context.\n * Controls the cleanup of graphics-specific resources.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface ContextDestroyOptions {\n\t/**\n\t * Whether to destroy the graphics context associated with the graphics object.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcontext?: boolean;\n}\n/**\n * Options when destroying a text object. Controls whether associated text styles\n * should be cleaned up along with the text object itself.\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface TextDestroyOptions {\n\t/**\n\t * Whether to destroy the text style object along with the text.\n\t * Use carefully with shared styles.\n\t * @default false\n\t */\n\tstyle?: boolean;\n}\n/**\n * Options for destroying a container and its resources.\n * Combines all destroy options into a single configuration object.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport type DestroyOptions = TypeOrBool<BaseDestroyOptions & ContextDestroyOptions & TextureDestroyOptions & TextDestroyOptions>;\n/**\n * Global registration system for all PixiJS extensions. Provides a centralized way to add, remove,\n * and manage functionality across the engine.\n *\n * Features:\n * - Register custom extensions and plugins\n * - Handle multiple extension types\n * - Priority-based ordering\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Extensions must have a type from {@link ExtensionType}\n * - Can be registered before or after their handlers\n * - Supports priority-based ordering\n * - Automatically normalizes extension formats\n */\nexport declare const extensions: {\n\t/**\n\t * Remove extensions from PixiJS.\n\t * @param extensions - Extensions to be removed. Can be:\n\t * - Extension class with static `extension` property\n\t * - Extension format object with `type` and `ref`\n\t * - Multiple extensions as separate arguments\n\t * @returns {extensions} this for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tremove(...extensions: Array<ExtensionFormat | any>): any;\n\t/**\n\t * Register new extensions with PixiJS. Extensions can be registered in multiple formats:\n\t * - As a class with a static `extension` property\n\t * - As an extension format object\n\t * - As multiple extensions passed as separate arguments\n\t * @param extensions - Extensions to add to PixiJS. Each can be:\n\t * - A class with static `extension` property\n\t * - An extension format object with `type` and `ref`\n\t * - Multiple extensions as separate arguments\n\t * @returns This extensions instance for chaining\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tadd(...extensions: Array<ExtensionFormat | any>): any;\n\t/**\n\t * Mixin the source object(s) properties into the target class's prototype.\n\t * Copies all property descriptors from source objects to the target's prototype.\n\t * @param Target - The target class to mix properties into\n\t * @param sources - One or more source objects containing properties to mix in\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Copies all properties including getters/setters\n\t * - Does not modify source objects\n\t * - Preserves property descriptors\n\t */\n\tmixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][]): void;\n};\n/**\n * The wrap modes that are supported by pixi.\n *\n * The wrap mode affects the default wrapping mode of future operations.\n * - `clamp-to-edge` is the default mode, which clamps the texture coordinates to the edge of the texture.\n * - `repeat` allows the texture to repeat in both u and v directions.\n * - `mirror-repeat` allows the texture to repeat in both u and v directions, but mirrors the texture on every other repeat.\n */\nexport type WRAP_MODE = \"clamp-to-edge\" | \"repeat\" | \"mirror-repeat\";\n/**\n * The scale modes that are supported by pixi.\n *\n * The scale mode affects the default scaling mode of future operations.\n * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n *\n * - `nearest` is a pixelating scaling mode, which does not interpolate pixels.\n * - `linear` is a smooth scaling mode, which interpolates pixels for smoother results.\n */\nexport type SCALE_MODE = \"nearest\" | \"linear\";\n/**\n * The options that can be passed to a new Texture\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource> {\n\t/** the underlying texture data that this texture will use  */\n\tsource?: TextureSourceType;\n\t/** optional label, for debugging */\n\tlabel?: string;\n\t/** The rectangle frame of the texture to show */\n\tframe?: Rectangle;\n\t/** The area of original texture */\n\torig?: Rectangle;\n\t/** Trimmed rectangle of original texture */\n\ttrim?: Rectangle;\n\t/** Default anchor point used for sprite placement / rotation */\n\tdefaultAnchor?: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\t/** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n\tdefaultBorders?: TextureBorders;\n\t/** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n\trotate?: number;\n\t/**\n\t * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n\t * This is false by default as it improves performance. Generally, it's recommended to create new\n\t * textures and swap those rather than modifying an existing texture's properties unless you are\n\t * working with a dynamic frames.\n\t * Not setting this to true when modifying the texture can lead to visual artifacts.\n\t *\n\t * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n\t * `sprite.onViewUpdate()`.\n\t */\n\tdynamic?: boolean;\n}\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n */\nexport declare class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n\tupdate: Texture;\n\tdestroy: Texture;\n}> implements BindableTexture {\n\t/**\n\t * Helper function that creates a returns Texture based on the source you provide.\n\t * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n\t * @param id - String or Source to create texture from\n\t * @param skipCache - Skip adding the texture to the cache\n\t * @returns The texture based on the Id provided\n\t */\n\tstatic from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\t/** label used for debugging */\n\tlabel?: string;\n\t/** unique id for this texture */\n\treadonly uid: number;\n\t/**\n\t * Has the texture been destroyed?\n\t */\n\tdestroyed: boolean;\n\t/**\n\t * Indicates whether the texture is rotated inside the atlas\n\t * set to 2 to compensate for texture packer rotation\n\t * set to 6 to compensate for spine packer rotation\n\t * can be used to rotate or mirror sprites\n\t * See {@link groupD8} for explanation\n\t */\n\treadonly rotate: number;\n\t/** A uvs object based on the given frame and the texture source */\n\treadonly uvs: UVs;\n\t/**\n\t * Anchor point that is used as default if sprite is created with this texture.\n\t * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n\t * @default {0,0}\n\t */\n\treadonly defaultAnchor?: {\n\t\tx: number;\n\t\ty: number;\n\t};\n\t/**\n\t * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n\t * @since 7.2.0\n\t */\n\treadonly defaultBorders?: TextureBorders;\n\t/**\n\t * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n\t * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n\t */\n\treadonly frame: Rectangle;\n\t/** This is the area of original texture, before it was put in atlas. */\n\treadonly orig: Rectangle;\n\t/**\n\t * This is the trimmed area of original texture, before it was put in atlas\n\t * Please call `updateUvs()` after you change coordinates of `trim` manually.\n\t */\n\treadonly trim: Rectangle;\n\t/**\n\t * Does this Texture have any frame data assigned to it?\n\t *\n\t * This mode is enabled automatically if no frame was passed inside constructor.\n\t *\n\t * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n\t *\n\t * Beware, after loading or resize of baseTexture event can fired two times!\n\t * If you want more control, subscribe on baseTexture itself.\n\t * @example\n\t * texture.on('update', () => {});\n\t */\n\tnoFrame: boolean;\n\t/**\n\t * Set to true if you plan on modifying the uvs of this texture.\n\t * When this is the case, sprites and other objects using the texture will\n\t * make sure to listen for changes to the uvs and update their vertices accordingly.\n\t */\n\tdynamic: boolean;\n\t/** is it a texture? yes! used for type checking */\n\treadonly isTexture = true;\n\t/**\n\t * @param {TextureOptions} options - Options for the texture\n\t */\n\tconstructor({ source, label, frame, orig, trim, defaultAnchor, defaultBorders, rotate, dynamic }?: TextureOptions<TextureSourceType>);\n\tset source(value: TextureSourceType);\n\t/** the underlying source of the texture (equivalent of baseTexture in v7) */\n\tget source(): TextureSourceType;\n\t/** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n\tget textureMatrix(): TextureMatrix;\n\t/** The width of the Texture in pixels. */\n\tget width(): number;\n\t/** The height of the Texture in pixels. */\n\tget height(): number;\n\t/** Call this function when you have modified the frame of this texture. */\n\tupdateUvs(): void;\n\t/**\n\t * Destroys this texture\n\t * @param destroySource - Destroy the source when the texture is destroyed.\n\t */\n\tdestroy(destroySource?: boolean): void;\n\t/**\n\t * Call this if you have modified the `texture outside` of the constructor.\n\t *\n\t * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n\t */\n\tupdate(): void;\n\t/** @deprecated since 8.0.0 */\n\tget baseTexture(): TextureSource;\n\t/** an Empty Texture used internally by the engine */\n\tstatic EMPTY: Texture;\n\t/** a White texture used internally by the engine */\n\tstatic WHITE: Texture<BufferImageSource>;\n}\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n */\nexport declare class GenerateTextureSystem implements System {\n\tconstructor(renderer: Renderer);\n\t/**\n\t * Creates a texture from a display object that can be used for creating sprites and other textures.\n\t * This is particularly useful for optimizing performance when a complex container needs to be reused.\n\t * @param options - Generate texture options or a container to convert to texture\n\t * @returns A new RenderTexture containing the rendered display object\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tgenerateTexture(options: GenerateTextureOptions | Container): RenderTexture;\n\tdestroy(): void;\n}\n/**\n * Various blend modes supported by Pixi\n */\nexport type BLEND_MODES = \"inherit\" | \"normal\" | \"add\" | \"multiply\" | \"screen\" | \"darken\" | \"lighten\" | \"erase\" | \"color-dodge\" | \"color-burn\" | \"linear-burn\" | \"linear-dodge\" | \"linear-light\" | \"hard-light\" | \"soft-light\" | \"pin-light\" | \"difference\" | \"exclusion\" | \"overlay\" | \"saturation\" | \"color\" | \"luminosity\" | \"normal-npm\" | \"add-npm\" | \"screen-npm\" | \"none\" | \"subtract\" | \"divide\" | \"vivid-light\" | \"hard-mix\" | \"negation\" | \"min\" | \"max\";\ninterface ShaderBase {\n\t/** The WebGL program used by the WebGL renderer. */\n\tglProgram?: GlProgram;\n\t/** The WebGPU program used by the WebGPU renderer. */\n\tgpuProgram?: GpuProgram;\n\t/**\n\t * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n\t * 0b00 - not compatible with either\n\t * 0b01 - compatible with WebGL\n\t * 0b10 - compatible with WebGPU\n\t * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n\t */\n\tcompatibleRenderers?: number;\n}\ninterface ShaderWithResourcesDescriptor {\n\t/**\n\t * A key value of uniform resources used by the shader.\n\t * Under the hood pixi will look at the provided shaders and figure out where\n\t * the resources are mapped. Its up to you to make sure the resource key\n\t * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n\t */\n\tresources?: Record<string, any>;\n}\ntype GlShaderFromWith = {\n\tgpu?: GpuProgramOptions;\n\tgl: GlProgramOptions;\n};\ntype GpuShaderFromWith = {\n\tgpu: GpuProgramOptions;\n\tgl?: GlProgramOptions;\n};\n/**\n * Defines a size with a width and a height.\n */\nexport interface Size {\n\t/** The width. */\n\twidth: number;\n\t/** The height. */\n\theight: number;\n}\ninterface LocalBoundsCacheData {\n\tdata: number[];\n\tindex: number;\n\tdidChange: boolean;\n\tlocalBounds: Bounds;\n}\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions {\n\t/**\n\t * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n\t * @default Texture.EMPTY\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttexture?: Texture;\n\t/**\n\t * The anchor point of the sprite (0-1 range).\n\t * Controls the origin point for rotation, scaling, and positioning.\n\t * Can be a number for uniform anchor or a PointData for separate x/y values.\n\t * @default 0\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tanchor?: PointData | number;\n\t/**\n\t * Whether or not to round the x/y position to whole pixels.\n\t * Useful for crisp pixel art style rendering.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\troundPixels?: boolean;\n}\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {\n}\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class Sprite extends ViewContainer<BatchableSprite> {\n\t/**\n\t * Creates a new sprite based on a source texture, image, video, or canvas element.\n\t * This is a convenience method that automatically creates and manages textures.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param source - The source to create the sprite from. Can be a path to an image, a texture,\n\t * or any valid texture source (canvas, video, etc.)\n\t * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n\t * @returns A new sprite based on the source\n\t */\n\tstatic from(source: Texture | TextureSourceLike, skipCache?: boolean): Sprite;\n\t/**\n\t * @param options - The options for creating the sprite.\n\t */\n\tconstructor(options?: SpriteOptions | Texture);\n\tset texture(value: Texture);\n\t/**\n\t * The texture that is displayed by the sprite. When changed, automatically updates\n\t * the sprite dimensions and manages texture event listeners.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget texture(): Texture;\n\t/**\n\t * The bounds of the sprite, taking into account the texture's trim area.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set width directly\n\t * sprite.width = 200;\n\t * console.log(sprite.scale.x); // Scale adjusted to match width\n\t *\n\t * // Set width while preserving aspect ratio\n\t * const ratio = sprite.height / sprite.width;\n\t * sprite.width = 300;\n\t * sprite.height = 300 * ratio;\n\t *\n\t * // For better performance when setting both width and height\n\t * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n\t *\n\t * // Reset to original texture size\n\t * sprite.width = sprite.texture.orig.width;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set height directly\n\t * sprite.height = 150;\n\t * console.log(sprite.scale.y); // Scale adjusted to match height\n\t *\n\t * // Set height while preserving aspect ratio\n\t * const ratio = sprite.width / sprite.height;\n\t * sprite.height = 200;\n\t * sprite.width = 200 * ratio;\n\t *\n\t * // For better performance when setting both width and height\n\t * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n\t *\n\t * // Reset to original texture size\n\t * sprite.height = sprite.texture.orig.height;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic size retrieval\n\t * const sprite = new Sprite(Texture.from('sprite.png'));\n\t * const size = sprite.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * sprite.getSize(reuseSize);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic size setting\n\t * const sprite = new Sprite(Texture.from('sprite.png'));\n\t * sprite.setSize(100, 200); // Width: 100, Height: 200\n\t *\n\t * // Set uniform size\n\t * sprite.setSize(100); // Sets both width and height to 100\n\t *\n\t * // Set size with object\n\t * sprite.setSize({\n\t *     width: 200,\n\t *     height: 300\n\t * });\n\t *\n\t * // Reset to texture size\n\t * sprite.setSize(\n\t *     sprite.texture.orig.width,\n\t *     sprite.texture.orig.height\n\t * );\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n *",
      "language": "ts"
    },
    {
      "code": "* // Customize default options\n\t * ExtractSystem.defaultImageOptions.format = 'webp';\n\t * ExtractSystem.defaultImageOptions.quality = 0.8;\n\t *\n\t * // Use defaults\n\t * const image = await renderer.extract.image(sprite);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic usage with a sprite\n\t * const sprite = new Sprite(texture);\n\t * const image = await renderer.extract.image(sprite);\n\t * document.body.appendChild(image);\n\t *\n\t * // Advanced usage with options\n\t * const image = await renderer.extract.image({\n\t *     target: container,\n\t *     format: 'webp',\n\t *     quality: 0.8,\n\t *     frame: new Rectangle(0, 0, 100, 100),\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000',\n\t *     antialias: true\n\t * });\n\t *\n\t * // Extract directly from a texture\n\t * const texture = Texture.from('myTexture.png');\n\t * const image = await renderer.extract.image(texture);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic usage with a sprite\n\t * const sprite = new Sprite(texture);\n\t * const base64 = await renderer.extract.base64(sprite);\n\t * console.log(base64); // data:image/png;base64,...\n\t *\n\t * // Advanced usage with options\n\t * const base64 = await renderer.extract.base64({\n\t *     target: container,\n\t *     format: 'webp',\n\t *     quality: 0.8,\n\t *     frame: new Rectangle(0, 0, 100, 100),\n\t *     resolution: 2\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic canvas extraction from a sprite\n\t * const sprite = new Sprite(texture);\n\t * const canvas = renderer.extract.canvas(sprite);\n\t * document.body.appendChild(canvas);\n\t *\n\t * // Extract with custom region\n\t * const canvas = renderer.extract.canvas({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const canvas = renderer.extract.canvas({\n\t *     target: sprite,\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Extract directly from a texture\n\t * const texture = Texture.from('myTexture.png');\n\t * const canvas = renderer.extract.canvas(texture);\n\t *\n\t * // Extract with anti-aliasing\n\t * const canvas = renderer.extract.canvas({\n\t *     target: graphics,\n\t *     antialias: true\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic pixel extraction\n\t * const sprite = new Sprite(texture);\n\t * const pixels = renderer.extract.pixels(sprite);\n\t * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n\t *\n\t * // Extract with custom region\n\t * const pixels = renderer.extract.pixels({\n\t *     target: sprite,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const pixels = renderer.extract.pixels({\n\t *     target: sprite,\n\t *     resolution: 2\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic texture extraction from a sprite\n\t * const sprite = new Sprite(texture);\n\t * const extractedTexture = renderer.extract.texture(sprite);\n\t *\n\t * // Extract with custom region\n\t * const regionTexture = renderer.extract.texture({\n\t *     target: container,\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Extract with high resolution\n\t * const hiResTexture = renderer.extract.texture({\n\t *     target: sprite,\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Create a new sprite from extracted texture\n\t * const newSprite = new Sprite(\n\t *     renderer.extract.texture({\n\t *         target: graphics,\n\t *         antialias: true\n\t *     })\n\t * );\n\t *\n\t * // Clean up when done\n\t * extractedTexture.destroy(true);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic download with default filename\n\t * const sprite = new Sprite(texture);\n\t * renderer.extract.download(sprite); // Downloads as 'image.png'\n\t *\n\t * // Download with custom filename\n\t * renderer.extract.download({\n\t *     target: sprite,\n\t *     filename: 'screenshot.png'\n\t * });\n\t *\n\t * // Download with custom region\n\t * renderer.extract.download({\n\t *     target: container,\n\t *     filename: 'region.png',\n\t *     frame: new Rectangle(0, 0, 100, 100)\n\t * });\n\t *\n\t * // Download with high resolution and background\n\t * renderer.extract.download({\n\t *     target: stage,\n\t *     filename: 'hd-screenshot.png',\n\t *     resolution: 2,\n\t *     clearColor: '#ff0000'\n\t * });\n\t *\n\t * // Download with anti-aliasing\n\t * renderer.extract.download({\n\t *     target: graphics,\n\t *     filename: 'smooth.png',\n\t *     antialias: true\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n *",
      "language": "ts"
    },
    {
      "code": "* import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n *",
      "language": "ts"
    },
    {
      "code": "* import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * // Initialize with common options\n * await app.init({\n *    // Rendering options\n *    width: 800,                    // Canvas width\n *    height: 600,                   // Canvas height\n *    backgroundColor: 0x1099bb,     // Background color\n *    antialias: true,              // Enable antialiasing\n *    resolution: window.devicePixelRatio, // Screen resolution\n *\n *    // Performance options\n *    autoStart: true,              // Auto-starts the render loop\n *    sharedTicker: true,           // Use shared ticker for better performance\n *\n *    // Automatic resize options\n *    resizeTo: window,             // Auto-resize to window\n *    autoDensity: true,           // Adjust for device pixel ratio\n *\n *    // Advanced options\n *    preference: 'webgl',         // Renderer preference ('webgl' or 'webgpu')\n *    powerPreference: 'high-performance' // GPU power preference\n * });\n *",
      "language": "js"
    },
    {
      "code": "* import { Assets, Application, Sprite } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n *\n * // Initialize with options\n * await app.init({\n *     width: 800,           // Canvas width\n *     height: 600,          // Canvas height\n *     backgroundColor: 0x1099bb, // Background color\n *     antialias: true,     // Enable antialiasing\n *     resolution: 1,       // Resolution / device pixel ratio\n *     preference: 'webgl', // or 'webgpu' // Renderer preference\n * });\n *\n * // Add the canvas to your webpage\n * document.body.appendChild(app.canvas);\n *\n * // Start adding content to your application\n * const texture - await Assets.load('your-image.png');\n * const sprite = new Sprite(texture);\n * app.stage.addChild(sprite);\n *",
      "language": "js"
    },
    {
      "code": "* // Create a sprite and add it to the stage\n\t * const sprite = Sprite.from('image.png');\n\t * app.stage.addChild(sprite);\n\t *\n\t * // Create a container for grouping objects\n\t * const container = new Container();\n\t * app.stage.addChild(container);\n\t *",
      "language": "js"
    },
    {
      "code": "* // Create a new application\n\t * const app = new Application();\n\t * await app.init({\n\t *     width: 800,\n\t *     height: 600,\n\t *     preference: 'webgl', // or 'webgpu'\n\t * });\n\t *\n\t * // Access renderer properties\n\t * console.log(app.renderer.width, app.renderer.height);\n\t *",
      "language": "js"
    },
    {
      "code": "* const app = new Application();\n\t *\n\t * // Initialize with custom options\n\t * await app.init({\n\t *     width: 800,\n\t *     height: 600,\n\t *     backgroundColor: 0x1099bb,\n\t *     preference: 'webgl', // or 'webgpu'\n\t * });\n\t *",
      "language": "js"
    },
    {
      "code": "* // Example 1: Default setup (TickerPlugin handles rendering)\n\t * const app = new Application();\n\t * await app.init();\n\t * // No need to call render() - TickerPlugin handles it\n\t *\n\t * // Example 2: Custom rendering loop (if TickerPlugin is disabled)\n\t * const app = new Application();\n\t * await app.init({ autoStart: false }); // Disable automatic rendering\n\t *\n\t * function animate() {\n\t *     app.render();\n\t *     requestAnimationFrame(animate);\n\t * }\n\t * animate();\n\t *",
      "language": "js"
    },
    {
      "code": "* // Create a new application\n\t * const app = new Application();\n\t * // Initialize the application\n\t * await app.init({...});\n\t * // Add canvas to the page\n\t * document.body.appendChild(app.canvas);\n\t *\n\t * // Access the canvas directly\n\t * console.log(app.canvas); // HTMLCanvasElement\n\t *",
      "language": "js"
    },
    {
      "code": "* // Use as filter area for a full-screen effect\n\t * const blurFilter = new BlurFilter();\n\t * sprite.filterArea = app.screen;\n\t *\n\t * // Use as hit area for screen-wide interaction\n\t * const screenSprite = new Sprite();\n\t * screenSprite.hitArea = app.screen;\n\t *\n\t * // Get screen dimensions\n\t * console.log(app.screen.width, app.screen.height);\n\t *",
      "language": "js"
    },
    {
      "code": "* // Basic cleanup\n\t * app.destroy();\n\t *\n\t * // Remove canvas and do complete cleanup\n\t * app.destroy(true, true);\n\t *\n\t * // Remove canvas with explicit options\n\t * app.destroy({ removeView: true }, true);\n\t *\n\t * // Detailed cleanup with specific options\n\t * app.destroy(\n\t *     { removeView: true },\n\t *     {\n\t *         children: true,\n\t *         texture: true,\n\t *         textureSource: true,\n\t *         context: true\n\t *     }\n\t * );\n\t *",
      "language": "js"
    },
    {
      "code": "* // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic layer with automatic sorting\n * const layer = new RenderLayer({\n *     sortableChildren: true\n * });\n *\n * // Layer with custom sort function\n * const customLayer = new RenderLayer({\n *     sortableChildren: true,\n *     sortFunction: (a, b) => {\n *         // Sort by y position\n *         return a.position.y - b.position.y;\n *     }\n * });\n *\n * // Add objects to layer while maintaining scene graph parent\n * const sprite = new Sprite(texture);\n * container.addChild(sprite);      // Add to scene graph\n * layer.attach(sprite);            // Add to render layer\n *\n * // Manual sorting when needed\n * const manualLayer = new RenderLayer({\n *     sortableChildren: false\n * });\n * manualLayer.attach(sprite1, sprite2);\n * manualLayer.sortRenderLayerChildren(); // Sort manually\n *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer({\n\t *     sortableChildren: true // Automatically sorts children by zIndex\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer({\n\t *     sortFunction: (a, b) => {\n\t *         // Sort by y position\n\t *         return a.position.y - b.position.y;\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n * app.stage.addChild(layer); // Insert the layer into the scene graph\n *",
      "language": "js"
    },
    {
      "code": "* const rect = new Graphics();\n * container.addChild(rect);    // Add to logical parent\n * layer.attach(rect);      // Control render order via the layer\n *",
      "language": "js"
    },
    {
      "code": "* layer.remove(rect); // Stop rendering rect via the layer\n *",
      "language": "js"
    },
    {
      "code": "* container.addChild(rect);    // Logical parent\n * layer.attach(rect);      // Explicitly reassign to the layer\n *",
      "language": "js"
    },
    {
      "code": "* const backgroundLayer = new RenderLayer();\n * const uiLayer = new RenderLayer();\n *\n * app.stage.addChild(backgroundLayer);\n * app.stage.addChild(world);\n * app.stage.addChild(uiLayer);\n *",
      "language": "js"
    },
    {
      "code": "* // Create a custom render layer with modified default options\n\t * RenderLayer.defaultOptions = {\n\t *     sortableChildren: true,\n\t *     sortFunction: (a, b) => a.y - b.y // Sort by vertical position\n\t * };\n\t *\n\t * // All new render layers will use these defaults\n\t * const layer1 = new RenderLayer();\n\t * // layer1 will have sortableChildren = true\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n\t * const sprite = new Sprite(texture);\n\t *\n\t * // Add sprite to scene graph for transforms\n\t * container.addChild(sprite);\n\t *\n\t * // Add to layer for render order control\n\t * layer.attach(sprite);\n\t * console.log(layer.renderLayerChildren.length); // 1\n\t *\n\t * // Access objects in the layer\n\t * layer.renderLayerChildren.forEach(child => {\n\t *     console.log('Layer child:', child);\n\t * });\n\t *\n\t * // Check if object is in layer\n\t * const isInLayer = layer.renderLayerChildren.includes(sprite);\n\t *\n\t * // Clear all objects from layer\n\t * layer.detachAll();\n\t * console.log(layer.renderLayerChildren.length); // 0\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n\t * const container = new Container();\n\t * const sprite1 = new Sprite(texture1);\n\t * const sprite2 = new Sprite(texture2);\n\t *\n\t * // Add sprites to scene graph for transforms\n\t * container.addChild(sprite1, sprite2);\n\t *\n\t * // Add sprites to layer for render order control\n\t * layer.attach(sprite1, sprite2);\n\t *\n\t * // Add single sprite with type checking\n\t * const typedSprite = layer.attach<Sprite>(new Sprite(texture3));\n\t * typedSprite.tint = 'red';\n\t *\n\t * // Automatically removes from previous layer if needed\n\t * const otherLayer = new RenderLayer();\n\t * otherLayer.attach(sprite1); // Removes from previous layer\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n\t * const container = new Container();\n\t * const sprite1 = new Sprite(texture1);\n\t * const sprite2 = new Sprite(texture2);\n\t *\n\t * // Add sprites to scene graph and layer\n\t * container.addChild(sprite1, sprite2);\n\t * layer.attach(sprite1, sprite2);\n\t *\n\t * // Remove single sprite from layer\n\t * layer.detach(sprite1);\n\t * // sprite1 is still child of container but not rendered in layer\n\t *\n\t * // Remove multiple sprites at once\n\t * const otherLayer = new RenderLayer();\n\t * otherLayer.attach(sprite3, sprite4);\n\t * otherLayer.detach(sprite3, sprite4);\n\t *\n\t * // Type-safe detachment\n\t * const typedSprite = layer.detach<Sprite>(spriteInLayer);\n\t * typedSprite.texture = newTexture; // TypeScript knows this is a Sprite\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n\t * const container = new Container();\n\t *\n\t * // Add multiple sprites to scene graph and layer\n\t * const sprites = [\n\t *     new Sprite(texture1),\n\t *     new Sprite(texture2),\n\t *     new Sprite(texture3)\n\t * ];\n\t *\n\t * container.addChild(...sprites);  // Add to scene graph\n\t * layer.attach(...sprites);       // Add to render layer\n\t *\n\t * // Later, remove all sprites from layer at once\n\t * layer.detachAll();\n\t * console.log(layer.renderLayerChildren.length); // 0\n\t * console.log(container.children.length);        // 3 (still in scene graph)\n\t *",
      "language": "ts"
    },
    {
      "code": "* const layer = new RenderLayer();\n\t *\n\t * // Add multiple sprites at different depths\n\t * const sprite1 = new Sprite(texture);\n\t * const sprite2 = new Sprite(texture);\n\t * const sprite3 = new Sprite(texture);\n\t *\n\t * sprite1.zIndex = 3;\n\t * sprite2.zIndex = 1;\n\t * sprite3.zIndex = 2;\n\t *\n\t * layer.attach(sprite1, sprite2, sprite3);\n\t *\n\t * // Manual sorting with default zIndex sort\n\t * layer.sortRenderLayerChildren();\n\t * // Order is now: sprite2 (1), sprite3 (2), sprite1 (3)\n\t *\n\t * // Custom sort by y position\n\t * layer.sortFunction = (a, b) => a.y - b.y;\n\t * layer.sortRenderLayerChildren();\n\t *\n\t * // Automatic sorting\n\t * layer.sortableChildren = true; // Will sort each render\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Container, Sprite } from 'pixi.js';\n *\n * // Setup container with event listeners\n * const container = new Container();\n *\n * // Listen for child additions\n * container.on('childAdded', (child, container, index) => {\n *     console.log(`Child added at index ${index}:`, child);\n * });\n *\n * // Listen for child removals\n * container.on('childRemoved', (child, container, index) => {\n *     console.log(`Child removed from index ${index}:`, child);\n * });\n *\n * // Listen for when container is added to parent\n * container.on('added', (parent) => {\n *     console.log('Added to parent:', parent);\n * });\n *\n * // Listen for when container is removed from parent\n * container.on('removed', (parent) => {\n *     console.log('Removed from parent:', parent);\n * });\n *\n * // Listen for container destruction\n * container.on('destroyed', (container) => {\n *     console.log('Container destroyed:', container);\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* const child = new Container();\n\t * child.on('added', (parent) => {\n\t *     console.log('Child added to parent:', parent.label);\n\t * });\n\t * parentContainer.addChild(child);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const parent = new Container();\n\t * parent.on('childAdded', (child, container, index) => {\n\t *     console.log(`New child at index ${index}:`, child);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const child = new Container();\n\t * child.on('removed', (oldParent) => {\n\t *     console.log('Child removed from parent:', oldParent.label);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const parent = new Container();\n\t * parent.on('childRemoved', (child, container, index) => {\n\t *     console.log(`Child removed from index ${index}:`, child);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container();\n\t * container.on('destroyed', (container) => {\n\t *     console.log('Container destroyed:', container.label);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n *",
      "language": "js"
    },
    {
      "code": "* // Basic blend modes\n\t * new Container({ blendMode: 'normal' }); // Default blending\n\t * new Container({ blendMode: 'add' });    // Additive blending\n\t * new Container({ blendMode: 'multiply' }); // Multiply colors\n\t * new Container({ blendMode: 'screen' }); // Screen blend\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ tint: 0xff0000 }); // Red tint\n\t * new Container({ tint: 'blue' }); // Blue tint\n\t * new Container({ tint: '#00ff00' }); // Green tint\n\t * new Container({ tint: 'rgb(0,0,255)' }); // Blue tint\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ alpha: 0.5 }); // 50% opacity\n\t * new Container({ alpha: 1 }); // Fully opaque\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ angle: 45 }); // Rotate 45 degrees\n\t * new Container({ angle: 90 }); // Rotate 90 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({\n\t *    children: [\n\t *        new Container(), // First child\n\t *        new Container(), // Second child\n\t *    ],\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ renderable: false }); // Will not be drawn, but transforms will update\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ rotation: Math.PI / 4 }); // Rotate 45 degrees\n\t * new Container({ rotation: Math.PI / 2 }); // Rotate 90 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ scale: new Point(2, 2) }); // Scale by 2x\n\t * new Container({ scale: 0.5 }); // Scale by 0.5x\n\t * new Container({ scale: { x: 1.5, y: 1.5 } }); // Scale by 1.5x\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ pivot: new Point(100, 200) }); // Set pivot to (100, 200)\n\t * new Container({ pivot: 50 }); // Set pivot to (50, 50)\n\t * new Container({ pivot: { x: 150, y: 150 } }); // Set pivot to (150, 150)\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ origin: new Point(100, 100) }); // Rotate around point (100,100)\n\t * new Container({ origin: 50 }); // Rotate around point (50, 50)\n\t * new Container({ origin: { x: 150, y: 150 } }); // Rotate around point (150, 150)\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ position: new Point(100, 200) }); // Set position to (100, 200)\n\t * new Container({ position: { x: 150, y: 150 } }); // Set position to (150, 150)\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ skew: new Point(0.1, 0.2) }); // Skew by 0.1 radians on x and 0.2 radians on y\n\t * new Container({ skew: { x: 0.1, y: 0.2 } }); // Skew by 0.1 radians on x and 0.2 radians on y\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ visible: false }); // Will not be drawn and transforms will not update\n\t * new Container({ visible: true }); // Will be drawn and transforms will update\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ x: 100 }); // Set x position to 100\n\t *",
      "language": "ts"
    },
    {
      "code": "* new Container({ y: 200 }); // Set y position to 200\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container({\n\t *    boundsArea: new Rectangle(0, 0, 500, 500) // Set a fixed bounds area\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n *",
      "language": "ts"
    },
    {
      "code": "* // Access children\n\t * const firstChild = container.children[0];\n\t * const lastChild = container.children[container.children.length - 1];\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic parent access\n\t * const parent = sprite.parent;\n\t *\n\t * // Walk up the tree\n\t * let current = sprite;\n\t * while (current.parent) {\n\t *     console.log('Level up:', current.parent.constructor.name);\n\t *     current = current.parent;\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic transform access\n\t * const localMatrix = sprite.localTransform;\n\t * console.log(localMatrix.toString());\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Cleanup with destroy\n\t * sprite.destroy();\n\t * console.log(sprite.destroyed); // true\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container();\n\t * container.boundsArea = new Rectangle(0, 0, 500, 500);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Add a single child\n\t * container.addChild(sprite);\n\t *\n\t * // Add multiple children\n\t * container.addChild(background, player, foreground);\n\t *\n\t * // Add with type checking\n\t * const sprite = container.addChild<Sprite>(new Sprite(texture));\n\t * sprite.tint = 'red';\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Remove a single child\n\t * const removed = container.removeChild(sprite);\n\t *\n\t * // Remove multiple children\n\t * const bg = container.removeChild(background, player, userInterface);\n\t *\n\t * // Remove with type checking\n\t * const sprite = container.removeChild<Sprite>(childSprite);\n\t * sprite.texture = newTexture;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get world position\n\t * const worldPos = container.worldTransform;\n\t * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic position\n\t * container.x = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic position\n\t * container.y = 200;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic position setting\n\t * container.position.set(100, 200);\n\t * container.position.set(100); // Sets both x and y to 100\n\t * // Using point data\n\t * container.position = { x: 50, y: 75 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic rotation\n\t * container.rotation = Math.PI / 4; // 45 degrees\n\t *\n\t * // Convert from degrees\n\t * const degrees = 45;\n\t * container.rotation = degrees * Math.PI / 180;\n\t *\n\t * // Rotate around center\n\t * container.pivot.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // 180 degrees\n\t *\n\t * // Rotate around center with origin\n\t * container.origin.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // 180 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic angle rotation\n\t * sprite.angle = 45; // 45 degrees\n\t *\n\t * // Rotate around center\n\t * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n\t * sprite.angle = 180; // Half rotation\n\t *\n\t * // Rotate around center with origin\n\t * sprite.origin.set(sprite.width / 2, sprite.height / 2);\n\t * sprite.angle = 180; // Half rotation\n\t *\n\t * // Reset rotation\n\t * sprite.angle = 0;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Rotate around center\n\t * container.pivot.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // Rotates around center\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic skewing\n\t * container.skew.set(0.5, 0); // Skew horizontally\n\t * container.skew.set(0, 0.5); // Skew vertically\n\t *\n\t * // Skew with point data\n\t * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n\t *\n\t * // Reset skew\n\t * container.skew.set(0, 0);\n\t *\n\t * // Animate skew\n\t * app.ticker.add(() => {\n\t *     // Create wave effect\n\t *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n\t * });\n\t *\n\t * // Combine with rotation\n\t * container.rotation = Math.PI / 4; // 45 degrees\n\t * container.skew.set(0.2, 0.2); // Skew the rotated object\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic scaling\n\t * container.scale.set(2, 2); // Scales to double size\n\t * container.scale.set(2); // Scales uniformly to double size\n\t * container.scale = 2; // Scales uniformly to double size\n\t * // Scale to a specific width and height\n\t * container.setSize(200, 100); // Sets width to 200 and height to 100\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Rotate around center point\n\t * container.origin.set(container.width / 2, container.height / 2);\n\t * container.rotation = Math.PI; // Rotates around center\n\t *\n\t * // Reset origin\n\t * container.origin.set(0, 0);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic width setting\n\t * container.width = 100;\n\t * // Optimized width setting\n\t * container.setSize(100, 100);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic height setting\n\t * container.height = 200;\n\t * // Optimized height setting\n\t * container.setSize(100, 200);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic size retrieval\n\t * const size = container.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * container.getSize(reuseSize);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic size setting\n\t * container.setSize(100, 200);\n\t *\n\t * // Set uniform size\n\t * container.setSize(100); // Sets both width and height to 100\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic transform update\n\t * container.updateTransform({\n\t *     x: 100,\n\t *     y: 200,\n\t *     rotation: Math.PI / 4\n\t * });\n\t *\n\t * // Scale and rotate around center\n\t * sprite.updateTransform({\n\t *     pivotX: sprite.width / 2,\n\t *     pivotY: sprite.height / 2,\n\t *     scaleX: 2,\n\t *     scaleY: 2,\n\t *     rotation: Math.PI\n\t * });\n\t *\n\t * // Update position only\n\t * button.updateTransform({\n\t *     x: button.x + 10, // Move right\n\t *     y: button.y      // Keep same y\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic matrix transform\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * container.setFromMatrix(matrix);\n\t *\n\t * // Copy transform from another container\n\t * const source = new Container();\n\t * source.position.set(100, 100);\n\t * source.rotation = Math.PI / 2;\n\t *\n\t * target.setFromMatrix(source.localTransform);\n\t *\n\t * // Reset transform\n\t * container.setFromMatrix(Matrix.IDENTITY);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic transparency\n\t * sprite.alpha = 0.5; // 50% opacity\n\t *\n\t * // Inherited opacity\n\t * container.alpha = 0.5;\n\t * const child = new Sprite(texture);\n\t * child.alpha = 0.5;\n\t * container.addChild(child);\n\t * // child's effective opacity is 0.25 (0.5 * 0.5)\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic color tinting\n\t * container.tint = 0xff0000; // Red tint\n\t * container.tint = 'red';    // Same as above\n\t * container.tint = '#00ff00'; // Green\n\t * container.tint = 'rgb(0,0,255)'; // Blue\n\t *\n\t * // Remove tint\n\t * container.tint = 0xffffff; // White = no tint\n\t * container.tint = null;     // Also removes tint\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic blend modes\n\t * sprite.blendMode = 'add';        // Additive blending\n\t * sprite.blendMode = 'multiply';   // Multiply colors\n\t * sprite.blendMode = 'screen';     // Screen blend\n\t *\n\t * // Reset blend mode\n\t * sprite.blendMode = 'normal';     // Normal blending\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic visibility toggle\n\t * sprite.visible = false; // Hide sprite\n\t * sprite.visible = true;  // Show sprite\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic render control\n\t * sprite.renderable = false; // Skip rendering\n\t * sprite.renderable = true;  // Enable rendering\n\t *",
      "language": "ts"
    },
    {
      "code": "* container.destroy();\n\t * container.destroy(true);\n\t * container.destroy({ children: true });\n\t * container.destroy({ children: true, texture: true, textureSource: true });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container();\n\t * container.accessible = true;\n\t *",
      "language": "js"
    },
    {
      "code": "* const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleTitle = 'My Container';\n\t *",
      "language": "js"
    },
    {
      "code": "* const container = new Container();\n\t * container.accessible = true;\n\t * container.tabIndex = 0;\n\t *\n\t * const sprite = new Sprite(texture);\n\t * sprite.accessible = true;\n\t * sprite.tabIndex = 1;\n\t *",
      "language": "js"
    },
    {
      "code": "* const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleText = 'This is a container';\n\t *",
      "language": "js"
    },
    {
      "code": "* const container = new Container();\n\t * container.accessible = true;\n\t * container.accessibleChildren = false; // This will prevent any children from being accessible\n\t *\n\t * const sprite = new Sprite(texture);\n\t * sprite.accessible = true; // This will not work since accessibleChildren is false\n\t *",
      "language": "js"
    },
    {
      "code": "* // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // iOS device checks\n\t * if (isMobile.apple.device) {\n\t *     if (isMobile.apple.tablet) {\n\t *         // iPad-specific code\n\t *         useTabletLayout();\n\t *     } else if (isMobile.apple.phone) {\n\t *         // iPhone-specific code\n\t *         usePhoneLayout();\n\t *     }\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Amazon Fire tablet detection\n\t * if (isMobile.amazon.tablet) {\n\t *     // Fire tablet optimizations\n\t *     optimizeForFireTablet();\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Android device handling\n\t * if (isMobile.android.device) {\n\t *     // Check specific type\n\t *     const deviceType = isMobile.android.tablet ?\n\t *         'tablet' : 'phone';\n\t *     console.log(`Android ${deviceType} detected`);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Windows device checks\n\t * if (isMobile.windows.tablet) {\n\t *     // Surface tablet optimizations\n\t *     enableTouchFeatures();\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check other platforms\n\t * if (isMobile.other.blackberry10) {\n\t *     // BlackBerry 10 specific code\n\t * } else if (isMobile.other.chrome) {\n\t *     // Chrome mobile specific code\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check if device is a phone\n\t * if (isMobile.phone) {\n\t *     console.log('Running on a mobile phone');\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check if device is a tablet\n\t * if (isMobile.tablet) {\n\t *     console.log('Running on a mobile tablet');\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check if device is mobile\n\t * if (isMobile.any) {\n\t *     console.log('Running on a mobile device');\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n *",
      "language": "js"
    },
    {
      "code": "* app.renderer.accessibility.setAccessibilityEnabled(true);\n *",
      "language": "js"
    },
    {
      "code": "* container.accessible = true;\n *",
      "language": "js"
    },
    {
      "code": "* import { AccessibilitySystem } from 'pixi.js';\n\t *\n\t * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n\t *\n\t * const app = new Application()\n\t * app.init()\n\t *",
      "language": "js"
    },
    {
      "code": "* app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n\t * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n\t *",
      "language": "js"
    },
    {
      "code": "* ticker.add((ticker) => {\n *    // Access deltaTime (dimensionless scalar ~1.0 at 60fps)\n *    sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *    // Access deltaMS (milliseconds elapsed)\n *    const progress = ticker.deltaMS / animationDuration;\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic ticker usage with different time units\n * const ticker = new Ticker();\n * ticker.add((ticker) => {\n *     // Frame-independent animation using dimensionless deltaTime\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *     // Time-based animation using deltaMS (milliseconds)\n *     sprite.x += (100 / 1000) * ticker.deltaMS; // 100 pixels per second\n * });\n * ticker.start();\n *\n * // Control update priority\n * ticker.add(\n *     (ticker) => {\n *         // High priority updates run first\n *         physics.update(ticker.deltaTime);\n *     },\n *     undefined,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // One-time updates\n * ticker.addOnce(() => {\n *     console.log('Runs on next frame only');\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Default is 0.06 (60 FPS)\n\t * console.log(Ticker.targetFPMS); // 0.06\n\t *\n\t * // Calculate target frame duration\n\t * const frameDuration = 1 / Ticker.targetFPMS; // â‰ˆ 16.67ms\n\t *\n\t * // Use in custom timing calculations\n\t * const deltaTime = elapsedMS * Ticker.targetFPMS;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Default behavior (manual start)\n\t * const ticker = new Ticker();\n\t * ticker.autoStart = false;\n\t * ticker.add(() => {\n\t *     // Won't run until ticker.start() is called\n\t * });\n\t *\n\t * // Auto-start behavior\n\t * const autoTicker = new Ticker();\n\t * autoTicker.autoStart = true;\n\t * autoTicker.add(() => {\n\t *     // Runs immediately when added\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Frame-independent animation using deltaTime scalar\n\t * ticker.add((ticker) => {\n\t *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Animation timing\n\t * ticker.add((ticker) => {\n\t *     // Use millisecond timing for precise animations\n\t *     const progress = (ticker.deltaMS / animationDuration);\n\t *     sprite.alpha = Math.min(1, progress);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* ticker.add((ticker) => {\n\t *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* ticker.add((ticker) => {\n\t *     const currentTime = performance.now();\n\t *     const timeSinceLastFrame = currentTime - ticker.lastTime;\n\t *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic speed adjustment\n\t * ticker.speed = 0.5; // Half speed (slow motion)\n\t * ticker.speed = 2.0; // Double speed (fast forward)\n\t *\n\t * // Temporary speed changes\n\t * function slowMotion() {\n\t *     const normalSpeed = ticker.speed;\n\t *     ticker.speed = 0.2;\n\t *     setTimeout(() => {\n\t *         ticker.speed = normalSpeed;\n\t *     }, 1000);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check ticker state\n\t * const ticker = new Ticker();\n\t * console.log(ticker.started); // false\n\t *\n\t * // Start and verify\n\t * ticker.start();\n\t * console.log(ticker.started); // true\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Access time properties through the ticker parameter\n\t * ticker.add((ticker) => {\n\t *     // Use deltaTime (dimensionless scalar) for frame-independent animations\n\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t *\n\t *     // Use deltaMS (milliseconds) for time-based calculations\n\t *     const progress = ticker.deltaMS / animationDuration;\n\t *\n\t *     // Use elapsedMS for raw timing measurements\n\t *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic one-time update\n\t * ticker.addOnce(() => {\n\t *     console.log('Runs next frame only');\n\t * });\n\t *\n\t * // With specific context\n\t * const game = {\n\t *     init(ticker) {\n\t *         this.loadResources();\n\t *         console.log('Game initialized');\n\t *     }\n\t * };\n\t * ticker.addOnce(game.init, game);\n\t *\n\t * // With priority\n\t * ticker.addOnce(\n\t *     () => {\n\t *         // High priority one-time setup\n\t *         physics.init();\n\t *     },\n\t *     undefined,\n\t *     UPDATE_PRIORITY.HIGH\n\t * );\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic removal\n\t * const onTick = () => {\n\t *     sprite.rotation += 0.1;\n\t * };\n\t * ticker.add(onTick);\n\t * ticker.remove(onTick);\n\t *\n\t * // Remove with context\n\t * const game = {\n\t *     update(ticker) {\n\t *         this.physics.update(ticker.deltaTime);\n\t *     }\n\t * };\n\t * ticker.add(game.update, game);\n\t * ticker.remove(game.update, game);\n\t *\n\t * // Remove all matching handlers\n\t * // (if same function was added multiple times)\n\t * ticker.add(onTick);\n\t * ticker.add(onTick);\n\t * ticker.remove(onTick); // Removes all instances\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check number of active listeners\n\t * const ticker = new Ticker();\n\t * console.log(ticker.count); // 0\n\t *\n\t * // Add some listeners\n\t * ticker.add(() => {});\n\t * ticker.add(() => {});\n\t * console.log(ticker.count); // 2\n\t *\n\t * // Check after cleanup\n\t * ticker.destroy();\n\t * console.log(ticker.count); // 0\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic manual start\n\t * const ticker = new Ticker();\n\t * ticker.add(() => {\n\t *     // Animation code here\n\t * });\n\t * ticker.start();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stop\n\t * const ticker = new Ticker();\n\t * ticker.stop();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Clean up with active listeners\n\t * const ticker = new Ticker();\n\t * ticker.add(() => {});\n\t * ticker.destroy(); // Removes all listeners\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic manual update\n\t * const ticker = new Ticker();\n\t * ticker.update(performance.now());\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic FPS monitoring\n\t * ticker.add(() => {\n\t *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set minimum acceptable frame rate\n\t * const ticker = new Ticker();\n\t * ticker.minFPS = 30; // Never go below 30 FPS\n\t *\n\t * // Use with maxFPS for frame rate clamping\n\t * ticker.minFPS = 30;\n\t * ticker.maxFPS = 60;\n\t *\n\t * // Monitor delta capping\n\t * ticker.add(() => {\n\t *     // Delta time will be capped based on minFPS\n\t *     console.log(`Delta time: ${ticker.deltaTime}`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set minimum acceptable frame rate\n\t * const ticker = new Ticker();\n\t * ticker.maxFPS = 60; // Never go above 60 FPS\n\t *\n\t * // Use with maxFPS for frame rate clamping\n\t * ticker.minFPS = 30;\n\t * ticker.maxFPS = 60;\n\t *\n\t * // Monitor delta capping\n\t * ticker.add(() => {\n\t *     // Delta time will be capped based on maxFPS\n\t *     console.log(`Delta time: ${ticker.deltaTime}`);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application();\n\t * await app.init({\n\t *     resizeTo: window, // Resize to the entire window\n\t *     // or\n\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t *     // or\n\t *     resizeTo: null, // Disable auto-resize\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n *",
      "language": "ts"
    },
    {
      "code": "* import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n *",
      "language": "ts"
    },
    {
      "code": "* // Auto-start (default behavior)\n\t * await app.init({ autoStart: true });\n\t *\n\t * // Manual start\n\t * await app.init({ autoStart: false });\n\t * app.start(); // Start when ready\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Use shared ticker (global instance)\n\t * await app.init({ sharedTicker: true });\n\t *\n\t * // Use dedicated ticker (default)\n\t * await app.init({ sharedTicker: false });\n\t *\n\t * // Access ticker properties\n\t * console.log(app.ticker.FPS);    // Current FPS\n\t * console.log(app.ticker.deltaMS); // MS since last update\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     resizeTo: window, // Resize to the entire window\n\t\t\t *     // or\n\t\t\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t\t\t *     // or\n\t\t\t *     resizeTo: null, // Disable auto-resize\n\t\t\t * });\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     resizeTo: window, // Resize to the entire window\n\t\t\t *     // or\n\t\t\t *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n\t\t\t *     // or\n\t\t\t *     resizeTo: null, // Disable auto-resize\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Manually trigger a resize\n\t\t\t * app.resize();\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* app.queueResize(); // Queue for next frame\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Queue a resize\n\t\t\t * app.queueResize();\n\t\t\t *\n\t\t\t * // Cancel if needed\n\t\t\t * app.cancelResize();\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic animation\n\t\t\t * app.ticker.add((ticker) => {\n\t\t\t *     sprite.rotation += 0.1 * ticker.deltaTime;\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Control update priority\n\t\t\t * app.ticker.add(\n\t\t\t *     (ticker) => {\n\t\t\t *         // Physics update (runs first)\n\t\t\t *     },\n\t\t\t *     undefined,\n\t\t\t *     UPDATE_PRIORITY.HIGH\n\t\t\t * );\n\t\t\t *\n\t\t\t * // One-time update\n\t\t\t * app.ticker.addOnce(() => {\n\t\t\t *     console.log('Runs next frame only');\n\t\t\t * });\n\t\t\t *\n\t\t\t * // Access timing info\n\t\t\t * console.log(app.ticker.FPS);      // Current FPS\n\t\t\t * console.log(app.ticker.deltaTime); // Scaled time delta\n\t\t\t * console.log(app.ticker.deltaMS);   // MS since last update\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Stop the application\n\t\t\t * app.stop();\n\t\t\t * // ... custom update logic ...\n\t\t\t * app.render(); // Manual render\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Initialize without auto-start\n\t\t\t * await app.init({ autoStart: false });\n\t\t\t *\n\t\t\t * // Start when ready\n\t\t\t * app.start();\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Enable culling for a container\n * const container = new Container();\n * container.cullable = true;\n *\n * // Set custom cull area for better performance\n * container.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Disable child culling for static scenes\n * container.cullableChildren = false;\n *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container();\n\t *\n\t * // Define custom culling boundary\n\t * container.cullArea = new Rectangle(0, 0, 800, 600);\n\t *\n\t * // Reset to use object bounds\n\t * container.cullArea = null;\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t *\n\t * // Enable culling\n\t * sprite.cullable = true;\n\t *\n\t * // Force object to always render\n\t * sprite.cullable = false;\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new Container();\n\t *\n\t * // Enable container culling\n\t * container.cullable = true;\n\t *\n\t * // Disable child culling for performance\n\t * container.cullableChildren = false;\n\t *\n\t * // Children will always render if container is visible\n\t * container.addChild(sprite1, sprite2, sprite3);\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Application } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n * await app.init({\n *     culler: {\n *         updateTransform: false // Skip updating transforms for culled objects\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic culling options\n\t * const app = new Application();\n\t * await app.init({\n\t *     culler: {...}\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application();\n\t\t * await app.init({\n\t\t *     culler: {\n\t\t *         updateTransform: false // Skip updating transforms for culled objects\n\t\t *     }\n\t\t * });\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* import { Application, CullerPlugin, Container, Rectangle } from 'pixi.js';\n *\n * // Register the plugin\n * extensions.add(CullerPlugin);\n *\n * // Create application\n * const app = new Application();\n * await app.init({...});\n *\n * // Create a container with culling enabled\n * const container = new Container();\n * container.cullable = true;         // Enable culling for this container\n * container.cullableChildren = true; // Enable culling for children (default)\n * app.stage.addChild(container);\n *\n * // Optional: Set custom cull area to avoid expensive bounds calculations\n * container.cullArea = new Rectangle(0, 0, app.screen.width, app.screen.height);\n *\n * // Add many sprites to the group\n * for (let j = 0; j < 100; j++) {\n *     const sprite = Sprite.from('texture.png');\n *     sprite.x = Math.random() * 2000;\n *     sprite.y = Math.random() * 2000;\n *\n *     sprite.cullable = true; // Enable culling for each sprite\n *\n *     // Set cullArea if needed\n *     // sprite.cullArea = new Rectangle(0, 0, 100, 100); // Optional\n *\n *     // Add to container\n *     container.addChild(sprite);\n * }\n *",
      "language": "ts"
    },
    {
      "code": "* // Create with a custom element\n * const domContainer = new DOMContainer({\n *     element: document.createElement('input'),\n *     anchor: { x: 0.5, y: 0.5 } // or anchor: 0.5 to center both x and y\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic text display\n * const textContainer = new DOMContainer();\n * textContainer.element.innerHTML = 'Hello World!';\n * app.stage.addChild(textContainer);\n *\n * // Input field with centered anchor\n * const inputContainer = new DOMContainer({\n *     element: document.createElement('input'),\n *     anchor: 0.5\n * });\n * inputContainer.position.set(400, 300);\n * app.stage.addChild(inputContainer);\n *\n * // Rich text area\n * const textArea = new DOMContainer({\n *     element: document.createElement('textarea'),\n *     anchor: { x: 0, y: 0 }\n * });\n * textArea.scale.set(2);\n * app.stage.addChild(textArea);\n *",
      "language": "ts"
    },
    {
      "code": "* const container = new DOMContainer();\n\t *\n\t * // Set anchor to center (shorthand)\n\t * container.anchor = 0.5;\n\t *\n\t * // Set anchor to bottom-right\n\t * container.anchor = { x: 1, y: 1 };\n\t *\n\t * // Set anchor to custom position\n\t * container.anchor = new Point(0.3, 0.7);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const domContainer = new DOMContainer();\n\t * domContainer.element = document.createElement('input');\n\t *",
      "language": "ts"
    },
    {
      "code": "* const domContainer = new DOMContainer();\n\t * domContainer.element.innerHTML = 'Hello World!';\n\t * document.body.appendChild(domContainer.element);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *",
      "language": "ts"
    },
    {
      "code": "* // Common cursor types\n\t * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n\t * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n\t * sprite.cursor = 'crosshair';   // Precise cursor for selection\n\t * sprite.cursor = 'not-allowed'; // Indicate disabled state\n\t *\n\t * // Direction cursors\n\t * sprite.cursor = 'n-resize';    // North resize\n\t * sprite.cursor = 'ew-resize';   // East-west resize\n\t * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n\t *\n\t * // Custom cursor with fallback\n\t * sprite.cursor = 'url(\"custom.png\"), auto';\n\t * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t *\n\t * // Enable standard interaction (like buttons)\n\t * sprite.eventMode = 'static';\n\t * sprite.on('pointerdown', () => console.log('clicked!'));\n\t *\n\t * // Enable for moving objects\n\t * sprite.eventMode = 'dynamic';\n\t * sprite.on('pointermove', () => updatePosition());\n\t *\n\t * // Disable all interaction\n\t * sprite.eventMode = 'none';\n\t *\n\t * // Only allow child interactions\n\t * sprite.eventMode = 'passive';\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Enable interaction events\n\t * sprite.interactive = true;  // Sets eventMode = 'static'\n\t * sprite.interactive = false; // Sets eventMode = 'passive'\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Container with many visual-only children\n\t * const container = new Container();\n\t * container.interactiveChildren = false; // Skip hit testing children\n\t *\n\t * // Menu with interactive buttons\n\t * const menu = new Container();\n\t * menu.interactiveChildren = true; // Test all children\n\t * menu.addChild(button1, button2, button3);\n\t *\n\t * // Performance optimization\n\t * background.interactiveChildren = false;\n\t * foreground.interactiveChildren = true;\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Rectangle, Circle, Sprite } from 'pixi.js';\n\t *\n\t * // Rectangular hit area\n\t * const button = new Sprite(texture);\n\t * button.eventMode = 'static';\n\t * button.hitArea = new Rectangle(0, 0, 100, 50);\n\t *\n\t * // Circular hit area\n\t * const icon = new Sprite(texture);\n\t * icon.eventMode = 'static';\n\t * icon.hitArea = new Circle(32, 32, 32);\n\t *\n\t * // Custom hit area with polygon\n\t * const custom = new Sprite(texture);\n\t * custom.eventMode = 'static';\n\t * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n\t *\n\t * // Custom hit testing logic\n\t * sprite.hitArea = {\n\t *     contains(x: number, y: number) {\n\t *         // Custom collision detection\n\t *         return x >= 0 && x <= width && y >= 0 && y <= height;\n\t *     }\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('click', (event) => {\n\t *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onclick = (event) => {\n\t *     console.log('Clicked at:', event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mousedown', (event) => {\n\t *    sprite.alpha = 0.5; // Visual feedback\n\t *    console.log('Mouse button:', event.button);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmousedown = (event) => {\n\t *     sprite.alpha = 0.5; // Visual feedback\n\t *     console.log('Mouse button:', event.button);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseenter', (event) => {\n\t *     sprite.scale.set(1.1);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseenter = (event) => {\n\t *     sprite.scale.set(1.1);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseleave', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseleave = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mousemove', (event) => {\n\t *    // Get coordinates relative to the sprite\n\t *   console.log('Local:', event.getLocalPosition(sprite));\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmousemove = (event) => {\n\t *     // Get coordinates relative to the sprite\n\t *     console.log('Local:', event.getLocalPosition(sprite));\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globalmousemove', (event) => {\n\t *     // Move sprite to mouse position\n\t *     sprite.position.copyFrom(event.global);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobalmousemove = (event) => {\n\t *     // Move sprite to mouse position\n\t *     sprite.position.copyFrom(event.global);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseout', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseout = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseover', (event) => {\n\t *      sprite.scale.set(1.1);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseover = (event) => {\n\t *     sprite.scale.set(1.1);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseup = (event) => {\n\t *      sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('mouseupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onmouseupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointercancel', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointercancel = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerdown', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerdown = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerenter', (event) => {\n\t *     sprite.scale.set(1.2);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerenter = (event) => {\n\t *     sprite.scale.set(1.2);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t * // Using emitter handler\n\t * sprite.on('pointerleave', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerleave = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointermove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointermove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globalpointermove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobalpointermove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerout', (event) => {\n\t *    sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerout = (event) => {\n\t *    sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerover', (event) => {\n\t *     sprite.scale.set(1.2);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerover = (event) => {\n\t *     sprite.scale.set(1.2);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointertap', (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointertap = (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerup = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('pointerupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onpointerupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightclick', (event) => {\n\t *     console.log('Right-clicked at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightclick = (event) => {\n\t *     console.log('Right-clicked at:', event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightdown', (event) => {\n\t *     sprite.scale.set(0.9);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightdown = (event) => {\n\t *     sprite.scale.set(0.9);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightup', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightup = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('rightupoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onrightupoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('tap', (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontap = (event) => {\n\t *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchcancel', (event) => {\n\t *     console.log('Touch canceled at:', event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchcancel = (event) => {\n\t *     console.log('Touch canceled at:', event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchend', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchend = (event) => {\n\t *    sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchendoutside', (event) => {\n\t *     sprite.scale.set(1.0);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchendoutside = (event) => {\n\t *     sprite.scale.set(1.0);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchmove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchmove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('globaltouchmove', (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * });\n\t * // Using property-based handler\n\t * sprite.onglobaltouchmove = (event) => {\n\t *     sprite.position.set(event.global.x, event.global.y);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('touchstart', (event) => {\n\t *     sprite.scale.set(0.9);\n\t * });\n\t * // Using property-based handler\n\t * sprite.ontouchstart = (event) => {\n\t *     sprite.scale.set(0.9);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new Sprite(texture);\n\t * sprite.eventMode = 'static';\n\t *\n\t * // Using emitter handler\n\t * sprite.on('wheel', (event) => {\n\t *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n\t *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n\t * });\n\t * // Using property-based handler\n\t * sprite.onwheel = (event) => {\n\t *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n\t *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* sprite.on('click', (event) => {\n\t *     // Prevent both browser's default click behavior\n\t *     // and PixiJS's default handling\n\t *     event.preventDefault();\n\t *\n\t *     // Custom handling\n\t *     customClickHandler();\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* container.on('pointerdown', (event) => {\n\t *     // Stop all further event handling\n\t *     event.stopImmediatePropagation();\n\t *\n\t *     // These handlers won't be called:\n\t *     // - Other pointerdown listeners on this container\n\t *     // - Any pointerdown listeners on parent containers\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* child.on('pointermove', (event) => {\n\t *     // Handle event on child\n\t *     updateChild();\n\t *\n\t *     // Prevent parent handlers from being called\n\t *     event.stopPropagation();\n\t * });\n\t *\n\t * // This won't be called if child handles the event\n\t * parent.on('pointermove', (event) => {\n\t *     updateParent();\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic usage - get local coordinates relative to a container\n\t * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n\t *     // Get position relative to the sprite\n\t *     const localPos = event.getLocalPosition(sprite);\n\t *     console.log('Local position:', localPos.x, localPos.y);\n\t * });\n\t * // Using custom global coordinates\n\t * const customGlobal = new Point(100, 100);\n\t * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n\t *     // Transform custom coordinates\n\t *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n\t *     console.log('Custom local position:', localPos.x, localPos.y);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n *",
      "language": "ts"
    },
    {
      "code": "* import { EventSystem, EventSystemFeatures } from 'pixi.js';\n\t * // Access the default event features\n\t * EventSystem.defaultEventFeatures = {\n\t *     // Enable pointer movement events\n\t *     move: true,\n\t *     // Enable global pointer move events\n\t *     globalMove: true,\n\t *     // Enable click events\n\t *     click: true,\n\t *     // Enable wheel events\n\t *     wheel: true,\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Allow default browser actions\n\t * app.renderer.events.autoPreventDefault = false;\n\t *\n\t * // Block default actions (default)\n\t * app.renderer.events.autoPreventDefault = true;\n\t *\n\t * // Example with text selection\n\t * const text = new Text('Selectable text');\n\t * text.eventMode = 'static';\n\t * app.renderer.events.autoPreventDefault = false; // Allow text selection\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Access event system through renderer\n\t * const eventSystem = app.renderer.events;\n\t *\n\t * // Set string-based cursor styles\n\t * eventSystem.cursorStyles.default = 'pointer';\n\t * eventSystem.cursorStyles.hover = 'grab';\n\t * eventSystem.cursorStyles.drag = 'grabbing';\n\t *\n\t * // Use CSS object for complex styling\n\t * eventSystem.cursorStyles.custom = {\n\t *     cursor: 'url(\"custom.png\") 2 2, auto',\n\t *     userSelect: 'none'\n\t * };\n\t *\n\t * // Use a url for custom cursors\n\t * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n\t * eventSystem.cursorStyles.icon = defaultIcon;\n\t *\n\t * // Use callback function for dynamic cursors\n\t * eventSystem.cursorStyles.dynamic = (mode) => {\n\t *     // Update cursor based on mode\n\t *     document.body.style.cursor = mode === 'hover'\n\t *         ? 'pointer'\n\t *         : 'default';\n\t * };\n\t *\n\t * // Apply cursor style to a sprite\n\t * sprite.cursor = 'hover'; // Will use the hover style defined above\n\t * sprite.cursor = 'icon'; // Will apply the icon cursor\n\t * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n\t * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n\t * sprite.cursor = 'default'; // Will apply the default pointer cursor\n\t * sprite.cursor = 'dynamic'; // Will call the dynamic function\n\t *",
      "language": "ts"
    },
    {
      "code": "* {\n\t *     default: 'inherit',\n\t *     pointer: 'pointer' // Default cursor styles\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Using predefined cursor styles\n\t * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n\t * app.renderer.events.setCursor('grab');       // Set grab cursor\n\t * app.renderer.events.setCursor(null);         // Reset to default\n\t *\n\t * // Using custom cursor styles\n\t * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n\t * app.renderer.events.setCursor('custom');     // Apply custom cursor\n\t *\n\t * // Using callback-based cursor\n\t * app.renderer.events.cursorStyles.dynamic = (mode) => {\n\t *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n\t * };\n\t * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Access current pointer position at any time\n\t * const eventSystem = app.renderer.events;\n\t * const pointer = eventSystem.pointer;\n\t *\n\t * // Get global coordinates\n\t * console.log('Position:', pointer.global.x, pointer.global.y);\n\t *\n\t * // Check button state\n\t * console.log('Buttons pressed:', pointer.buttons);\n\t *\n\t * // Get pointer type and pressure\n\t * console.log('Type:', pointer.pointerType);\n\t * console.log('Pressure:', pointer.pressure);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set a new canvas element as the target\n\t * const canvas = document.createElement('canvas');\n\t * app.renderer.events.setTargetElement(canvas);\n\t *\n\t * // Remove all event bindings\n\t * app.renderer.events.setTargetElement(null);\n\t *\n\t * // Switch to a different canvas\n\t * const newCanvas = document.querySelector('#game-canvas');\n\t * app.renderer.events.setTargetElement(newCanvas);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Map mouse coordinates to PixiJS space\n\t * const point = new Point();\n\t * app.renderer.events.mapPositionToPoint(\n\t *     point,\n\t *     event.clientX,\n\t *     event.clientY\n\t * );\n\t * console.log('Mapped position:', point.x, point.y);\n\t *\n\t * // Using with pointer events\n\t * sprite.on('pointermove', (event) => {\n\t *     // event.global already contains mapped coordinates\n\t *     console.log('Global:', event.global.x, event.global.y);\n\t *\n\t *     // Map to local coordinates\n\t *     const local = event.getLocalPosition(sprite);\n\t *     console.log('Local:', local.x, local.y);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic event mode setup\n\t\t\t * const sprite = new Sprite(texture);\n\t\t\t * sprite.eventMode = 'static';    // Enable standard interaction\n\t\t\t * sprite.on('pointerdown', () => { console.log('clicked!'); });\n\t\t\t *\n\t\t\t * // Different event modes\n\t\t\t * sprite.eventMode = 'none';      // Disable all interaction\n\t\t\t * sprite.eventMode = 'passive';   // Only allow interaction on children\n\t\t\t * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n\t\t\t * sprite.eventMode = 'dynamic';   // For moving/animated objects\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* const app = new Application();\n\t\t\t * await app.init({\n\t\t\t *     eventFeatures: {\n\t\t\t *         // Core interaction events\n\t\t\t *         move: true,        // Pointer/mouse/touch movement\n\t\t\t *         click: true,       // Click/tap events\n\t\t\t *         wheel: true,       // Mouse wheel/scroll events\n\t\t\t *         // Global tracking\n\t\t\t *         globalMove: false  // Global pointer movement\n\t\t\t *     }\n\t\t\t * });\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic equality check\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(0, 0, 100, 100);\n\t\t\t * console.log(rect1.equals(rect2)); // true\n\t\t\t *\n\t\t\t * // Check after modifications\n\t\t\t * rect2.width = 200;\n\t\t\t * console.log(rect1.equals(rect2)); // false\n\t\t\t *\n\t\t\t * // Compare with offset rectangle\n\t\t\t * const offset = new Rectangle(10, 10, 100, 100);\n\t\t\t * console.log(rect1.equals(offset)); // false\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic intersection check\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t\t\t *\n\t\t\t * const overlap = rect1.intersection(rect2);\n\t\t\t * console.log(overlap); // Rectangle(50, 50, 50, 50)\n\t\t\t *\n\t\t\t * // Using output rectangle\n\t\t\t * const out = new Rectangle();\n\t\t\t * rect1.intersection(rect2, out);\n\t\t\t *\n\t\t\t * // Zero-area rectangles\n\t\t\t * const empty = new Rectangle(0, 0, 0, 100);\n\t\t\t * const result = rect1.intersection(empty);\n\t\t\t * console.log(result); // Rectangle(0, 0, 0, 0)\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic union\n\t\t\t * const rect1 = new Rectangle(0, 0, 100, 100);\n\t\t\t * const rect2 = new Rectangle(50, 50, 100, 100);\n\t\t\t * const combined = rect1.union(rect2);\n\t\t\t * console.log(combined); // Rectangle(0, 0, 150, 150)\n\t\t\t *\n\t\t\t * // Using output rectangle\n\t\t\t * const out = new Rectangle();\n\t\t\t * rect1.union(rect2, out);\n\t\t\t *\n\t\t\t * // Chain multiple unions\n\t\t\t * const rect3 = new Rectangle(200, 200, 50, 50);\n\t\t\t * const result = rect1.union(rect2).union(rect3);\n\t\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic point addition\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(5, 10);\n\t\t * const result = point.add(other);\n\t\t * console.log(result); // Point(15, 30)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.add(other, output);\n\t\t * console.log(output); // Point(15, 30)\n\t\t *\n\t\t * // Chain multiple additions\n\t\t * const final = point.add(other).add(new Point(2, 3));\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic point subtraction\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(5, 10);\n\t\t * const result = point.subtract(other);\n\t\t * console.log(result); // Point(5, 10)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.subtract(other, output);\n\t\t * console.log(output); // Point(5, 10)\n\t\t *\n\t\t * // Chain multiple subtractions\n\t\t * const final = point.subtract(other).subtract(new Point(2, 3));\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic point multiplication\n\t\t * const point = new Point(10, 20);\n\t\t * const other = new Point(2, 3);\n\t\t * const result = point.multiply(other);\n\t\t * console.log(result); // Point(20, 60)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.multiply(other, output);\n\t\t * console.log(output); // Point(20, 60)\n\t\t *\n\t\t * // Chain multiple operations\n\t\t * const final = point.multiply(other).add(new Point(5, 5));\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic scalar multiplication\n\t\t * const point = new Point(10, 20);\n\t\t * const result = point.multiplyScalar(2);\n\t\t * console.log(result); // Point(20, 40)\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point();\n\t\t * point.multiplyScalar(0.5, output);\n\t\t * console.log(output); // Point(5, 10)\n\t\t *\n\t\t * // Chain with other operations\n\t\t * const final = point.multiplyScalar(2).add(new Point(5, 5));\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic dot product\n\t\t * const v1 = new Point(2, 3);\n\t\t * const v2 = new Point(4, 5);\n\t\t * const result = v1.dot(v2); // 2*4 + 3*5 = 23\n\t\t *\n\t\t * // Check if vectors are perpendicular\n\t\t * const isOrthogonal = v1.dot(v2) === 0;\n\t\t *\n\t\t * // Get angle between vectors\n\t\t * const cosTheta = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic cross product\n\t\t * const v1 = new Point(2, 3);\n\t\t * const v2 = new Point(4, 5);\n\t\t * const result = v1.cross(v2); // 2*5 - 3*4 = -2\n\t\t *\n\t\t * // Check if vectors are parallel\n\t\t * const isParallel = v1.cross(v2) === 0;\n\t\t *\n\t\t * // Get signed area of parallelogram\n\t\t * const area = Math.abs(v1.cross(v2));\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic normalization\n\t\t * const vector = new Point(3, 4);\n\t\t * const normalized = vector.normalize();\n\t\t * console.log(normalized.magnitude()); // 1\n\t\t *\n\t\t * // Using output point\n\t\t * const out = new Point();\n\t\t * vector.normalize(out);\n\t\t *\n\t\t * // Chain with other operations\n\t\t * const scaled = vector.normalize().multiplyScalar(5);\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic length calculation\n\t\t * const vector = new Point(3, 4);\n\t\t * console.log(vector.magnitude()); // 5\n\t\t *\n\t\t * // Check if unit vector\n\t\t * const isUnit = Math.abs(vector.magnitude() - 1) < 0.0001;\n\t\t *\n\t\t * // Compare vector lengths\n\t\t * const longer = v1.magnitude() > v2.magnitude();\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Efficient length comparison\n\t\t * const v1 = new Point(3, 4);\n\t\t * const v2 = new Point(1, 2);\n\t\t *\n\t\t * // Better than: v1.magnitude() > v2.magnitude()\n\t\t * const longer = v1.magnitudeSquared() > v2.magnitudeSquared();\n\t\t *\n\t\t * // Check if vector is longer than 5 units\n\t\t * const isLong = v1.magnitudeSquared() > 25; // 5 * 5\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic reflection\n\t\t * const ray = new Point(1, 1);\n\t\t * const surfaceNormal = new Point(0, 1).normalize();\n\t\t * const reflection = ray.reflect(surfaceNormal);\n\t\t *\n\t\t * // Using output point\n\t\t * const out = new Point();\n\t\t * ray.reflect(surfaceNormal, out);\n\t\t *\n\t\t * // Reflect off angled surface\n\t\t * const slope = new Point(1, 1).normalize();\n\t\t * const bounced = ray.reflect(slope);\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic point rotation\n\t\t * const point = new Point(10, 20);\n\t\t * const degrees = 45\n\t\t * const radians = degrees * (Math.PI / 180)\n\t\t * const result = point.rotate(radians);\n\t\t * console.log(result); // {x: -7.071067811865474, y: 21.213203435596427}\n\t\t *\n\t\t * // Using output point for efficiency\n\t\t * const output = new Point(10, 20);\n\t\t * point.rotate(90 * (Math.PI / 180), output);\n\t\t * console.log(result); // {x: -7.071067811865474, y: 21.213203435596427}\n\t\t *\n\t\t * // Chain multiple additions\n\t\t * const final = point.rotate(radians).rotate(radians2);\n\t\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic color fill\n * const fillStyle = {\n *     color: 0xff0000,  // Red\n *     alpha: 0.5        // 50% opacity\n * };\n *\n * // Textured fill ( Graphics only )\n * const fillStyle = {\n *     texture: Texture.from('myImage.png'),\n *     matrix: new Matrix().scale(0.5, 0.5),\n * };\n *\n * // Gradient fill\n * const gradient = new FillGradient({\n *    end: { x: 1, y: 0 },\n *    stops: [\n *        { color: 0xff0000, offset: 0 }, // Red at start\n *        { color: 0x0000ff, offset: 1 }, // Blue at end\n *    ]\n * })\n *\n * const fillStyle = {\n *     fill: gradient,\n *     alpha: 1\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Using a hex color\n\t * const fillStyle = { color: 0xff0000 }; // Red\n\t * // Using a Color object\n\t * const fillStyle = { color: new Color(1, 0, 0) }; // Red\n\t * // Using a string color\n\t * const fillStyle = { color: 'red' }; // Red\n\t * // Using object string\n\t * const fillStyle = { color: 'rgb(255, 0, 0)' }; // Red\n\t *",
      "language": "ts"
    },
    {
      "code": "* const fillStyle = { alpha: 0.5 }; // 50% opacity\n\t *",
      "language": "ts"
    },
    {
      "code": "* const fillStyle = { texture: Texture.from('myImage.png') };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Scale and rotate a texture fill\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     matrix: new Matrix()\n\t *         .scale(0.5, 0.5)\n\t *         .rotate(Math.PI / 4)\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Using a gradient\n\t * const gradient = new FillGradient({\n\t *    end: { x: 1, y: 0 },\n\t *    stops: [\n\t *        { color: 0xff0000, offset: 0 }, // Red at start\n\t *        { color: 0x0000ff, offset: 1 }, // Blue at end\n\t *    ]\n\t * });\n\t *\n\t * const fillStyle = {\n\t *     fill: gradient,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // Using a pattern\n\t * const pattern = new FillPattern(\n\t *     Texture.from('pattern.png'),\n\t *     'repeat' // or 'no-repeat', 'repeat-x', 'repeat-y'\n\t * );\n\t *\n\t * const fillStyle = {\n\t *     fill: pattern\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Local space - texture fits each shape independently\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     textureSpace: 'local'\n\t * };\n\t *\n\t * // Global space - texture continues across shapes\n\t * const fillStyle = {\n\t *     texture: Texture.from('myImage.png'),\n\t *     textureSpace: 'global'\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const graphics = new Graphics();\n *\n * // Basic stroke with width\n * graphics.stroke({\n *     width: 4,\n *     color: 0xff0000 // Or use a Color object\n * });\n *\n * // Stroke with rounded corners and ends\n * const text = new Text('Hello World', {\n *     fontSize: 32,\n *     fill: 0x000000, // Text color\n *     stroke: {\n *     width: 8,\n *         color: 0x00ff00, // Or use a Color object\n *         cap: 'round',    // Round end caps\n *         join: 'round',   // Round corner joins\n *         alignment: 0.5   // Center alignment\n *     }\n * });\n *\n * // Stroke with mitered corners\n * graphics.stroke({\n *     width: 6,\n *     color: 0x0000ff, // Or use a Color object\n *     join: 'miter',\n *     miterLimit: 3,   // Limit how far miter extends\n *     alignment: 0     // Outside alignment\n * });\n *\n * // Pixel-perfect line\n * graphics.stroke({\n *     width: 1,\n *     pixelLine: true, // Ensures crisp 1px lines\n *     color: 0x000000  // Or use a Color object\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* const stroke = { width: 4 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Inside alignment\n\t * const stroke = { alignment: 1 };\n\t * // Centered alignment\n\t * const stroke = { alignment: 0.5 };\n\t * // Outside alignment\n\t * const stroke = { alignment: 0 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const stroke = { cap: 'round' };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const stroke = { join: 'round' };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const stroke = {\n\t *     join: 'miter',\n\t *     miterLimit: 3,\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const graphics = new Graphics();\n\t *\n\t * // Draw pixel-perfect line\n\t * graphics\n\t *     .moveTo(50, 50)\n\t *     .lineTo(150, 50)\n\t *     .stroke({\n\t *         width: 1,\n\t *         pixelLine: true,\n\t *         color: 0x000000\n\t *     });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // --- Graphics Examples ---\n * const graphics = new Graphics();\n *\n * // Basic solid color stroke\n * graphics.stroke({\n *     width: 4,\n *     color: 0xff0000,\n *     alpha: 0.8,\n *     join: 'round'\n * });\n *\n * // Gradient stroke with attributes\n * const gradient = new FillGradient({\n *    end: { x: 1, y: 0 },\n *    stops: [\n *        { color: 0xff0000, offset: 0 }, // Red at start\n *        { color: 0x0000ff, offset: 1 }, // Blue at end\n *    ]\n * });\n *\n * graphics.stroke({\n *     width: 8,\n *     fill: gradient,\n *     cap: 'round',\n *     join: 'round',\n *     alignment: 0.5\n * });\n *\n * // --- Text Examples ---\n *\n * // Basic text stroke\n * const text = new Text('Hello World', {\n *     fontSize: 48,\n *     stroke: {\n *         width: 4,\n *         color: 0x000000,\n *         alignment: 0  // Outside stroke\n *     }\n * });\n *\n * // Gradient text stroke\n * const textGradient = new FillGradient({\n *   end: { x: 1, y: 0 },\n *   stops: [\n *       { color: 0xff0000, offset: 0 }, // Red at start\n *       { color: 0x0000ff, offset: 1 }, // Blue at end\n *   ]\n * });\n *\n * const fancyText = new Text('Gradient Outline', {\n *     fontSize: 64,\n *     fill: 0xffffff,\n *     stroke: {\n *         width: 6,\n *         fill: textGradient,\n *         alignment: 0.5,\n *         join: 'round'\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* graphics.fill(0xff0000);\n * graphics.fill(new FillPattern(texture));\n * graphics.fill(new FillGradient(0, 0, 200, 0));\n * graphics.fill({\n *   color: 0xff0000,\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * });\n * graphics.fill({\n *   fill: new FillPattern(texture),\n * });\n * graphics.fill({\n *   fill: new FillGradient(0, 0, 200, 0),\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* graphics.stroke(0xff0000);\n * graphics.stroke(new FillPattern(texture));\n * graphics.stroke(new FillGradient(0, 0, 200, 0));\n * graphics.stroke({\n *   color: 0xff0000,\n *   width?: 1,\n *   alignment?: 0.5,\n * });\n * graphics.stroke({\n *   fill: new FillPattern(texture),\n *   width: 1,\n *   alignment: 0.5,\n * });\n * graphics.stroke({\n *   fill: new FillGradient(0, 0, 200, 0),\n *   width: 1,\n *   alignment: 0.5,\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Set drop shadow opacity to 50%\n\t * dropShadow: {\n\t *    alpha: 0.5\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set drop shadow angle to 30 degrees\n\t * dropShadow: {\n\t *    angle: Math.PI / 6 // 30 degrees\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set drop shadow blur radius to 10 pixels\n\t * dropShadow: {\n\t *   blur: 10\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set drop shadow distance to 5 pixels\n\t * dropShadow: {\n\t *   distance: 5\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Enable word breaking\n\t * const style = new TextStyle({\n\t *    breakWords: true,\n\t *    wordWrap: true,\n\t *    wordWrapWidth: 200\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Single font family\n\t * fontFamily: 'Arial'\n\t * // Multiple font families\n\t * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Numeric size\n\t * fontSize: 26\n\t * // String size\n\t * fontSize: '26px'\n\t * // Percentage size\n\t * fontSize: '160%' // 1.6 times the parent element's font size\n\t * // Em size\n\t * fontSize: '1.6em' // 1.6 times the parent element's font size\n\t * @default 26\n\t */\n\tfontSize?: number | string;\n\t/**\n\t * Font style (normal, italic, oblique).\n\t * @default 'normal'\n\t */\n\tfontStyle?: TextStyleFontStyle;\n\t/**\n\t * Font variant (normal, small-caps).\n\t * @default 'normal'\n\t */\n\tfontVariant?: TextStyleFontVariant;\n\t/**\n\t * Font weight (normal, bold, bolder, lighter, 100-900).\n\t * @default 'normal'\n\t */\n\tfontWeight?: TextStyleFontWeight;\n\t/** The height of the line, a number that represents the vertical space that a letter uses. */\n\tleading?: number;\n\t/** The amount of spacing between letters, default is 0 */\n\tletterSpacing?: number;\n\t/** The line height, a number that represents the vertical space that a letter uses */\n\tlineHeight?: number;\n\t/**\n\t * Padding around the text.\n\t *\n\t * Occasionally some fonts are cropped. Adding some padding will prevent this from\n\t * happening by adding padding to all sides of the text.\n\t */\n\tpadding?: number;\n\t/**\n\t * Stroke style for text outline.\n\t * @default null\n\t */\n\tstroke?: StrokeInput;\n\t/**\n\t * Vertical alignment baseline.\n\t * @default 'alphabetic'\n\t */\n\ttextBaseline?: TextStyleTextBaseline;\n\t/**\n\t * Whether to trim transparent edges.\n\t * > [!NOTE] This is an expensive operation and should only be used when necessary.\n\t * @default false\n\t */\n\ttrim?: boolean;\n\t/**\n\t * How to handle whitespace.\n\t *\n\t * It needs wordWrap to be set to true for this to have an effect.\n\t * @default 'pre'\n\t */\n\twhiteSpace?: TextStyleWhiteSpace;\n\t/** Indicates if word wrap should be used */\n\twordWrap?: boolean;\n\t/** The width at which text will wrap, it needs wordWrap to be set to true */\n\twordWrapWidth?: number;\n\t/**\n\t * Array of filters to apply to the text.\n\t *\n\t * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n\t * compared to applying the filter directly to the text object (which would be applied at run time).\n\t * @default undefined\n\t */\n\tfilters?: Filter[] | readonly Filter[];\n}\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n *",
      "language": "ts"
    },
    {
      "code": "*\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n */\nexport declare class TextStyle extends EventEmitter<{\n\tupdate: TextDropShadow;\n}> {\n\t/**\n\t * Default drop shadow settings used when enabling drop shadows on text.\n\t * These values are used as the base configuration when drop shadows are enabled without specific settings.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic defaultDropShadow: TextDropShadow;\n\t/**\n\t * Default text style settings used when creating new text objects.\n\t * These values serve as the base configuration and can be customized globally.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic defaultTextStyle: TextStyleOptions;\n\tconstructor(style?: Partial<TextStyleOptions>);\n\t/**\n\t * Alignment for multiline text, does not affect single line text.\n\t * @type {'left'|'center'|'right'|'justify'}\n\t */\n\tget align(): TextStyleAlign;\n\tset align(value: TextStyleAlign);\n\t/** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n\tget breakWords(): boolean;\n\tset breakWords(value: boolean);\n\t/** Set a drop shadow for the text. */\n\tget dropShadow(): TextDropShadow;\n\tset dropShadow(value: boolean | TextDropShadow);\n\t/** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n\tget fontFamily(): string | string[];\n\tset fontFamily(value: string | string[]);\n\t/** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n\tget fontSize(): number;\n\tset fontSize(value: string | number);\n\t/**\n\t * The font style.\n\t * @type {'normal'|'italic'|'oblique'}\n\t */\n\tget fontStyle(): TextStyleFontStyle;\n\tset fontStyle(value: TextStyleFontStyle);\n\t/**\n\t * The font variant.\n\t * @type {'normal'|'small-caps'}\n\t */\n\tget fontVariant(): TextStyleFontVariant;\n\tset fontVariant(value: TextStyleFontVariant);\n\t/**\n\t * The font weight.\n\t * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n\t */\n\tget fontWeight(): TextStyleFontWeight;\n\tset fontWeight(value: TextStyleFontWeight);\n\t/** The space between lines. */\n\tget leading(): number;\n\tset leading(value: number);\n\t/** The amount of spacing between letters, default is 0. */\n\tget letterSpacing(): number;\n\tset letterSpacing(value: number);\n\t/** The line height, a number that represents the vertical space that a letter uses. */\n\tget lineHeight(): number;\n\tset lineHeight(value: number);\n\t/**\n\t * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n\t * by adding padding to all sides of the text.\n\t * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n\t */\n\tget padding(): number;\n\tset padding(value: number);\n\t/**\n\t * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n\t * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n\t * compared to applying the filter directly to the text object (which would be applied at run time).\n\t * @default null\n\t */\n\tget filters(): readonly Filter[];\n\tset filters(value: Filter[]);\n\t/**\n\t * Trim transparent borders from the text texture.\n\t * > [!IMPORTANT] PERFORMANCE WARNING:\n\t * > This is a costly operation as it requires scanning pixel alpha values.\n\t * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n\t */\n\tget trim(): boolean;\n\tset trim(value: boolean);\n\t/**\n\t * The baseline of the text that is rendered.\n\t * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n\t */\n\tget textBaseline(): TextStyleTextBaseline;\n\tset textBaseline(value: TextStyleTextBaseline);\n\t/**\n\t * How newlines and spaces should be handled.\n\t * Default is 'pre' (preserve, preserve).\n\t *\n\t *  value       | New lines     |   Spaces\n\t *  ---         | ---           |   ---\n\t * 'normal'     | Collapse      |   Collapse\n\t * 'pre'        | Preserve      |   Preserve\n\t * 'pre-line'   | Preserve      |   Collapse\n\t * @type {'normal'|'pre'|'pre-line'}\n\t */\n\tget whiteSpace(): TextStyleWhiteSpace;\n\tset whiteSpace(value: TextStyleWhiteSpace);\n\t/** Indicates if word wrap should be used. */\n\tget wordWrap(): boolean;\n\tset wordWrap(value: boolean);\n\t/** The width at which text will wrap, it needs wordWrap to be set to true. */\n\tget wordWrapWidth(): number;\n\tset wordWrapWidth(value: number);\n\t/**\n\t * The fill style that will be used to color the text.\n\t * This can be:\n\t * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n\t * - A hex number like 0xff0000 for red\n\t * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n\t * - A FillGradient for gradient fills\n\t * - A FillPattern for pattern/texture fills\n\t *\n\t * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n\t * while gradients at any other angle are spread across the entire text body as a whole.\n\t * @example\n\t * // Vertical gradient applied per line\n\t * const verticalGradient = new FillGradient(0, 0, 0, 1)\n\t *     .addColorStop(0, 0xff0000)\n\t *     .addColorStop(1, 0x0000ff);\n\t *\n\t * const text = new Text({\n\t *     text: 'Line 1\\nLine 2',\n\t *     style: { fill: verticalGradient }\n\t * });\n\t *\n\t * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n\t * @type {string|number|FillStyle|FillGradient|FillPattern}\n\t */\n\tget fill(): FillInput;\n\tset fill(value: FillInput);\n\t/** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n\tget stroke(): StrokeInput;\n\tset stroke(value: StrokeInput);\n\tupdate(): void;\n\t/** Resets all properties to the default values */\n\treset(): void;\n\t/**\n\t * Returns a unique key for this instance.\n\t * This key is used for caching.\n\t * @returns {string} Unique key for the instance\n\t */\n\tget styleKey(): string;\n\t/**\n\t * Creates a new TextStyle object with the same values as this one.\n\t * @returns New cloned TextStyle object\n\t */\n\tclone(): TextStyle;\n\t/**\n\t * Destroys this text style.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *  have been set to that value\n\t * @example\n\t * // Destroy the text style and its textures\n\t * textStyle.destroy({ texture: true, textureSource: true });\n\t * textStyle.destroy(true);\n\t */\n\tdestroy(options?: TypeOrBool<TextureDestroyOptions>): void;\n}\n/**\n * Options for HTML text style, extends standard text styling with HTML-specific capabilities.\n * Omits certain base text properties that don't apply to HTML rendering.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, \"leading\" | \"textBaseline\" | \"trim\" | \"filters\"> {\n\t/**\n\t * Custom styles to apply to specific HTML tags.\n\t * Allows for consistent styling of custom elements without CSS overrides.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n */\nexport declare class HTMLTextStyle extends TextStyle {\n\t/**\n\t * Custom styles to apply to specific HTML tags.\n\t * Allows for consistent styling of custom elements without CSS overrides.\n\t * @example\n\t * new HTMLText({\n\t *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n\t *   style:{\n\t *       fontFamily: 'DM Sans',\n\t *       fill: 'white',\n\t *       fontSize:100,\n\t *       tagStyles:{\n\t *           red:{\n\t *               fill:'red',\n\t *           },\n\t *           blue:{\n\t *               fill:'blue',\n\t *           },\n\t *           green:{\n\t *               fill:'green',\n\t *           }\n\t *       }\n\t *   }\n\t * );\n\t */\n\ttagStyles: Record<string, HTMLTextStyleOptions>;\n\tconstructor(options?: HTMLTextStyleOptions);\n\t/**\n\t * Creates a new HTMLTextStyle object with the same values as this one.\n\t * This creates a deep copy of all style properties, including dropShadow and tag styles.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*\n\t * Properties that are cloned:\n\t * - Basic text properties (fontSize, fontFamily, etc.)\n\t * - Fill and stroke styles\n\t * - Drop shadow configuration\n\t * - CSS overrides\n\t * - Tag styles (deep copied)\n\t * - Word wrap settings\n\t * - Alignment and spacing\n\t * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n\t */\n\tclone(): HTMLTextStyle;\n\t/**\n\t * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n\t * Texture fills are not supported and will trigger a warning in debug mode.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param value - The fill color to use. Must be a string or number.\n\t * @throws {Warning} In debug mode when attempting to use unsupported fill types\n\t */\n\tset fill(value: FillInput);\n\t/**\n\t * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n\t * Texture strokes are not supported and will trigger a warning in debug mode.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n\t * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n\t */\n\tset stroke(value: StrokeInput);\n}\n/**\n * A string or number that can be used as text.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport type TextString = string | number | {\n\ttoString: () => string;\n};\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * This is used to allow for any text style to be passed to a text object.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * This is used to allow for any text style options to be passed to a text object.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n/**\n * Options for creating text objects in PixiJS. This interface defines the common properties\n * used across different text rendering implementations (Canvas, HTML, and Bitmap).\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface TextOptions<TEXT_STYLE extends TextStyle = TextStyle, TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions> extends PixiMixins.TextOptions, ViewContainerOptions {\n\t/**\n\t * The anchor point of the text that controls the origin point for positioning and rotation.\n\t * Can be a number (same value for x/y) or a PointData object.\n\t * - (0,0) is top-left\n\t * - (0.5,0.5) is center\n\t * - (1,1) is bottom-right\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default { x: 0, y: 0 }\n\t */\n\tanchor?: PointData | number;\n\t/**\n\t * The text content to display. Use '\\n' for line breaks.\n\t * Accepts strings, numbers, or objects with toString() method.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default ''\n\t */\n\ttext?: TextString;\n\t/**\n\t * The resolution/device pixel ratio for rendering.\n\t * Higher values result in sharper text at the cost of performance.\n\t * Set to null for auto-resolution based on device.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default null\n\t */\n\tresolution?: number;\n\t/**\n\t * The style configuration for the text.\n\t * Can be a TextStyle instance or a configuration object.\n\t * Supports canvas text styles, HTML text styles, and bitmap text styles.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* const text = new Text({\n\t *     text: 'Rounded Text',\n\t *     roundPixels: true // Rounds position to whole pixels\n\t * });\n\t * @default false\n\t */\n\troundPixels?: boolean;\n}\ninterface Text$1 extends PixiMixins.Text, AbstractText<TextStyle, TextStyleOptions, CanvasTextOptions, BatchableText> {\n}\n/**\n * Constructor options used for `Text` instances. These options extend TextOptions with\n * canvas-specific features like texture styling.\n * @example\n *",
      "language": "ts"
    },
    {
      "code": "*/\nexport interface CanvasTextOptions extends TextOptions {\n}\n/**\n * A powerful text rendering class that creates one or multiple lines of text using the Canvas API.\n * Provides rich text styling capabilities with runtime modifications.\n *\n * Key features:\n * - Dynamic text content and styling\n * - Multi-line text support\n * - Word wrapping\n * - Custom texture styling\n * - High-quality text rendering\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Performance Considerations:\n * - Each text instance creates its own texture\n * - Texture is regenerated when text or style changes\n * - Use BitmapText for better performance with static text\n * - Consider texture style options for quality vs performance tradeoffs\n */\ndeclare class Text$1 extends AbstractText<TextStyle, TextStyleOptions, CanvasTextOptions, BatchableText> implements View {\n\t/**\n\t * @param {CanvasTextOptions} options - The options of the text.\n\t */\n\tconstructor(options?: CanvasTextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<TextStyle>);\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface ICanvas {\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\tresolution?: number;\n\t\t\tfailIfMajorPerformanceCaveat?: boolean;\n\t\t\troundPixels?: boolean;\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUOptions {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface RendererSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface CanvasSystems {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface RendererPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGLPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface WebGPUPipes {\n\t\t}\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\t\tinterface CanvasPipes {\n\t\t}\n\t}\n}\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions {\n\t/**\n\t * The GraphicsContext to use, useful for reuse and optimisation\n\t * If not provided, a new GraphicsContext will be created.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcontext?: GraphicsContext;\n\t/**\n\t * Whether or not to round the x/y position.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\troundPixels?: boolean;\n}\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {\n}\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction {\n\t/**\n\t * Creates a new Graphics object.\n\t * @param options - Options for the Graphics.\n\t */\n\tconstructor(options?: GraphicsOptions | GraphicsContext);\n\tset context(context: GraphicsContext);\n\t/**\n\t * The underlying graphics context used for drawing operations.\n\t * Controls how shapes and paths are rendered.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget context(): GraphicsContext;\n\t/**\n\t * The local bounds of the graphics object.\n\t * Returns the boundaries after all graphical operations but before any transforms.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget bounds(): Bounds;\n\t/**\n\t * Checks if the object contains the given point.\n\t * Returns true if the point lies within the Graphics object's rendered area.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param point - The point to check in local coordinates\n\t * @returns True if the point is inside the Graphics object\n\t */\n\tcontainsPoint(point: PointData): boolean;\n\t/**\n\t * Destroys this graphics renderable and optionally its context.\n\t * @param options - Options parameter. A boolean will act as if all options\n\t *\n\t * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n\t * then the context will still be destroyed.\n\t *\n\t * If you want to explicitly not destroy this context that this graphics created,\n\t * then you should pass destroy({ context: false })\n\t *\n\t * If the context was passed in as an argument to the constructor then it will not be destroyed\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tdestroy(options?: DestroyOptions): void;\n\t/**\n\t * Sets the current fill style of the graphics context.\n\t * The fill style can be a color, gradient, pattern, or a complex style object.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param {FillInput} args - The fill style to apply\n\t * @returns The Graphics instance for chaining\n\t */\n\tsetFillStyle(...args: Parameters<GraphicsContext[\"setFillStyle\"]>): this;\n\t/**\n\t * Sets the current stroke style of the graphics context.\n\t * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param {StrokeInput} args - The stroke style to apply\n\t * @returns The Graphics instance for chaining\n\t */\n\tsetStrokeStyle(...args: Parameters<GraphicsContext[\"setStrokeStyle\"]>): this;\n\t/**\n\t * Fills the current or given path with the current fill style or specified style.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param {FillInput} style - The style to fill the path with. Can be:\n\t * - A ColorSource\n\t * - A gradient\n\t * - A pattern\n\t * - A complex style object\n\t * If omitted, uses current fill style.\n\t * @returns The Graphics instance for chaining\n\t */\n\tfill(style?: FillInput): this;\n\t/** @deprecated 8.0.0 */\n\tfill(color: ColorSource, alpha?: number): this;\n\t/**\n\t * Strokes the current path with the current stroke style or specified style.\n\t * Outlines the shape using the stroke settings.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n\t * - A stroke style object with width, color, etc.\n\t * - A gradient\n\t * - A pattern\n\t * If omitted, uses current stroke style.\n\t * @returns The Graphics instance for chaining\n\t */\n\tstroke(...args: Parameters<GraphicsContext[\"stroke\"]>): this;\n\t/**\n\t * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n\t * including basic textures, tinted textures, and textures with custom dimensions.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* Basic texture drawing:\n\t * @param texture - The Texture object to use.\n\t * @returns The instance of the current Graphics for chaining.\n\t *\n\t * Extended texture drawing:\n\t * @param texture - The Texture object to use.\n\t *        tint - A ColorSource to tint the texture (defaults to white).\n\t *        dx - The x-coordinate for the texture placement.\n\t *        dy - The y-coordinate for the texture placement.\n\t *        dw - The width to draw the texture (defaults to texture width).\n\t *        dh - The height to draw the texture (defaults to texture height).\n\t * @returns The instance of the current Graphics for chaining.\n\t */\n\ttexture(texture: Texture): this;\n\ttexture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n\t/**\n\t * Resets the current path. Any previous path and its commands are discarded and a new path is\n\t * started. This is typically called before beginning a new shape or series of drawing commands.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for chaining\n\t */\n\tbeginPath(): this;\n\t/**\n\t * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n\t * subtracting a path from the previously drawn path.\n\t *\n\t * If a hole is not completely in a shape, it will fail to cut correctly.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcut(): this;\n\t/**\n\t * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n\t * starting and ending angles, and direction.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the arc's center\n\t * @param y - The y-coordinate of the arc's center\n\t * @param radius - The arc's radius (must be positive)\n\t * @param startAngle - The starting point of the arc, in radians\n\t * @param endAngle - The end point of the arc, in radians\n\t * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n\t *                          If false (default), draws clockwise.\n\t * @returns The Graphics instance for method chaining\n\t */\n\tarc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n\t/**\n\t * Adds an arc to the current path that connects two points using a radius.\n\t * The arc is drawn between the current point and the specified end point,\n\t * using the given control point to determine the curve of the arc.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x1 - The x-coordinate of the control point\n\t * @param y1 - The y-coordinate of the control point\n\t * @param x2 - The x-coordinate of the end point\n\t * @param y2 - The y-coordinate of the end point\n\t * @param radius - The radius of the arc in pixels (must be positive)\n\t * @returns The Graphics instance for method chaining\n\t */\n\tarcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n\t/**\n\t * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n\t * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param rx - The x-radius of the ellipse (must be non-negative)\n\t * @param ry - The y-radius of the ellipse (must be non-negative)\n\t * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n\t * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n\t * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n\t *                    a positive angle direction (1) or negative (0)\n\t * @param x - The x-coordinate of the arc's end point\n\t * @param y - The y-coordinate of the arc's end point\n\t * @returns The Graphics instance for method chaining\n\t */\n\tarcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n\t/**\n\t * Adds a cubic BÃ©zier curve to the path, from the current point to the specified end point.\n\t * The curve is influenced by two control points that define its shape and curvature.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param cp1x - The x-coordinate of the first control point\n\t * @param cp1y - The y-coordinate of the first control point\n\t * @param cp2x - The x-coordinate of the second control point\n\t * @param cp2y - The y-coordinate of the second control point\n\t * @param x - The x-coordinate of the end point\n\t * @param y - The y-coordinate of the end point\n\t * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n\t * @returns The Graphics instance for method chaining\n\t */\n\tbezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Closes the current path by drawing a straight line back to the start point.\n\t *\n\t * This is useful for completing shapes and ensuring they are properly closed for fills.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for method chaining\n\t */\n\tclosePath(): this;\n\t/**\n\t * Draws an ellipse at the specified location and with the given x and y radii.\n\t * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the center of the ellipse\n\t * @param y - The y-coordinate of the center of the ellipse\n\t * @param radiusX - The horizontal radius of the ellipse\n\t * @param radiusY - The vertical radius of the ellipse\n\t * @returns The Graphics instance for method chaining\n\t */\n\tellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n\t/**\n\t * Draws a circle shape at the specified location with the given radius.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the center of the circle\n\t * @param y - The y-coordinate of the center of the circle\n\t * @param radius - The radius of the circle\n\t * @returns The Graphics instance for method chaining\n\t */\n\tcircle(x: number, y: number, radius: number): this;\n\t/**\n\t * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n\t * This allows for reuse of complex paths and shapes across different graphics instances.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param path - The `GraphicsPath` to add to the current path\n\t * @returns The Graphics instance for method chaining\n\t */\n\tpath(path: GraphicsPath): this;\n\t/**\n\t * Connects the current point to a new point with a straight line.\n\t * Any subsequent drawing commands will start from this new point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the line's end point\n\t * @param y - The y-coordinate of the line's end point\n\t * @returns The Graphics instance for method chaining\n\t */\n\tlineTo(x: number, y: number): this;\n\t/**\n\t * Sets the starting point for a new sub-path.\n\t *\n\t * Moves the \"pen\" to a new location without drawing a line.\n\t * Any subsequent drawing commands will start from this point.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate to move to\n\t * @param y - The y-coordinate to move to\n\t * @returns The Graphics instance for method chaining\n\t */\n\tmoveTo(x: number, y: number): this;\n\t/**\n\t * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n\t * The starting point is the last point in the current path.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param cpx - The x-coordinate of the control point\n\t * @param cpy - The y-coordinate of the control point\n\t * @param x - The x-coordinate of the end point\n\t * @param y - The y-coordinate of the end point\n\t * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n\t * @returns The Graphics instance for method chaining\n\t */\n\tquadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle shape.\n\t *\n\t * This method adds a new rectangle path to the current drawing.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param w - The width of the rectangle\n\t * @param h - The height of the rectangle\n\t * @returns The Graphics instance for method chaining\n\t */\n\trect(x: number, y: number, w: number, h: number): this;\n\t/**\n\t * Draws a rectangle with rounded corners. The corner radius can be specified to\n\t * determine how rounded the corners should be.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param w - The width of the rectangle\n\t * @param h - The height of the rectangle\n\t * @param radius - The radius of the rectangle's corners (must be non-negative)\n\t * @returns The Graphics instance for method chaining\n\t */\n\troundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n\t/**\n\t * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n\t * which can be both open and closed.\n\t *\n\t * An optional transformation can be applied, enabling the polygon to be scaled,\n\t * rotated, or translated as needed.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n\t *                representing the vertices of the polygon in sequence\n\t * @param close - Whether to close the polygon path by connecting the last point to the first.\n\t *               Default is true.\n\t * @returns The Graphics instance for method chaining\n\t */\n\tpoly(points: number[] | PointData[], close?: boolean): this;\n\t/**\n\t * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n\t * making shapes like triangles, squares, pentagons, etc.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the center of the polygon\n\t * @param y - The y-coordinate of the center of the polygon\n\t * @param radius - The radius of the circumscribed circle of the polygon\n\t * @param sides - The number of sides of the polygon (must be 3 or more)\n\t * @param rotation - The rotation angle of the polygon in radians (default: 0)\n\t * @param transform - Optional Matrix to transform the polygon's shape\n\t * @returns The Graphics instance for method chaining\n\t */\n\tregularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n\t/**\n\t * Draws a polygon with rounded corners.\n\t *\n\t * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the center of the polygon\n\t * @param y - The y-coordinate of the center of the polygon\n\t * @param radius - The radius of the circumscribed circle of the polygon\n\t * @param sides - The number of sides of the polygon (must be 3 or more)\n\t * @param corner - The radius of the corner rounding (must be non-negative)\n\t * @param rotation - The rotation angle of the polygon in radians (default: 0)\n\t * @returns The Graphics instance for method chaining\n\t */\n\troundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n\t/**\n\t * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n\t * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param points - An array of `RoundedPoint` representing the corners of the shape.\n\t *                Each point can have its own radius or use the default.\n\t *                A minimum of 3 points is required.\n\t * @param radius - The default radius for corners without a specific radius defined.\n\t *                Applied to any point that doesn't specify its own radius.\n\t * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n\t *                      of arcs, creating a different visual style. Defaults to false.\n\t * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n\t *                    is true. Values range from 0-1, higher values create smoother curves.\n\t * @returns The Graphics instance for method chaining\n\t */\n\troundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n\t/**\n\t * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n\t * radii which create external rounded corners rather than internal ones.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param width - The width of the rectangle\n\t * @param height - The height of the rectangle\n\t * @param fillet - The radius of the corner fillets (can be positive or negative)\n\t * @returns The Graphics instance for method chaining\n\t */\n\tfilletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n\t/**\n\t * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n\t * a 45-degree angle based on the chamfer size.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the top-left corner of the rectangle\n\t * @param y - The y-coordinate of the top-left corner of the rectangle\n\t * @param width - The width of the rectangle\n\t * @param height - The height of the rectangle\n\t * @param chamfer - The size of the corner chamfers (must be non-zero)\n\t * @param transform - Optional Matrix to transform the rectangle\n\t * @returns The Graphics instance for method chaining\n\t */\n\tchamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n\t/**\n\t * Draws a star shape centered at a specified location. This method allows for the creation\n\t * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n\t *\n\t * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n\t * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The x-coordinate of the center of the star\n\t * @param y - The y-coordinate of the center of the star\n\t * @param points - The number of points on the star (must be >= 3)\n\t * @param radius - The outer radius of the star (distance from center to point tips)\n\t * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n\t *                     If not specified, defaults to half of the outer radius\n\t * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n\t *                  which aligns one point straight up\n\t * @returns The Graphics instance for method chaining\n\t */\n\tstar(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n\t/**\n\t * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n\t * and paths defined in SVG format to be drawn within the graphics context.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param svg - The SVG string to be parsed and rendered\n\t * @returns The Graphics instance for method chaining\n\t */\n\tsvg(svg: string): this;\n\t/**\n\t * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n\t * This includes transformations, fill styles, and stroke styles.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for method chaining\n\t */\n\trestore(): this;\n\t/**\n\t * Saves the current graphics state onto a stack. The state includes:\n\t * - Current transformation matrix\n\t * - Current fill style\n\t * - Current stroke style\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for method chaining\n\t */\n\tsave(): this;\n\t/**\n\t * Returns the current transformation matrix of the graphics context.\n\t * This matrix represents all accumulated transformations including translate, scale, and rotate.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The current transformation matrix.\n\t */\n\tgetTransform(): Matrix;\n\t/**\n\t * Resets the current transformation matrix to the identity matrix, effectively removing\n\t * any transformations (rotation, scaling, translation) previously applied.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for method chaining\n\t */\n\tresetTransform(): this;\n\t/**\n\t * Applies a rotation transformation to the graphics context around the current origin.\n\t * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param angle - The angle of rotation in radians\n\t * @returns The Graphics instance for method chaining\n\t */\n\trotateTransform(angle: number): this;\n\t/**\n\t * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n\t * and by y vertically relative to the current origin.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The scale factor in the horizontal direction\n\t * @param y - The scale factor in the vertical direction. If omitted, equals x\n\t * @returns The Graphics instance for method chaining\n\t */\n\tscaleTransform(x: number, y?: number): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context.\n\t *\n\t * This method can either\n\t * take a Matrix object or individual transform values to create a new transformation matrix.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param transform - The matrix to set as the current transformation matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(transform: Matrix): this;\n\t/**\n\t * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n\t * This replaces the current transformation matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\tsetTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\tsetTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n\t/**\n\t * Applies a transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix. This allows for complex transformations\n\t * combining multiple operations.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param transform - The matrix to apply to the current transformation.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(transform: Matrix): this;\n\t/**\n\t * Applies the specified transformation matrix to the current graphics context by multiplying\n\t * the current matrix with the specified matrix.\n\t * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n\t * @param b - The value for the b property of the matrix.\n\t * @param c - The value for the c property of the matrix.\n\t * @param d - The value for the d property of the matrix.\n\t * @param dx - The value for the tx (translate x) property of the matrix.\n\t * @param dy - The value for the ty (translate y) property of the matrix.\n\t * @returns The instance of the current GraphicsContext for method chaining.\n\t */\n\ttransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n\ttransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n\t/**\n\t * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n\t * This affects all subsequent drawing operations.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param x - The amount to translate in the horizontal direction\n\t * @param y - The amount to translate in the vertical direction. If omitted, equals x\n\t * @returns The Graphics instance for method chaining\n\t */\n\ttranslateTransform(x: number, y?: number): this;\n\t/**\n\t * Clears all drawing commands from the graphics context, effectively resetting it.\n\t * This includes clearing the current path, fill style, stroke style, and transformations.\n\t *\n\t * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n\t * > Instead, they are intended to be used for static or semi-static graphics that\n\t * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @returns The Graphics instance for method chaining\n\t */\n\tclear(): this;\n\t/**\n\t * Gets or sets the current fill style for the graphics context. The fill style determines\n\t * how shapes are filled when using the fill() method.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @type {ConvertedFillStyle}\n\t */\n\tget fillStyle(): GraphicsContext[\"fillStyle\"];\n\tset fillStyle(value: FillInput);\n\t/**\n\t * Gets or sets the current stroke style for the graphics context. The stroke style determines\n\t * how paths are outlined when using the stroke() method.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tget strokeStyle(): GraphicsContext[\"strokeStyle\"];\n\tset strokeStyle(value: StrokeStyle);\n\t/**\n\t * Creates a new Graphics object that copies the current graphics content.\n\t * The clone can either share the same context (shallow clone) or have its own independent\n\t * context (deep clone).\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @param deep - Whether to create a deep clone of the graphics object.\n\t *              If false (default), the context will be shared between objects.\n\t *              If true, creates an independent copy of the context.\n\t * @returns A new Graphics instance with either shared or copied context\n\t */\n\tclone(deep?: boolean): Graphics;\n\t/**\n\t * @param width\n\t * @param color\n\t * @param alpha\n\t * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n\t */\n\tlineStyle(width?: number, color?: ColorSource, alpha?: number): this;\n\t/**\n\t * @param color\n\t * @param alpha\n\t * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n\t */\n\tbeginFill(color: ColorSource, alpha?: number): this;\n\t/**\n\t * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n\t */\n\tendFill(): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n\t */\n\tdrawCircle(...args: Parameters<GraphicsContext[\"circle\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n\t */\n\tdrawEllipse(...args: Parameters<GraphicsContext[\"ellipse\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n\t */\n\tdrawPolygon(...args: Parameters<GraphicsContext[\"poly\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n\t */\n\tdrawRect(...args: Parameters<GraphicsContext[\"rect\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n\t */\n\tdrawRoundedRect(...args: Parameters<GraphicsContext[\"roundRect\"]>): this;\n\t/**\n\t * @param {...any} args\n\t * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n\t */\n\tdrawStar(...args: Parameters<GraphicsContext[\"star\"]>): this;\n}\ninterface GeometryData {\n\tvertices: number[];\n\tuvs: number[];\n\tindices: number[];\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tgraphicsContext: GraphicsContextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\tgraphics: GraphicsPipe;\n\t\t}\n\t\tinterface RendererOptions {\n\t\t\t/**\n\t\t\t * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n\t\t\t * @default 0.5\n\t\t\t */\n\t\t\tbezierSmoothness: number;\n\t\t}\n\t}\n}\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\n/**\n * The Mask type represents different ways to mask a display object.\n * - A number represents a mask ID.\n * - A Container represents a mask object, such as a Graphics or Sprite.\n * - null indicates that no mask is applied.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport type Mask = number | Container | null;\n/**\n * Options for configuring mask behavior on a display object.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface MaskOptions {\n\t/**\n\t * Whether the mask should be inverted.\n\t * When true, the masked area becomes transparent and the unmasked area becomes visible.\n\t * @default false\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tinverse: boolean;\n}\n/**\n * MaskOptionsAndMask combines MaskOptions with a Mask for configuring masking behavior.\n * Used when setting up complex masking effects with additional options.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface MaskOptionsAndMask extends MaskOptions {\n\t/**\n\t * The mask to apply, which can be a Container or null.\n\t *\n\t * If null, it clears the existing mask.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic x position\n\t * const circle = new Circle();\n\t * circle.x = 100;\n\t *\n\t * // Center circle on point\n\t * circle.x = point.x;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic y position\n\t * const circle = new Circle();\n\t * circle.y = 200;\n\t *\n\t * // Center circle on point\n\t * circle.y = point.y;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic radius setting\n\t * const circle = new Circle(100, 100);\n\t * circle.radius = 50;\n\t *\n\t * // Calculate area\n\t * const area = Math.PI * circle.radius * circle.radius;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check shape type\n\t * const shape = new Circle(0, 0, 50);\n\t * console.log(shape.type); // 'circle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'circle') {\n\t *     console.log(shape.radius);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic circle cloning\n\t * const original = new Circle(100, 100, 50);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.radius = 75;\n\t *\n\t * // Verify independence\n\t * console.log(original.radius); // 50\n\t * console.log(modified.radius); // 75\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const circle = new Circle(100, 100, 50);\n\t * const isInside = circle.contains(120, 120);\n\t *\n\t * // Check mouse position\n\t * const circle = new Circle(0, 0, 100);\n\t * container.hitArea = circle;\n\t * container.on('pointermove', (e) => {\n\t *     // only called if pointer is within circle\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stroke check\n\t * const circle = new Circle(100, 100, 50);\n\t * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic bounds calculation\n\t * const circle = new Circle(100, 100, 50);\n\t * const bounds = circle.getBounds();\n\t * // bounds: x=50, y=50, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * circle.getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Circle(100, 100, 50);\n\t * const target = new Circle();\n\t * target.copyFrom(source);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Circle(100, 100, 50);\n\t * const target = new Circle();\n\t * source.copyTo(target);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic x position\n\t * const ellipse = new Ellipse();\n\t * ellipse.x = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic y position\n\t * const ellipse = new Ellipse();\n\t * ellipse.y = 200;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set half width\n\t * const ellipse = new Ellipse(100, 100);\n\t * ellipse.halfWidth = 50; // Total width will be 100\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set half height\n\t * const ellipse = new Ellipse(100, 100);\n\t * ellipse.halfHeight = 25; // Total height will be 50\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check shape type\n\t * const shape = new Ellipse(0, 0, 50, 25);\n\t * console.log(shape.type); // 'ellipse'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'ellipse') {\n\t *     console.log(shape.halfWidth, shape.halfHeight);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic cloning\n\t * const original = new Ellipse(100, 100, 50, 25);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.halfWidth *= 2;\n\t * modified.halfHeight *= 2;\n\t *\n\t * // Verify independence\n\t * console.log(original.halfWidth);  // 50\n\t * console.log(modified.halfWidth);  // 100\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const isInside = ellipse.contains(120, 110);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stroke check\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic bounds calculation\n\t * const ellipse = new Ellipse(100, 100, 50, 25);\n\t * const bounds = ellipse.getBounds();\n\t * // bounds: x=50, y=75, width=100, height=50\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * ellipse.getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Ellipse(100, 100, 50, 25);\n\t * const target = new Ellipse();\n\t * target.copyFrom(source);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Ellipse(100, 100, 50, 25);\n\t * const target = new Ellipse();\n\t * source.copyTo(target);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic x position\n\t * const rect = new RoundedRectangle();\n\t * rect.x = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic y position\n\t * const rect = new RoundedRectangle();\n\t * rect.y = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic width setting\n\t * const rect = new RoundedRectangle();\n\t * rect.width = 200; // Total width will be 200\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic height setting\n\t * const rect = new RoundedRectangle();\n\t * rect.height = 150; // Total height will be 150\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic radius setting\n\t * const rect = new RoundedRectangle(0, 0, 200, 150);\n\t * rect.radius = 20;\n\t *\n\t * // Clamp to maximum safe radius\n\t * rect.radius = Math.min(rect.width, rect.height) / 2;\n\t *\n\t * // Create pill shape\n\t * rect.radius = rect.height / 2;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check shape type\n\t * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n\t * console.log(shape.type); // 'roundedRectangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'roundedRectangle') {\n\t *     console.log(shape.radius);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic bounds calculation\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const bounds = rect.getBounds();\n\t * // bounds: x=100, y=100, width=200, height=150\n\t *\n\t * // Reuse existing rectangle\n\t * const out = new Rectangle();\n\t * rect.getBounds(out);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic cloning\n\t * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.radius = 30;\n\t * modified.width *= 2;\n\t *\n\t * // Verify independence\n\t * console.log(original.radius);  // 20\n\t * console.log(modified.radius);  // 30\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const target = new RoundedRectangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const rect = new RoundedRectangle()\n\t *     .copyFrom(source)\n\t *     .getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const target = new RoundedRectangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new RoundedRectangle())\n\t *     .getBounds();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const isInside = rect.contains(150, 125); // true\n\t * // Check corner radius\n\t * const corner = rect.contains(100, 100); // false if within corner curve\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stroke check\n\t * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n\t * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n\t * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n\t * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n *",
      "language": "ts"
    },
    {
      "code": "* // Access points directly\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n\t *\n\t * // Modify points\n\t * polygon.points[0] = 10; // Move first x coordinate\n\t * polygon.points[1] = 10; // Move first y coordinate\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create open polygon\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * polygon.closePath = false;\n\t *\n\t * // Check path state\n\t * if (polygon.closePath) {\n\t *     // Last point connects to first\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check shape type\n\t * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(shape.type); // 'polygon'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'polygon') {\n\t *     // TypeScript knows this is a Polygon\n\t *     console.log(shape.points.length);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check polygon winding\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * console.log(polygon.isClockwise()); // Check direction\n\t *\n\t * // Use in path construction\n\t * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n\t * if (hole.isClockwise() === shape.isClockwise()) {\n\t *     hole.points.reverse(); // Reverse for proper hole winding\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n\t * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n\t *\n\t * outerSquare.containsPolygon(innerSquare); // Returns true\n\t * innerSquare.containsPolygon(outerSquare); // Returns false\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic cloning\n\t * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.points[0] = 10; // Modify first x coordinate\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const isInside = polygon.contains(25, 25); // true\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stroke check\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n\t * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n\t * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic bounds calculation\n\t * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const bounds = polygon.getBounds();\n\t * // bounds: x=0, y=0, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * polygon.getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const target = new Polygon();\n\t * target.copyFrom(source);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n\t * const target = new Polygon();\n\t * source.copyTo(target);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.lastX); // 300\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.lastY); // 400\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.x); // 0\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic coordinate access\n\t * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n\t * console.log(polygon.y); // 0\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic triangle creation\n * const triangle = new Triangle(0, 0, 100, 0, 50, 50);\n * // Use as hit area\n * container.hitArea = new Triangle(0, 0, 100, 0, 50, 100);\n * // Check point containment\n * const isInside = triangle.contains(mouseX, mouseY);\n * // Get bounding box\n * const bounds = triangle.getBounds();\n *",
      "language": "ts"
    },
    {
      "code": "* // Check shape type\n\t * const shape = new Triangle(0, 0, 100, 0, 50, 100);\n\t * console.log(shape.type); // 'triangle'\n\t *\n\t * // Use in type guards\n\t * if (shape.type === 'triangle') {\n\t *     console.log(shape.x2, shape.y2);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set first point x position\n\t * const triangle = new Triangle();\n\t * triangle.x = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set first point y position\n\t * const triangle = new Triangle();\n\t * triangle.y = 100;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create horizontal line for second point\n\t * const triangle = new Triangle(0, 0);\n\t * triangle.x2 = triangle.x + 100; // 100 units to the right\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create vertical line for second point\n\t * const triangle = new Triangle(0, 0);\n\t * triangle.y2 = triangle.y + 100; // 100 units down\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create equilateral triangle\n\t * const triangle = new Triangle(0, 0, 100, 0);\n\t * triangle.x3 = 50;  // Middle point x\n\t * triangle.y3 = 86.6; // Height using sin(60Â°)\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create right triangle\n\t * const triangle = new Triangle(0, 0, 100, 0);\n\t * triangle.x3 = 0;   // Align with first point\n\t * triangle.y3 = 100; // 100 units down\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic containment check\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const isInside = triangle.contains(25, 25); // true\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic stroke check\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const isOnStroke = triangle.strokeContains(25, 25, 4); // 4px line width\n\t *\n\t * // Check with different alignments\n\t * const innerStroke = triangle.strokeContains(25, 25, 4, 1);   // Inside\n\t * const centerStroke = triangle.strokeContains(25, 25, 4, 0.5); // Centered\n\t * const outerStroke = triangle.strokeContains(25, 25, 4, 0);   // Outside\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic cloning\n\t * const original = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const copy = original.clone();\n\t *\n\t * // Clone and modify\n\t * const modified = original.clone();\n\t * modified.x3 = 75;\n\t * modified.y3 = 150;\n\t *\n\t * // Verify independence\n\t * console.log(original.y3);  // 100\n\t * console.log(modified.y3);  // 150\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const target = new Triangle();\n\t * target.copyFrom(source);\n\t *\n\t * // Chain with other operations\n\t * const triangle = new Triangle()\n\t *     .copyFrom(source)\n\t *     .getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic copying\n\t * const source = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const target = new Triangle();\n\t * source.copyTo(target);\n\t *\n\t * // Chain with other operations\n\t * const result = source\n\t *     .copyTo(new Triangle())\n\t *     .getBounds();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic bounds calculation\n\t * const triangle = new Triangle(0, 0, 100, 0, 50, 100);\n\t * const bounds = triangle.getBounds();\n\t * // bounds: x=0, y=0, width=100, height=100\n\t *\n\t * // Reuse existing rectangle\n\t * const rect = new Rectangle();\n\t * triangle.getBounds(rect);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic plane with default vertex density\n * const plane = new MeshPlane({\n *     texture: Assets.get('background.png')\n * });\n *\n * // High-detail plane for complex deformations\n * const detailedPlane = new MeshPlane({\n *     texture: Assets.get('landscape.jpg'),\n *     verticesX: 20,\n *     verticesY: 20\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic plane\n * const plane = new MeshPlane({\n *     texture: Assets.get('background.png'),\n *     verticesX: 10,\n *     verticesY: 10\n * });\n *\n * // Get the buffer for vertex positions.\n * const { buffer } = plane.geometry.getAttribute('aPosition');\n *\n * // Listen for animate update\n * let timer = 0;\n *\n * app.ticker.add(() =>\n * {\n *     // Randomize the vertices positions a bit to create movement.\n *     for (let i = 0; i < buffer.data.length; i++)\n *     {\n *         buffer.data[i] += Math.sin(timer / 10 + i) * 0.5;\n *     }\n *     buffer.update();\n *     timer++;\n * });\n *\n * // Change texture dynamically\n * plane.texture = Assets.get('newTexture.png');\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a plane that auto-resizes with texture changes\n\t * const plane = new MeshPlane({\n\t *     texture: Assets.get('small.png'),\n\t *     verticesX: 10,\n\t *     verticesY: 10\n\t * });\n\t *\n\t * // Plane will automatically resize to match new texture\n\t * plane.texture = Assets.get('large.png');\n\t *\n\t * // Disable auto-resizing to maintain original dimensions\n\t * plane.autoResize = false;\n\t *\n\t * // Plane keeps its size even with new texture\n\t * plane.texture = Assets.get('different.png');\n\t *\n\t * // Manually update geometry if needed\n\t * const geometry = plane.geometry as PlaneGeometry;\n\t * geometry.width = plane.texture.width;\n\t * geometry.height = plane.texture.height;\n\t * geometry.build();\n\t *",
      "language": "ts"
    },
    {
      "code": "* const plane = new MeshPlane({\n\t *     texture: Assets.get('initial.png'),\n\t *     verticesX: 10,\n\t *     verticesY: 10\n\t * });\n\t *\n\t * // Update texture and auto-resize geometry\n\t * plane.texture = Assets.get('larger.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a perspective mesh with a texture\n * const mesh = new PerspectiveMesh({\n *     texture: Texture.from('myImage.png'),\n *     verticesX: 20,\n *     verticesY: 20,\n *     // Define corners clockwise from top-left\n *     x0: 0,   y0: 0,    // Top-left\n *     x1: 100, y1: 20,   // Top-right (raised)\n *     x2: 100, y2: 100,  // Bottom-right\n *     x3: 0,   y3: 80    // Bottom-left (raised)\n * });\n *\n * // Create a skewed perspective\n * const skewedMesh = new PerspectiveMesh({\n *     texture: Texture.from('background.jpg'),\n *     verticesX: 15,     // More vertices for smoother perspective\n *     verticesY: 15,\n *     x0: 0,   y0: 30,   // Shifted top-left\n *     x1: 128, y1: 0,    // Raised top-right\n *     x2: 128, y2: 128,  // Normal bottom-right\n *     x3: 0,   y3: 98    // Shifted bottom-left\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a perspective mesh with a texture\n * const mesh = new PerspectiveMesh({\n *     texture: Texture.from('myImage.png'),\n *     verticesX: 20,\n *     verticesY: 20,\n *     // Define corners clockwise from top-left\n *     x0: 0,   y0: 0,    // Top-left\n *     x1: 100, y1: 20,   // Top-right (raised)\n *     x2: 100, y2: 100,  // Bottom-right\n *     x3: 0,   y3: 80    // Bottom-left (raised)\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Change defaults globally\n\t * PerspectiveMesh.defaultOptions = {\n\t *     ...PerspectiveMesh.defaultOptions,\n\t *     verticesX: 15,\n\t *     verticesY: 15,\n\t *     // Move top edge up for default skew\n\t *     y0: -20,\n\t *     y1: -20\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const mesh = new PerspectiveMesh({\n\t *     texture: Texture.from('initial.png'),\n\t * });\n\t *\n\t * // Update texture and maintain perspective\n\t * mesh.texture = Texture.from('newImage.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* const mesh = new PerspectiveMesh({\n\t *     texture: Texture.from('myImage.png'),\n\t * });\n\t *\n\t * // Create a basic perspective tilt\n\t * mesh.setCorners(\n\t *     0, 0,      // Top-left\n\t *     100, 20,   // Top-right (raised)\n\t *     100, 100,  // Bottom-right\n\t *     0, 80      // Bottom-left\n\t * );\n\t *\n\t * // Create a skewed billboard effect\n\t * mesh.setCorners(\n\t *     0, 30,     // Top-left (shifted down)\n\t *     128, 0,    // Top-right (raised)\n\t *     128, 128,  // Bottom-right\n\t *     0, 98      // Bottom-left (shifted up)\n\t * );\n\t *\n\t * // Animate perspective\n\t * app.ticker.add((delta) => {\n\t *     const time = performance.now() / 1000;\n\t *     const wave = Math.sin(time) * 20;\n\t *\n\t *     mesh.setCorners(\n\t *         0, wave,      // Top-left\n\t *         100, -wave,   // Top-right\n\t *         100, 100,     // Bottom-right\n\t *         0, 100        // Bottom-left\n\t *     );\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic rope with two points\n * const rope = new MeshRope({\n *     texture: Texture.from('snake.png'),\n *     points: [\n *         new Point(0, 0),\n *         new Point(100, 0)\n *     ]\n * });\n *\n * // Create a rope with high-quality texture scaling\n * const highQualityRope = new MeshRope({\n *     texture: Texture.from('rope-hd.png'),\n *     points: [\n *         new Point(0, 0),\n *         new Point(50, 25),\n *         new Point(100, 0)\n *     ],\n *     textureScale: 0.5  // Downscale HD texture for better quality\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a snake with multiple segments\n * const points = [];\n * for (let i = 0; i < 20; i++) {\n *     points.push(new Point(i * 50, 0));\n * }\n *\n * const snake = new MeshRope({\n *     texture: Texture.from('snake.png'),\n *     points,\n *     textureScale: 0.5\n * });\n *\n * // Animate the snake\n * app.ticker.add((delta) => {\n *     const time = performance.now() / 1000;\n *\n *     // Update points to create wave motion\n *     for (let i = 0; i < points.length; i++) {\n *         points[i].y = Math.sin(i * 0.5 + time) * 30;\n *         points[i].x = (i * 50) + Math.cos(i * 0.3 + time) * 20;\n *     }\n * });\n *\n * // Disable auto updates if manually updating\n * snake.autoUpdate = false;\n *",
      "language": "ts"
    },
    {
      "code": "* // Use default options globally\n\t * MeshRope.defaultOptions = {\n\t *     textureScale: 0.5  // Set higher quality texture scaling\n\t * };\n\t *\n\t * // Create rope with modified defaults\n\t * const rope = new MeshRope({\n\t *     texture: Texture.from('rope.png'),\n\t *     points: [\n\t *         new Point(0, 0),\n\t *         new Point(100, 0)\n\t *     ]\n\t * }); // Will use textureScale: 0.5\n\t *",
      "language": "ts"
    },
    {
      "code": "* const points = [];\n\t * for (let i = 0; i < 20; i++) {\n\t *     points.push(new Point(i * 50, 0));\n\t * }\n\t *\n\t * const rope = new MeshRope({\n\t *     texture: Texture.from('rope.png'),\n\t *     points\n\t * });\n\t *\n\t * // Auto-update (default)\n\t * app.ticker.add(() => {\n\t *     // Points will automatically update the rope\n\t *     for (let i = 0; i < points.length; i++) {\n\t *         points[i].y = Math.sin(i * 0.5 + performance.now() / 1000) * 30;\n\t *     }\n\t * });\n\t *\n\t * // Manual update\n\t * rope.autoUpdate = false;\n\t * app.ticker.add(() => {\n\t *     // Update points\n\t *     for (let i = 0; i < points.length; i++) {\n\t *         points[i].y = Math.sin(i * 0.5 + performance.now() / 1000) * 30;\n\t *     }\n\t *     // Manually trigger update\n\t *     (rope.geometry as RopeGeometry).update();\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic particle\n * const particle = new Particle({\n *     texture: Texture.from('particle.png'),\n *     x: 100,\n *     y: 100,\n *     scaleX: 0.5,\n *     scaleY: 0.5,\n *     rotation: Math.PI / 4,  // 45 degrees\n *     tint: 0xff0000,        // Red tint\n *     alpha: 0.8             // Slightly transparent\n * });\n *\n * // Modify particle properties\n * particle.x += 10;          // Move right\n * particle.rotation += 0.1;   // Rotate slightly\n * particle.alpha = 0.5;      // Change transparency\n *\n * // Use anchor points (0-1 range)\n * particle.anchorX = 0.5;    // Center horizontally\n * particle.anchorY = 0.5;    // Center vertically\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic red particle\n * const particle = new Particle({\n *     texture: Texture.from('particle.png'),\n *     tint: 0xff0000,\n *     alpha: 0.8\n * });\n *\n * // Create a scaled and rotated particle\n * const rotatedParticle = new Particle({\n *     texture: Texture.from('star.png'),\n *     x: 100,\n *     y: 100,\n *     scaleX: 2,\n *     scaleY: 2,\n *     rotation: Math.PI / 4,\n *     anchorX: 0.5,\n *     anchorY: 0.5\n * });\n *\n * // Use color strings for tint\n * const coloredParticle = new Particle({\n *     texture: Texture.from('circle.png'),\n *     tint: '#ff00ff',     // Magenta\n *     alpha: 0.5,          // Half transparent\n *     x: 200,\n *     y: 200\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* const particle = new Particle({\n *   texture,\n *   x: 100,\n *   y: 100,\n *   scaleX: 0.5,\n *   scaleY: 0.5,\n *   rotation: Math.PI / 2,\n *   color: 0xff0000,\n * });\n *",
      "language": "javascript"
    },
    {
      "code": "* // Override defaults globally\n\t * Particle.defaultOptions = {\n\t *     ...Particle.defaultOptions,\n\t *     anchorX: 0.5,\n\t *     anchorY: 0.5,\n\t *     alpha: 0.8\n\t * };\n\t *\n\t * // New particles use modified defaults\n\t * const centeredParticle = new Particle(texture);\n\t * console.log(centeredParticle.anchorX); // 0.5\n\t * console.log(centeredParticle.alpha); // 0.8\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.anchorX = 0.5; // Center horizontally\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.anchorY = 0.5; // Center vertically\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.x = 100; // Move right\n\t * particle.x += Math.sin(time) * 10; // Oscillate horizontally\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.y = 100; // Move down\n\t * particle.y += Math.cos(time) * 10; // Oscillate vertically\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.scaleX = 2; // Double width\n\t * particle.scaleX *= 0.9; // Shrink over time\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.scaleY = 2; // Double height\n\t * particle.scaleY *= 0.9; // Shrink over time\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.rotation = Math.PI; // 180 degrees\n\t * particle.rotation += 0.1; // Rotate slowly clockwise\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Usually set via tint and alpha properties\n\t * particle.tint = 0xff0000; // Red\n\t * particle.alpha = 0.5; // Half transparent\n\t * console.log(particle.color); // Combined RGBA value\n\t *",
      "language": "ts"
    },
    {
      "code": "* particle.texture = Texture.from('particle.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a semi-transparent particle\n\t * const particle = new Particle({\n\t *     texture: Texture.from('particle.png'),\n\t *     alpha: 0.5\n\t * });\n\t *\n\t * // Fade out\n\t * particle.alpha *= 0.9;\n\t *\n\t * // Fade in\n\t * particle.alpha = Math.min(particle.alpha + 0.1, 1);\n\t *\n\t * // Values are clamped to valid range\n\t * particle.alpha = 1.5; // Becomes 1.0\n\t * particle.alpha = -0.5; // Becomes 0.0\n\t *\n\t * // Animate transparency\n\t * app.ticker.add((delta) => {\n\t *     const time = performance.now() / 1000;\n\t *     particle.alpha = 0.5 + Math.sin(time) * 0.5; // Pulse between 0-1\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a red particle\n\t * const particle = new Particle({\n\t *     texture: Texture.from('particle.png'),\n\t *     tint: 0xff0000\n\t * });\n\t *\n\t * // Use CSS color strings\n\t * particle.tint = '#00ff00';  // Green\n\t * particle.tint = 'blue';     // Blue\n\t *\n\t * // Animate tint color\n\t * app.ticker.add(() => {\n\t *     const time = performance.now() / 1000;\n\t *\n\t *     // Cycle through hues\n\t *     const hue = (time * 50) % 360;\n\t *     particle.tint = `hsl(${hue}, 100%, 50%)`;\n\t * });\n\t *\n\t * // Reset to white (no tint)\n\t * particle.tint = 0xffffff;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a particle container with dynamic position and rotation\n * const container = new ParticleContainer({\n *     dynamicProperties: {\n *         position: true,  // Update positions each frame\n *         rotation: true,  // Update rotations each frame\n *         vertex: false,   // Static vertices\n *         uvs: false,     // Static texture coordinates\n *         color: false     // Static colors\n *     }\n * });\n *\n * // Create a fully dynamic particle container\n * const dynamicContainer = new ParticleContainer({\n *     dynamicProperties: {\n *         vertex: true,    // Dynamic mesh deformation\n *         position: true,  // Dynamic movement\n *         rotation: true,  // Dynamic spinning\n *         uvs: true,      // Dynamic texture animation\n *         color: true     // Dynamic coloring\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic particle container\n * const container = new ParticleContainer({\n *     texture: Texture.from('particle.png'),\n *     particles: [\n *         new Particle(texture),\n *         new Particle(texture)\n *     ],\n *     dynamicProperties: {\n *         position: true,  // Update positions each frame\n *         rotation: true   // Update rotations each frame\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* import { ParticleContainer, Particle } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let particle = new Particle(texture);\n *     container.addParticle(particle);\n * }\n *",
      "language": "ts"
    },
    {
      "code": "* // Change defaults globally\n\t * ParticleContainer.defaultOptions = {\n\t *     dynamicProperties: {\n\t *         position: true,  // Update positions each frame\n\t *         rotation: true,  // Update rotations each frame\n\t *         vertex: false,   // Static vertices\n\t *         uvs: false,      // Static texture coordinates\n\t *         color: false     // Static colors\n\t *     },\n\t *     roundPixels: true // Enable pixel rounding for crisp rendering\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new ParticleContainer();\n\t *\n\t * // Add particles directly to the array\n\t * container.particleChildren.push(\n\t *     new Particle(texture),\n\t *     new Particle(texture)\n\t * );\n\t * container.update(); // Required after direct modification\n\t *\n\t * // Modify existing particles\n\t * container.particleChildren.forEach(particle => {\n\t *     particle.position.x += 10;\n\t * });\n\t *\n\t * // Remove particles\n\t * container.particleChildren.length = 0; // Clear all\n\t * container.update();\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new ParticleContainer();\n\t * // Set texture for all particles\n\t * container.texture = Texture.from('particle.png');\n\t *\n\t * // Create particles using container's texture\n\t * for (let i = 0; i < 100; i++) {\n\t *     const particle = new Particle(container.texture);\n\t *     container.addParticle(particle); // Will use the particles texture if not set\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new ParticleContainer();\n\t *\n\t * // Add a single particle\n\t * const particle = new Particle(Assets.get('particleTexture'));\n\t * container.addParticle(particle);\n\t *\n\t * // Add multiple particles at once\n\t * const particles = [\n\t *     new Particle(Assets.get('particleTexture')),\n\t *     new Particle(Assets.get('particleTexture')),\n\t *     new Particle(Assets.get('particleTexture'))\n\t * ];\n\t *\n\t * container.addParticle(...particles);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Remove a single particle\n\t * container.removeParticle(particle1);\n\t *\n\t * // Remove multiple particles at once\n\t * container.removeParticle(particle2, particle3);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Batch modify particles\n\t * container.particleChildren.push(...particles);\n\t * container.update(); // Required after direct array modification\n\t *\n\t * // Update static properties\n\t * container.particleChildren.forEach(particle => {\n\t *     particle.position.set(\n\t *         Math.random() * 800,\n\t *         Math.random() * 600\n\t *     );\n\t * });\n\t * container.update(); // Required after changing static positions\n\t *",
      "language": "ts"
    },
    {
      "code": "* const container = new ParticleContainer({\n\t *     texture: Texture.from('particle.png')\n\t * });\n\t *\n\t * // Default bounds are empty\n\t * console.log(container.bounds); // Bounds(0, 0, 0, 0)\n\t *\n\t * // Set manual bounds for the particle area\n\t * container.boundsArea = {\n\t *     minX: 0,\n\t *     minY: 0,\n\t *     maxX: 800,\n\t *     maxY: 600\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic animated sprite\n * const sprite = new AnimatedSprite({\n *     textures: [\n *         Texture.from('walk1.png'),\n *         Texture.from('walk2.png'),\n *         Texture.from('walk3.png')\n *     ],\n *     animationSpeed: 0.1,\n *     loop: true\n * });\n *\n * // Create with spritesheet frames and callbacks\n * const sheet = await Assets.load('character.json');\n * const animatedSprite = new AnimatedSprite({\n *     textures: sheet.animations['walk'],\n *     autoPlay: true,\n *     updateAnchor: true,\n *     onComplete: () => console.log('Animation complete'),\n *     onFrameChange: (frame) => console.log('Current frame:', frame),\n *     onLoop: () => console.log('Animation looped')\n * });\n *\n * // Create with custom timing for each frame\n * const customTimingSprite = new AnimatedSprite({\n *     textures: [\n *         { texture: Texture.from('frame1.png'), time: 100 },\n *         { texture: Texture.from('frame2.png'), time: 200 },\n *         { texture: Texture.from('frame3.png'), time: 300 }\n *     ],\n *     autoUpdate: true\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create an AnimatedSprite with a slower animation speed\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     animationSpeed: 0.5 // Slower animation\n\t * });\n\t *\n\t * // Update the animation speed to make it faster\n\t * animation.animationSpeed = 2; // Faster animation\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an AnimatedSprite that starts playing immediately\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoPlay: true\n\t * });\n\t *\n\t * // Create an AnimatedSprite that does not start playing immediately\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoPlay: false\n\t * });\n\t * animation.play(); // Start the animation manually\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an AnimatedSprite that does not auto update\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     autoUpdate: false\n\t * });\n\t *\n\t * // Manually update the animation in your game loop\n\t * ticker.add((ticker) => {\n\t *     animation.update(ticker);\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* animation.onComplete = () => {\n\t *     // Finished!\n\t *     console.log('Animation complete');\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* animation.onFrameChange = (currentFrame) => {\n\t *     // Updated!\n\t *     console.log('Current frame:', currentFrame);\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* animation.onLoop = () => {\n\t *     // Looped!\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an AnimatedSprite with an array of textures\n\t * const animation = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ]\n\t * });\n\t * * // Create an AnimatedSprite with an array of frame objects\n\t * const animation = new AnimatedSprite({\n\t *     textures: [\n\t *         { texture: Texture.from('frame1.png'), time: 100 },\n\t *         { texture: Texture.from('frame2.png'), time: 200 },\n\t *         { texture: Texture.from('frame3.png'), time: 300 }\n\t *     ]\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an AnimatedSprite with updateAnchor enabled\n\t * const animation = new AnimatedSprite({\n\t *     textures: [Texture.from('frame1.png'), Texture.from('frame2.png')],\n\t *     updateAnchor: true\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n *",
      "language": "js"
    },
    {
      "code": "* import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n *",
      "language": "js"
    },
    {
      "code": "* // Create a sprite with normal speed animation\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     animationSpeed: 1 // Default speed\n\t * });\n\t *\n\t * // Slow down the animation\n\t * sprite.animationSpeed = 0.5;\n\t *\n\t * // Speed up the animation\n\t * sprite.animationSpeed = 2;\n\t *\n\t * // Reverse the animation\n\t * sprite.animationSpeed = -1;\n\t *\n\t * // Stop the animation\n\t * sprite.animationSpeed = 0;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a looping animation\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     loop: true // Will repeat\n\t * });\n\t *\n\t * // Play animation once\n\t * sprite.loop = false;\n\t * sprite.onComplete = () => console.log('Animation finished!');\n\t * sprite.play();\n\t *\n\t * // Toggle looping at runtime\n\t * sprite.loop = !sprite.loop;\n\t *",
      "language": "ts"
    },
    {
      "code": "* animation.onComplete = () => {\n\t *     // Finished!\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ],\n\t *     autoPlay: true\n\t * });\n\t *\n\t * // Stop at current frame\n\t * sprite.stop();\n\t *\n\t * // Stop at specific frame\n\t * sprite.gotoAndStop(1); // Stops at second frame\n\t *\n\t * // Stop and reset\n\t * sprite.stop();\n\t * sprite.currentFrame = 0;\n\t *\n\t * // Stop with completion check\n\t * if (sprite.playing) {\n\t *     sprite.stop();\n\t *     sprite.onComplete?.();\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic playback\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *     ],\n\t *     autoPlay: false\n\t * });\n\t * sprite.play();\n\t *\n\t * // Play after stopping\n\t * sprite.stop();\n\t * sprite.currentFrame = 0; // Reset to start\n\t * sprite.play(); // Play from beginning\n\t *\n\t * // Play with auto-update disabled\n\t * sprite.autoUpdate = false;\n\t * sprite.play();\n\t * app.ticker.add(() => {\n\t *     sprite.update(app.ticker); // Manual updates\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png'),\n\t *     ]\n\t * });\n\t *\n\t * // Go to specific frames\n\t * sprite.gotoAndStop(0);  // First frame\n\t * sprite.gotoAndStop(2);  // Third frame\n\t *\n\t * // Jump to last frame\n\t * sprite.gotoAndStop(sprite.totalFrames - 1);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Start from specific frame\n\t * sprite.gotoAndPlay(1); // Starts playing from second frame\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an animated sprite with manual updates\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ],\n\t *     autoUpdate: false // Disable automatic updates\n\t * });\n\t *\n\t * // Manual update with app ticker\n\t * app.ticker.add((ticker) => {\n\t *     sprite.update(ticker);\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Destroy the sprite when done\n\t * sprite.destroy();\n\t * // Or with options\n\t * sprite.destroy({ children: true, texture: true, textureSource: true });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create from frame IDs\n\t * const frameIds = [\n\t *     'walk_001.png',\n\t *     'walk_002.png',\n\t *     'walk_003.png'\n\t * ];\n\t *\n\t * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);\n\t * walkingAnimation.play();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create from image URLs\n\t * const images = [\n\t *     'assets/walk1.png',\n\t *     'assets/walk2.png',\n\t *     'assets/walk3.png'\n\t * ];\n\t *\n\t * const walkingSprite = AnimatedSprite.fromImages(images);\n\t * walkingSprite.play();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('frame1.png'),\n\t *         Texture.from('frame2.png'),\n\t *         Texture.from('frame3.png')\n\t *     ]\n\t * });\n\t *\n\t * // Get total frames\n\t * console.log(sprite.totalFrames); // Outputs: 3\n\t *\n\t * // Use with frame navigation\n\t * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Update textures at runtime\n\t * sprite.textures = [\n\t *     Texture.from('run1.png'),\n\t *     Texture.from('run2.png')\n\t * ];\n\t *\n\t * // Use custom frame timing\n\t * sprite.textures = [\n\t *     { texture: Texture.from('explosion1.png'), time: 100 },\n\t *     { texture: Texture.from('explosion2.png'), time: 200 },\n\t *     { texture: Texture.from('explosion3.png'), time: 300 }\n\t * ];\n\t *\n\t * // Use with spritesheet\n\t * const sheet = await Assets.load('animations.json');\n\t * sprite.textures = sheet.animations['walk'];\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create an animated sprite\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [\n\t *         Texture.from('walk1.png'),\n\t *         Texture.from('walk2.png'),\n\t *         Texture.from('walk3.png')\n\t *     ]\n\t * });\n\t *\n\t * // Get current frame\n\t * console.log(sprite.currentFrame); // 0\n\t *\n\t * // Set specific frame\n\t * sprite.currentFrame = 1; // Show second frame\n\t *\n\t * // Use with frame callbacks\n\t * sprite.onFrameChange = (frame) => {\n\t *     console.log(`Now showing frame: ${frame}`);\n\t * };\n\t * sprite.currentFrame = 2;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Check if animation is playing\n\t * console.log('Playing:', sprite.playing); // true\n\t *\n\t * // Use with play control\n\t * if (!sprite.playing) {\n\t *     sprite.play();\n\t * }\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create sprite with auto-update disabled\n\t * const sprite = new AnimatedSprite({\n\t *     textures: [],\n\t *     autoUpdate: false\n\t * });\n\t *\n\t * // Manual update with app ticker\n\t * app.ticker.add((ticker) => {\n\t *     sprite.update(ticker);\n\t * });\n\t *\n\t * // Enable auto-update later\n\t * sprite.autoUpdate = true;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic nine-slice sprite\n * const button = new NineSliceSprite({\n *     texture: Texture.from('button.png'),\n *     leftWidth: 20, // Left border (A)\n *     rightWidth: 20, // Right border (B)\n *     topHeight: 20, // Top border (C)\n *     bottomHeight: 20, // Bottom border (D)\n *     width: 100, // Initial width\n *     height: 50, // Initial height\n *     anchor: 0.5, // Center anchor point\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a sprite with a texture\n\t * const sprite = new NineSliceSprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., leftWidth: 20 });\n\t * sprite.leftWidth = 20; // Set left border width\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., topHeight: 20 });\n\t * sprite.topHeight = 20; // Set top border height\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., rightWidth: 20 });\n\t * sprite.rightWidth = 20; // Set right border width\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });\n\t * sprite.bottomHeight = 20; // Set bottom border height\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., width: 200 });\n\t * sprite.width = 200; // Set the width of the sprite\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., height: 100 });\n\t * sprite.height = 100; // Set the height of the sprite\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., roundPixels: true });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Centered anchor\n\t * const sprite = new NineSliceSprite({ ..., anchor: 0.5 });\n\t * sprite.anchor = 0.5;\n\t * // Separate x/y anchor\n\t * sprite.anchor = { x: 0.5, y: 0.5 };\n\t * // Right-aligned anchor\n\t * sprite.anchor = { x: 1, y: 0 };\n\t * // Update anchor directly\n\t * sprite.anchor.set(0.5, 0.5);\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { NineSliceSprite, Texture } from 'pixi.js';\n *\n * const plane9 = new NineSliceSprite({\n *   texture: Texture.from('BoxWithRoundedCorners.png'),\n *   leftWidth: 15,\n *   topHeight: 15,\n *   rightWidth: 15,\n *   bottomHeight: 15,\n *   width: 200,\n *   height: 100,\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Override default options globally\n\t * NineSliceSprite.defaultOptions.texture = Texture.from('defaultButton.png');\n\t * // Create sprite with default texture\n\t * const sprite = new NineSliceSprite({...});\n\t * // sprite will use 'defaultButton.png' as its texture\n\t *\n\t * // Reset to empty texture\n\t * NineSliceSprite.defaultOptions.texture = Texture.EMPTY;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a nine-slice sprite with fixed width\n\t * const panel = new NineSliceSprite({\n\t *     texture: Texture.from('panel.png'),\n\t *     width: 200  // Sets initial width\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * panel.width = 300;  // Stretches middle sections\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a nine-slice sprite with fixed height\n\t * const panel = new NineSliceSprite({\n\t *     texture: Texture.from('panel.png'),\n\t *     height: 150  // Sets initial height\n\t * });\n\t *\n\t * // Adjust height dynamically\n\t * panel.height = 200;  // Stretches middle sections\n\t *\n\t * // Create responsive UI element\n\t * const dialog = new NineSliceSprite({\n\t *     texture: Texture.from('dialog.png'),\n\t *     topHeight: 30,\n\t *     bottomHeight: 30,\n\t *     height: parent.height * 0.5  // 50% of parent height\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set to specific dimensions\n\t * panel.setSize(300, 200); // Width: 300, Height: 200\n\t *\n\t * // Set uniform size\n\t * panel.setSize(200); // Makes a square 200x200\n\t *\n\t * // Set size using object\n\t * panel.setSize({\n\t *     width: 400,\n\t *     height: 300\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get basic size\n\t * const size = panel.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * panel.getSize(reuseSize);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., leftWidth: 20 });\n\t * sprite.leftWidth = 20; // Set left border width\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., topHeight: 20 });\n\t * sprite.topHeight = 20; // Set top border height\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., rightWidth: 20 });\n\t * sprite.rightWidth = 20; // Set right border width\n\t *",
      "language": "ts"
    },
    {
      "code": "* const sprite = new NineSliceSprite({ ..., bottomHeight: 20 });\n\t * sprite.bottomHeight = 20; // Set bottom border height\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a sprite with a texture\n\t * const sprite = new NineSliceSprite({\n\t *     texture: Texture.from('path/to/image.png')\n\t * });\n\t * // Update the texture later\n\t * sprite.texture = Texture.from('path/to/another-image.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get original dimensions\n\t * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n\t *\n\t * // Use for relative scaling\n\t * sprite.width = sprite.originalWidth * 2; // Double the original width\n\t *\n\t * // Reset to original size\n\t * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get original dimensions\n\t * console.log(`Original size: ${sprite.originalWidth}x${sprite.originalHeight}`);\n\t *\n\t * // Use for relative scaling\n\t * sprite.height = sprite.originalHeight * 2; // Double the original height\n\t *\n\t * // Reset to original size\n\t * sprite.setSize(sprite.originalWidth, sprite.originalHeight);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic transform usage\n * const transform = new Transform();\n * transform.position.set(100, 100);\n * transform.rotation = Math.PI / 4; // 45 degrees\n * transform.scale.set(2, 2);\n *\n * // With pivot point\n * transform.pivot.set(50, 50);\n * transform.rotation = Math.PI; // Rotate around pivot\n *\n * // Matrix manipulation\n * const matrix = transform.matrix;\n * const position = { x: 0, y: 0 };\n * matrix.apply(position); // Transform point\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic position setting\n\t * transform.position.set(100, 100);\n\t *\n\t * // Individual coordinate access\n\t * transform.position.x = 50;\n\t * transform.position.y = 75;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Uniform scaling\n\t * transform.scale.set(2, 2);\n\t *\n\t * // Non-uniform scaling\n\t * transform.scale.x = 2; // Stretch horizontally\n\t * transform.scale.y = 0.5; // Compress vertically\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center pivot\n\t * transform.pivot.set(sprite.width / 2, sprite.height / 2);\n\t *\n\t * // Corner rotation\n\t * transform.pivot.set(0, 0);\n\t * transform.rotation = Math.PI / 4; // 45 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Apply horizontal skew\n\t * transform.skew.x = Math.PI / 6; // 30 degrees\n\t *\n\t * // Apply both skews\n\t * transform.skew.set(Math.PI / 6, Math.PI / 8);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get current matrix\n\t * const matrix = transform.matrix;\n\t * console.log(matrix.toString());\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic matrix decomposition\n\t * const transform = new Transform();\n\t * const matrix = new Matrix()\n\t *     .translate(100, 100)\n\t *     .rotate(Math.PI / 4)\n\t *     .scale(2, 2);\n\t *\n\t * transform.setFromMatrix(matrix);\n\t * console.log(transform.position.x); // 100\n\t * console.log(transform.rotation); // ~0.785 (Ï€/4)\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic rotation\n\t * transform.rotation = Math.PI / 4; // 45 degrees\n\t *\n\t * // Rotate around pivot point\n\t * transform.pivot.set(50, 50);\n\t * transform.rotation = Math.PI; // 180 degrees around pivot\n\t *\n\t * // Animate rotation\n\t * app.ticker.add(() => {\n\t *     transform.rotation += 0.1;\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a basic tiling sprite with repeating texture\n * const tilingSprite = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 800,     // Width of the tiling area\n *     height: 600     // Height of the tiling area\n * });\n *\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tilePosition: { x: 0, y: 0 },\n *     tileScale: { x: 1.5, y: 1.5 }  // Scale up the texture\n *     anchor: 0.5,                    // Center anchor point\n *     roundPixels: true,              // Crisp pixel rendering\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Centered anchor\n\t * const sprite = new TilingSprite({ ..., anchor: 0.5 });\n\t * sprite.anchor = 0.5;\n\t * // Separate x/y anchor\n\t * sprite.anchor = { x: 0.5, y: 0.5 };\n\t * // Right-aligned anchor\n\t * sprite.anchor = { x: 1, y: 0 };\n\t * // Update anchor directly\n\t * sprite.anchor.set(0.5, 0.5);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Offset the tiling pattern by 100 pixels in both x and y directions\n\t * tilingSprite.tilePosition = { x: 100, y: 100 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Scale the texture by 1.5 in both x and y directions\n\t * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Rotate the texture by 45 degrees (in radians)\n\t * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Use a texture from the asset cache\n\t * tilingSprite.texture = Texture.from('assets/pattern.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set the width of the tiling sprite to 800 pixels\n\t * tilingSprite.width = 800;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set the height of the tiling sprite to 600 pixels\n\t * tilingSprite.height = 600;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Enable anchor-based tiling\n\t * tilingSprite.applyAnchorToTexture = true;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Enable pixel rounding for crisp rendering\n\t * tilingSprite.roundPixels = true;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a simple tiling background\n * const background = new TilingSprite({\n *     texture: Texture.from('background.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n * });\n * app.stage.addChild(background);\n *\n * // Create a scrolling parallax background\n * const parallax = new TilingSprite({\n *     texture: Texture.from('clouds.png'),\n *     width: app.screen.width,\n *     height: app.screen.height,\n *     tileScale: { x: 0.5, y: 0.5 }\n * });\n *\n * // Animate the tiling position\n * app.ticker.add(() => {\n *     parallax.tilePosition.x -= 1; // Scroll left\n *     parallax.tilePosition.y -= 0.5; // Scroll up slowly\n * });\n *\n * // Create a repeating pattern with rotation\n * const pattern = new TilingSprite({\n *     texture: Texture.from('pattern.png'),\n *     width: 300,\n *     height: 200,\n *     tileRotation: Math.PI / 4, // 45 degree rotation\n *     anchor: 0.5 // Center anchor point\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Create a new tiling sprite from an image path\n\t * const pattern = TilingSprite.from('pattern.png');\n\t * pattern.width = 300; // Set the width of the tiling area\n\t * pattern.height = 200; // Set the height of the tiling area\n\t *\n\t * // Create from options\n\t * const texture = Texture.from('pattern.png');\n\t * const pattern = TilingSprite.from(texture, {\n\t *     width: 300,\n\t *     height: 200,\n\t *     tileScale: { x: 0.5, y: 0.5 }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Override default options globally\n\t * TilingSprite.defaultOptions.texture = Texture.from('defaultPattern.png');\n\t * TilingSprite.defaultOptions.tileScale = { x: 2, y: 2 };\n\t *\n\t * // Create sprite using default options\n\t * const sprite = new TilingSprite();\n\t * // Will use defaultPattern.png and scale 2x\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Enable anchor-based tiling\n\t * tilingSprite.applyAnchorToTexture = true;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center the anchor point\n\t * sprite.anchor = 0.5; // Sets both x and y to 0.5\n\t * sprite.position.set(400, 300); // Sprite will be centered at this position\n\t *\n\t * // Set specific x/y anchor points\n\t * sprite.anchor = {\n\t *     x: 1, // Right edge\n\t *     y: 0  // Top edge\n\t * };\n\t *\n\t * // Using individual coordinates\n\t * sprite.anchor.set(0.5, 1); // Center-bottom\n\t *\n\t * // For rotation around center\n\t * sprite.anchor.set(0.5);\n\t * sprite.rotation = Math.PI / 4; // 45 degrees around center\n\t *\n\t * // For scaling from center\n\t * sprite.anchor.set(0.5);\n\t * sprite.scale.set(2); // Scales from center point\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Offset the tiling pattern by 100 pixels in both x and y directions\n\t * tilingSprite.tilePosition = { x: 100, y: 100 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Scale the texture by 1.5 in both x and y directions\n\t * tilingSprite.tileScale = { x: 1.5, y: 1.5 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Rotate the texture by 45 degrees (in radians)\n\t * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Use a texture from the asset cache\n\t * tilingSprite.texture = Texture.from('assets/pattern.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * sprite.width = 800; // Expands tiling area\n\t *\n\t * // Update on resize\n\t * window.addEventListener('resize', () => {\n\t *     sprite.width = app.screen.width;\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t *\n\t * // Adjust width dynamically\n\t * sprite.height = 800; // Expands tiling area\n\t *\n\t * // Update on resize\n\t * window.addEventListener('resize', () => {\n\t *     sprite.height = app.screen.height;\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Set specific dimensions\n\t * sprite.setSize(300, 200); // Width: 300, Height: 200\n\t *\n\t * // Set uniform size (square)\n\t * sprite.setSize(400); // Width: 400, Height: 400\n\t *\n\t * // Set size using object\n\t * sprite.setSize({\n\t *     width: 500,\n\t *     height: 300\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Get basic size\n\t * const size = sprite.getSize();\n\t * console.log(`Size: ${size.width}x${size.height}`);\n\t *\n\t * // Reuse existing size object\n\t * const reuseSize = { width: 0, height: 0 };\n\t * sprite.getSize(reuseSize);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Create a tiling sprite\n\t * const sprite = new TilingSprite({\n\t *     texture: Texture.from('pattern.png'),\n\t *     width: 200,\n\t *     height: 100,\n\t *     anchor: 0.5 // Center anchor\n\t * });\n\t *\n\t * // Basic point check\n\t * const contains = sprite.containsPoint({ x: 50, y: 25 });\n\t * console.log('Point is inside:', contains);\n\t *\n\t * // Check with different anchors\n\t * sprite.anchor.set(0); // Top-left anchor\n\t * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic resolved asset\n * const asset: ResolvedAsset = {\n *     alias: ['hero'],\n *     src: 'hero.png',\n *     format: 'png'\n * };\n *\n * // Resolved asset with multiple aliases\n * const asset: ResolvedAsset = {\n *     alias: ['character', 'player'],\n *     src: 'character@2x.webp',\n *     format: 'webp',\n * };\n *\n * // Resolved asset with specific parser\n * const asset: ResolvedAsset = {\n *     alias: ['config'],\n *     src: 'data.txt',\n *     format: 'txt',\n *     parser: 'text'\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Single URL string\n * const src: AssetSrc = 'images/sprite.png';\n *\n * // Multiple format options\n * const src: AssetSrc = ['sprite.webp', 'sprite.png'];\n *\n * // With format pattern\n * const src: AssetSrc = 'sprite.{webp,png}';\n *\n * // Resolved source with options\n * const src: AssetSrc = {\n *     src: 'sprite.png',\n *     format: 'png',\n *     parser: 'texture',\n *     data: {\n *         scaleMode: 'nearest',\n *     }\n * };\n *\n * // Array of resolved sources\n * const src: AssetSrc = [\n *     {\n *         src: 'sprite@2x.webp',\n *         format: 'webp',\n *     },\n *     {\n *         src: 'sprite.png',\n *         format: 'png',\n *     }\n * ];\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic unresolved asset\n * const asset: UnresolvedAsset = {\n *     alias: 'hero',\n *     src: 'hero.png'\n * };\n *\n * // Multiple aliases and formats\n * const asset: UnresolvedAsset = {\n *     alias: ['hero', 'player'],\n *     src: 'hero.{webp,png}',\n *     data: {\n *         scaleMode: 'nearest',\n *     }\n * };\n *\n * // Asset with multiple sources and formats\n * const asset: UnresolvedAsset = {\n *     alias: 'background',\n *     src: [\n *         'bg@2x.webp',\n *         'bg@1x.webp',\n *         'bg@2x.png',\n *         'bg@1x.png',\n *     ]\n * };\n *\n * // With specific loader\n * const asset: UnresolvedAsset = {\n *     alias: 'config',\n *     src: 'data.txt',\n *     parser: 'text'\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic bundle structure\n * const bundle: AssetsBundle = {\n *     name: 'level-1',\n *     assets: [\n *         {\n *             alias: 'background',\n *             src: 'level1/bg.{webp,png}'\n *         },\n *         {\n *             alias: 'sprites',\n *             src: 'level1/sprites.json'\n *         }\n *     ]\n * };\n *\n * // Using object format for assets\n * const bundle: AssetsBundle = {\n *     name: 'ui',\n *     assets: {\n *         button: 'ui/button.png',\n *         panel: 'ui/panel.png',\n *         icons: ['ui/icons.webp', 'ui/icons.png']\n *     }\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* const manifest: AssetsManifest = {\n *     bundles: [\n *         {\n *             name: 'loading',\n *             assets: [\n *                 {\n *                     alias: 'logo',\n *                     src: 'logo.{webp,png}',\n *                     data: { scaleMode: 'nearest' }\n *                 },\n *                 {\n *                     alias: 'progress-bar',\n *                     src: 'progress.png'\n *                 }\n *             ]\n *         },\n *         {\n *             name: 'game',\n *             assets: {\n *                 background: ['bg.webp', 'bg.png'],\n *                 character: 'hero.json',\n *                 music: 'theme.mp3'\n *             }\n *         }\n *     ]\n * };\n *\n * // Initialize with manifest\n * await Assets.init({ manifest });\n *\n * // Load bundles as needed\n * await Assets.loadBundle('loading');\n * await Assets.loadBundle('game');\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* await Assets.init({\n\t *     basePath: 'https://my-cdn.com/assets/'\n\t * });\n\t *\n\t * // Now you can load assets like this:\n\t * // Will load from: https://my-cdn.com/assets/images/sprite.png\n\t * const texture = await Assets.load('images/sprite.png');\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Using a manifest object\n\t * await Assets.init({\n\t *     manifest: {\n\t *         bundles: [{\n\t *             name: 'game-screen',\n\t *             assets: [\n\t *                 {\n\t *                     alias: 'hero',\n\t *                     src: 'hero.{png,webp}'\n\t *                 },\n\t *                 {\n\t *                     alias: 'map',\n\t *                     src: 'map.json'\n\t *                 }\n\t *             ]\n\t *         }]\n\t *     }\n\t * });\n\t *\n\t * // Using a URL to manifest\n\t * await Assets.init({\n\t *     manifest: 'assets/manifest.json'\n\t * });\n\t *\n\t * // loading a bundle from the manifest\n\t * await Assets.loadBundle('game-screen');\n\t *\n\t * // load individual assets from the manifest\n\t * const heroTexture = await Assets.load('hero');\n\t *",
      "language": "ts"
    },
    {
      "code": "* await Assets.init({\n\t *     texturePreference: {\n\t *         // Prefer high-res textures on retina displays\n\t *         resolution: window.devicePixelRatio,\n\t *\n\t *         // Prefer modern formats, fallback to traditional\n\t *         format: ['avif', 'webp', 'png']\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* await Assets.init({\n\t *     preferences: {\n\t *         crossOrigin: 'anonymous',\n\t *         parseAsGraphicsContext: false\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* await Assets.init({\n\t *    loadOptions: {\n\t *       onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`),\n\t *       onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`),\n\t *       strategy: 'retry',\n\t *       retryCount: 5,\n\t *       retryDelay: 500,\n\t *   }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n *",
      "language": "typescript"
    },
    {
      "code": "* await Assets.load(['file1.png', 'file2.png'], {\n *   onProgress: (progress) => console.log(`Progress: ${progress * 100}%`),\n *   onError: (error, url) => console.error(`Error loading ${url}: ${error.message}`),\n *   strategy: 'retry', // 'throw' | 'skip' | 'retry'\n *   retryCount: 5, // Number of retry attempts if strategy is 'retry'\n *   retryDelay: 500, // Delay in ms between retries\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* const options: LoadOptions = {\n\t *   onProgress: (progress) => {\n\t *     console.log(`Loading progress: ${progress * 100}%`);\n\t *   },\n\t * };\n\t * await Assets.load('image.png', options);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: LoadOptions = {\n\t *   onError: (error, url) => {\n\t *     console.error(`Failed to load ${url}: ${error.message}`);\n\t *   },\n\t * };\n\t * await Assets.load('missing-file.png', options);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: LoadOptions = {\n\t *   strategy: 'skip',\n\t * };\n\t * await Assets.load('sometimes-fails.png', options);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: LoadOptions = {\n\t *   strategy: 'retry',\n\t *   retryCount: 5, // Retry up to 5 times\n\t * };\n\t * await Assets.load('unstable-asset.png', options);\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: LoadOptions = {\n\t *   strategy: 'retry',\n\t *   retryDelay: 1000, // Wait 1 second between retries\n\t * };\n\t * await Assets.load('sometimes-fails.png', options);\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'MyCustomFont',\n\t *     style: { fontFamily: 'Arial' }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Different ways to specify characters\n\t * BitmapFont.install({\n\t *     name: 'RangeFont',\n\t *     chars: [\n\t *         ['a', 'z'],              // Range of characters\n\t *         '0123456789',            // String of characters\n\t *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n\t *     ]\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'HiDPIFont',\n\t *     resolution: window.devicePixelRatio || 2\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'PaddedFont',\n\t *     padding: 8 // More padding for better quality\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'FastFont',\n\t *     skipKerning: true // Prioritize performance\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'StyledFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 32,\n\t *         fill: 'white',\n\t *         stroke: { color: '#000000', width: 2 },\n\t *         dropShadow: {\n\t *             color: '#000000',\n\t *             blur: 2,\n\t *             distance: 3\n\t *         }\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* BitmapFont.install({\n\t *     name: 'CrispFont',\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest',\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Correct usage - white fill with tinting enabled\n\t * BitmapFont.install({\n\t *     name: 'TintableFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFFFFFF  // Must be white for tinting\n\t *     },\n\t *     dynamicFill: true\n\t * });\n\t *\n\t * // Use the font with different colors via tinting\n\t * const redText = new BitmapText({\n\t *     text: 'Red Text',\n\t *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n\t * });\n\t *\n\t * const blueText = new BitmapText({\n\t *     text: 'Blue Text',\n\t *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Incorrect usage - colored fill with tinting enabled\n\t * BitmapFont.install({\n\t *     name: 'BadTintFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFF0000  // âŒ Red fill won't tint properly\n\t *     },\n\t *     dynamicFill: true  // âŒ Will not work as expected\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Alternative - baked colors (no tinting)\n\t * BitmapFont.install({\n\t *     name: 'BakedColorFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: 0xFF0000,  // Any color works\n\t *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n\t *     },\n\t *     dynamicFill: false  // Color is baked in\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     // Font data containing character metrics and layout info\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *             // ... other characters\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         // Optional distance field info for MSDF/SDF fonts\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     // Array of textures containing the font glyphs\n *     textures: [\n *         Texture.from('font.png')\n *     ]\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     textures: [Texture.from('font.png')]\n * });\n *\n * // Install a font for global use\n * BitmapFont.install({\n *     name: 'MyCustomFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ffffff',\n *         stroke: { color: '#000000', width: 2 }\n *     }\n * });\n *\n * // Uninstall when no longer needed\n * BitmapFont.uninstall('MyCustomFont');\n *",
      "language": "ts"
    },
    {
      "code": "* console.log(font.url); // 'fonts/myFont.fnt'\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Install a basic font\n\t * BitmapFont.install({\n\t *     name: 'Title',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 32,\n\t *         fill: '#ffffff'\n\t *     }\n\t * });\n\t *\n\t * // Install with advanced options\n\t * BitmapFont.install({\n\t *     name: 'Custom',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *         fontSize: 24,\n\t *         fill: '#00ff00',\n\t *         stroke: { color: '#000000', width: 2 }\n\t *     },\n\t *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n\t *     resolution: 2,\n\t *     padding: 4,\n\t *     textureStyle: {\n\t *         scaleMode: 'nearest'\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Remove a font when it's no longer needed\n\t * BitmapFont.uninstall('MyCustomFont');\n\t *\n\t * // Clear multiple fonts\n\t * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { BitmapText, BitmapFont } from 'pixi.js';\n *\n * // Dynamic font generation\n * const dynamicText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Pre-installed font usage\n * BitmapFont.install({\n *    name: 'myFont',\n *    style: {\n *        fontFamily: 'Arial',\n *    }\n * });\n *\n * const preinstalledText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myFont',\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Load and use external bitmap font, if the font supports MSDF/SDF then it will be used\n * const font = await Assets.load('fonts/myFont.fnt');\n *\n * const loadedFontText = new BitmapText({\n *     text: 'Hello Pixi!',\n *     style: {\n *        fontFamily: 'myLoadedFont', // Name from .fnt file\n *        fontSize: 24,\n *        fill: 0xff1010,\n *        align: 'center',\n *     }\n * });\n *\n * // Multiline text with word wrap\n * const wrappedText = new BitmapText({\n *     text: 'This is a long text that will wrap automatically',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *     }\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* new BitmapText(options?: TextOptions);\n\t *",
      "language": "ts"
    },
    {
      "code": "* // âŒ Incorrect: Setting resolution directly (will trigger warning)\n\t * const text = new BitmapText({\n\t *     text: 'Hello',\n\t *     resolution: 2 // This will be ignored\n\t * });\n\t *\n\t * // âœ… Correct: Set resolution when installing the font\n\t * BitmapFont.install({\n\t *     name: 'MyFont',\n\t *     style: {\n\t *         fontFamily: 'Arial',\n\t *     },\n\t *     resolution: 2 // Resolution is set here\n\t * });\n\t *\n\t * const text = new BitmapText({\n\t *     text: 'Hello',\n\t *     style: {\n\t *         fontFamily: 'MyFont' // Uses font's resolution\n\t *     }\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const splitResult = Text.split(myText);\n *\n * // Access individual characters\n * splitResult.chars.forEach(char => {\n *     char.alpha = 0;\n *     gsap.to(char, { alpha: 1, duration: 0.5 });\n * });\n *\n * // Access words (groups of characters)\n * splitResult.words.forEach(word => {\n *     word.scale.set(0);\n *     gsap.to(word.scale, { x: 1, y: 1, duration: 0.5 });\n * });\n *\n * // Access lines (groups of words)\n * splitResult.lines.forEach(line => {\n *     line.x = -200;\n *     gsap.to(line, { x: 0, duration: 0.5 });\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* lineAnchor: 0.5        // Center horizontally and vertically\n\t * lineAnchor: { x: 0, y: 0.5 }  // Left-center alignment\n\t *\n\t *",
      "language": "ts"
    },
    {
      "code": "* wordAnchor: { x: 1, y: 0 }  // Top-right alignment\n\t * wordAnchor: 0.5  // Center alignment\n\t *",
      "language": "ts"
    },
    {
      "code": "* charAnchor: { x: 0.5, y: 1 }  // Bottom-center alignment\n\t * charAnchor: 0.5  // Center alignment\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: SplitTextOptions = {\n *   text: 'Hello World',\n *   style: { fontSize: 32, fill: 0xffffff },\n *   // Transform origins\n *   lineAnchor: 0.5,                // Center each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center each char\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* const options: SplitTextOptions = {\n *   // Text content and style\n *   text: 'Multi\\nLine Text',\n *   style: new TextStyle({\n *     fontSize: 24,\n *     fill: 'white',\n *     strokeThickness: 2,\n *   }),\n *\n *   // Container properties\n *   x: 100,\n *   y: 100,\n *   alpha: 0.8,\n *\n *   // Splitting settings\n *   autoSplit: true,\n *\n *   // Transform origins (normalized 0-1)\n *   lineAnchor: { x: 1, y: 0 },    // Top-right\n *   wordAnchor: 0.5,               // Center\n *   charAnchor: { x: 0, y: 1 },    // Bottom-left\n * };\n *",
      "language": "ts"
    },
    {
      "code": "* const text = new SplitText({\n *   text: \"Hello World\",\n *   style: { fontSize: 24 },\n *   // Origin points for transformations (0-1 range)\n *   lineAnchor: 0.5,  // Center of each line\n *   wordAnchor: { x: 0, y: 0.5 },  // Left-center of each word\n *   charAnchor: { x: 0.5, y: 1 },  // Bottom-center of each character\n *   autoSplit: true  // Auto-update segments on text/style changes\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Character fade-in sequence\n * text.chars.forEach((char, i) => {\n *   gsap.from(char, {\n *     alpha: 0,\n *     delay: i * 0.1\n *   });\n * });\n *\n * // Word scale animation\n * text.words.forEach((word, i) => {\n *   gsap.to(word.scale, {\n *     x: 1.2, y: 1.2,\n *     yoyo: true,\n *     repeat: -1,\n *     delay: i * 0.2\n *   });\n * });\n *\n * // Line slide-in effect\n * text.lines.forEach((line, i) => {\n *   gsap.from(line, {\n *     x: -200,\n *     delay: i * 0.3\n *   });\n * });\n *",
      "language": "ts"
    },
    {
      "code": "* // Fade in characters sequentially\n\t * text.chars.forEach((char, i) => {\n\t *   char.alpha = 0;\n\t *   gsap.to(char, {\n\t *     alpha: 1,\n\t *     delay: i * 0.1\n\t *   });\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Scale words on hover\n\t * text.words.forEach(word => {\n\t *   word.interactive = true;\n\t *   word.on('pointerover', () => {\n\t *     gsap.to(word.scale, { x: 1.2, y: 1.2 });\n\t *   });\n\t *   word.on('pointerout', () => {\n\t *     gsap.to(word.scale, { x: 1, y: 1 });\n\t *   });\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Stagger line entrance animations\n\t * text.lines.forEach((line, i) => {\n\t *   line.x = -200;\n\t *   gsap.to(line, {\n\t *     x: 0,\n\t *     duration: 0.5,\n\t *     delay: i * 0.2,\n\t *     ease: 'back.out'\n\t *   });\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const text = new SplitText({\n\t *   text: 'Manual Update',\n\t *   autoSplit: false\n\t * });\n\t *\n\t * text.text = 'New Content';\n\t * text.style = { fontSize: 32 };\n\t * text.split(); // Apply changes\n\t *",
      "language": "ts"
    },
    {
      "code": "* const text = new SplitText({\n\t *   text: 'Original',\n\t *   autoSplit: true\n\t * });\n\t *\n\t * // Auto-splits on change\n\t * text.text = 'Updated Content';\n\t *\n\t * // Manual update\n\t * text.autoSplit = false;\n\t * text.text = 'Manual Update';\n\t * text.split();\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center rotation/scaling\n\t * text.lineAnchor = 0.5;\n\t *\n\t * // Rotate/scale from top-right corner\n\t * text.lineAnchor = { x: 1, y: 0 };\n\t *\n\t * // Custom anchor point\n\t * text.lineAnchor = {\n\t *   x: 0.2, // 20% from left\n\t *   y: 0.8  // 80% from top\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center each word\n\t * text.wordAnchor = 0.5;\n\t *\n\t * // Scale from bottom-left\n\t * text.wordAnchor = { x: 0, y: 1 };\n\t *\n\t * // Rotate around custom point\n\t * text.wordAnchor = {\n\t *   x: 0.75,  // 75% from left\n\t *   y: 0.5    // Middle vertically\n\t * };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Center each character\n\t * text.charAnchor = 0.5;\n\t *\n\t * // Rotate from top-center\n\t * text.charAnchor = { x: 0.5, y: 0 };\n\t *\n\t * // Scale from bottom-right\n\t * text.charAnchor = { x: 1, y: 1 };\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Rotate characters around their centers\n\t * text.charAnchor = 0.5;\n\t * text.chars.forEach((char, i) => {\n\t *   gsap.to(char, {\n\t *     rotation: Math.PI * 2,\n\t *     duration: 1,\n\t *     delay: i * 0.1,\n\t *     repeat: -1\n\t *   });\n\t * });\n\t *",
      "language": "ts"
    },
    {
      "code": "* const text = new Text({\n\t *     text: 'Styled Text',\n\t *     style: {\n\t *         fontSize: 24,\n\t *         fill: 0xff1010, // Red color\n\t *         fontFamily: 'Arial',\n\t *         align: 'center', // Center alignment\n\t *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n\t *         dropShadow: {\n\t *             color: '#000000', // Black shadow\n\t *             blur: 4, // Shadow blur\n\t *             distance: 6 // Shadow distance\n\t *         }\n\t *     }\n\t * });\n\t * // Update style dynamically\n\t * text.style = {\n\t *     fontSize: 30, // Change font size\n\t *     fill: 0x00ff00, // Change color to green\n\t *     align: 'right', // Change alignment to right\n\t *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n\t * }\n\t */\n\tset style(style: TextStyle | Partial<TextStyle> | TextStyleOptions);\n\t/**\n\t * Destroys the SplitText instance and all its resources.\n\t * Cleans up all segment arrays, event listeners, and optionally the text style.\n\t * @param options - Destroy configuration options\n\t * @example\n\t *",
      "language": "ts"
    },
    {
      "code": "*/\n\tdestroy(options?: DestroyOptions): void;\n}\n/**\n * Configuration options for Text splitting.\n */\nexport interface SplitOptions extends AbstractSplitOptions {\n}\n/**\n * Configuration options for SplitText, combining container properties with text splitting settings.\n * @example Basic Usage\n *",
      "language": "unknown"
    },
    {
      "code": "* @example Advanced Configuration\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text splitting options from {@link SplitOptions}\n * - Additional PixiJS-specific options from PixiMixins.SplitText\n */\nexport interface SplitTextOptions extends PixiMixins.SplitText, ContainerOptions, SplitOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * Converts each segment into a separate Text object.\n * @example Basic Usage\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Features:\n * - Hierarchical text segmentation (lines â†’ words â†’ characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * @example Animation Example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n */\nexport declare class SplitText extends AbstractSplitText<Text$1> {\n\t/**\n\t * Default configuration options for SplitText instances.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic defaultOptions: Partial<SplitTextOptions>;\n\tconstructor(config: SplitTextOptions);\n\t/**\n\t * Creates a SplitText instance from an existing text object.\n\t * Useful for converting standard Text or Text objects into segmented versions.\n\t * @param text - The source text object to convert\n\t * @param options - Additional splitting options\n\t * @returns A new SplitText instance\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic from(text: Text$1, options?: Omit<SplitTextOptions, \"text\" | \"style\">): SplitText;\n}\n/**\n * Constructor options used for `HTMLText` instances. Extends the base text options\n * with HTML-specific features and texture styling capabilities.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport interface HTMLTextOptions extends TextOptions<HTMLTextStyle, HTMLTextStyleOptions>, PixiMixins.HTMLTextOptions {\n}\nexport interface HTMLText extends PixiMixins.HTMLText, AbstractText<HTMLTextStyle, HTMLTextStyleOptions, HTMLTextOptions, BatchableHTMLText> {\n}\n/**\n * A HTMLText object creates text using HTML/CSS rendering with SVG foreignObject.\n * This allows for rich text formatting using standard HTML tags and CSS styling.\n *\n * Key features:\n * - HTML tag support (<strong>, <em>, etc.)\n * - CSS styling and custom style overrides\n * - Emoji and special character support\n * - Line breaking and word wrapping\n * - SVG-based rendering\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Platform Considerations:\n * - Rendering may vary slightly between browsers\n * - Requires browser support for foreignObject\n * - Performance similar to Canvas text\n * - Memory usage comparable to Canvas text\n */\nexport declare class HTMLText extends AbstractText<HTMLTextStyle, HTMLTextStyleOptions, HTMLTextOptions, BatchableHTMLText> implements View {\n\t/**\n\t * @param {HTMLTextOptions} options - The options of the html text.\n\t */\n\tconstructor(options?: HTMLTextOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(text?: TextString, options?: Partial<HTMLTextStyle>);\n\tget text(): string;\n\t/**\n\t * The text content to display. Use '\\n' for line breaks.\n\t * Accepts strings, numbers, or objects with toString() method.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default ''\n\t */\n\tset text(text: TextString);\n}\n/**\n * Configuration options for BitmapText splitting.\n */\nexport interface SplitBitmapOptions extends AbstractSplitOptions {\n}\n/**\n * Configuration options for SplitBitmapText, combining container properties with text splitting settings.\n * @example Basic Usage\n *",
      "language": "unknown"
    },
    {
      "code": "* @example Advanced Configuration\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Properties:\n * - Container options from {@link ContainerOptions}\n * - Text splitting options from {@link SplitBitmapOptions}\n * - Additional PixiJS-specific options from PixiMixins.SplitBitmapText\n */\nexport interface SplitBitmapTextOptions extends PixiMixins.SplitBitmapText, ContainerOptions, SplitBitmapOptions {\n}\n/**\n * @experimental\n * A container that splits text into individually manipulatable segments (lines, words, and characters)\n * for advanced text effects and animations.\n * Converts each segment into a separate BitmapText object.\n * @example Basic Usage\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Features:\n * - Hierarchical text segmentation (lines â†’ words â†’ characters)\n * - Independent transformation origins for each segment level\n * - Automatic or manual segment updates\n * @example Animation Example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Configuration Options:\n * - `text`: The string to render and segment\n * - `style`: TextStyle instance or configuration object\n * - `autoSplit`: Automatically update segments on changes (default: true)\n * - `lineAnchor`: Transform origin for lines (default: 0)\n * - `wordAnchor`: Transform origin for words (default: 0)\n * - `charAnchor`: Transform origin for characters (default: 0)\n *\n * > [!NOTE] Anchor points are normalized (0-1):\n * > - 0,0: Top-left\n * > - 0.5,0.5: Center\n * > - 1,1: Bottom-right\n *\n * > [!WARNING] Limitations\n * > - Character spacing may differ slightly from standard text due to browser\n * >   kerning being lost when characters are separated\n */\nexport declare class SplitBitmapText extends AbstractSplitText<BitmapText> {\n\t/**\n\t * Default configuration options for SplitBitmapText instances.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic defaultOptions: Partial<SplitBitmapTextOptions>;\n\tconstructor(config: SplitBitmapTextOptions);\n\t/**\n\t * Creates a SplitBitmapText instance from an existing text object.\n\t * Useful for converting standard Text or BitmapText objects into segmented versions.\n\t * @param text - The source text object to convert\n\t * @param options - Additional splitting options\n\t * @returns A new SplitBitmapText instance\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic from(text: BitmapText, options?: Omit<SplitBitmapTextOptions, \"text\" | \"style\">): SplitBitmapText;\n}\ndeclare class CanvasTextGeneratorClass {\n\t/**\n\t * Creates a canvas with the specified text rendered to it.\n\t *\n\t * Generates a canvas of appropriate size, renders the text with the provided style,\n\t * and returns both the canvas/context and a Rectangle representing the text bounds.\n\t *\n\t * When trim is enabled in the style, the frame will represent the bounds of the\n\t * non-transparent pixels, which can be smaller than the full canvas.\n\t * @param options - The options for generating the text canvas\n\t * @param options.text - The text to render\n\t * @param options.style - The style to apply to the text\n\t * @param options.resolution - The resolution of the canvas (defaults to 1)\n\t * @param options.padding\n\t * @returns An object containing the canvas/context and the frame (bounds) of the text\n\t */\n\tgetCanvasAndContext(options: {\n\t\ttext: string;\n\t\tstyle: TextStyle;\n\t\tresolution?: number;\n\t\tpadding?: number;\n\t}): {\n\t\tcanvasAndContext: CanvasAndContext;\n\t\tframe: Rectangle;\n\t};\n\t/**\n\t * Returns a canvas and context to the pool.\n\t *\n\t * This should be called when you're done with the canvas to allow reuse\n\t * and prevent memory leaks.\n\t * @param canvasAndContext - The canvas and context to return to the pool\n\t */\n\treturnCanvasAndContext(canvasAndContext: CanvasAndContext): void;\n}\nexport interface Mesh extends PixiMixins.Mesh, ViewContainer<MeshGpuData> {\n}\ninterface MeshData {\n\t/** if the mesh is batched or not */\n\tbatched: boolean;\n\t/** the size of the index buffer */\n\tindexSize: number;\n\t/** the size of the vertex buffer */\n\tvertexSize: number;\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tmesh: MeshPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tparticle: ParticleContainerPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface Container<C extends ContainerChild = ContainerChild> extends ChildrenHelperMixin<C>, ToLocalGlobalMixin, OnRenderMixin, MeasureMixin, EffectsMixin, FindMixin, SortMixin, GetGlobalMixin, CollectRenderablesMixin, GetFastGlobalBoundsMixin, CacheAsTextureMixin {\n\t\t}\n\t\tinterface ContainerOptions extends OnRenderMixinConstructor, MeasureMixinConstructor, EffectsMixinConstructor, FindMixinConstructor, SortMixinConstructor, CacheAsTextureMixinConstructor {\n\t\t}\n\t\tinterface ViewContainer {\n\t\t}\n\t\tinterface ViewContainerOptions {\n\t\t}\n\t\tinterface Graphics {\n\t\t}\n\t\tinterface GraphicsOptions {\n\t\t}\n\t\tinterface Mesh {\n\t\t}\n\t\tinterface MeshOptions {\n\t\t}\n\t\tinterface ParticleContainer {\n\t\t}\n\t\tinterface ParticleContainerOptions {\n\t\t}\n\t\tinterface Sprite {\n\t\t}\n\t\tinterface SpriteOptions {\n\t\t}\n\t\tinterface AnimatedSprite {\n\t\t}\n\t\tinterface AnimatedSpriteOptions {\n\t\t}\n\t\tinterface NineSliceSprite {\n\t\t}\n\t\tinterface NineSliceSpriteOptions {\n\t\t}\n\t\tinterface TilingSprite {\n\t\t}\n\t\tinterface TilingSpriteOptions {\n\t\t}\n\t\tinterface Text {\n\t\t}\n\t\tinterface BitmapText {\n\t\t}\n\t\tinterface TextOptions {\n\t\t}\n\t\tinterface HTMLText {\n\t\t}\n\t\tinterface HTMLTextOptions {\n\t\t}\n\t\tinterface SplitText {\n\t\t}\n\t\tinterface SplitTextOptions {\n\t\t}\n\t\tinterface SplitBitmapText {\n\t\t}\n\t\tinterface SplitBitmapTextOptions {\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tnineSliceSprite: NineSliceSpritePipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\ttilingSprite: TilingSpritePipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererPipes {\n\t\t\tbitmapText: BitmapTextPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\thtmlText: HTMLTextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\thtmlText: HTMLTextPipe;\n\t\t}\n\t}\n}\ndeclare global {\n\tnamespace PixiMixins {\n\t\tinterface RendererSystems {\n\t\t\tcanvasText: CanvasTextSystem;\n\t\t}\n\t\tinterface RendererPipes {\n\t\t\ttext: CanvasTextPipe;\n\t\t}\n\t}\n}\n/**\n * The final color has the hue and saturation of the top color, while using the luminosity of the bottom color.\n * The effect preserves gray levels and can be used to colorize the foreground.\n *\n * Available as `container.blendMode = 'color'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color'\n */\nexport declare class ColorBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is the result of inverting the bottom color, dividing the value by the top color,\n * and inverting that value. A white foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a black final image.\n * This blend mode is similar to multiply, but the foreground need only be as dark as the inverse\n * of the backdrop to make the final image black.\n *\n * Available as `container.blendMode = 'color-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-burn'\n */\nexport declare class ColorBurnBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is the result of dividing the bottom color by the inverse of the top color.\n * A black foreground leads to no change.\n * A foreground with the inverse color of the backdrop leads to a fully lit color.\n * This blend mode is similar to screen, but the foreground need only be as light as the inverse of the backdrop to create a fully lit color.\n *\n * Available as `container.blendMode = 'color-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-dodge'\n */\nexport declare class ColorDodgeBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is composed of the darkest values of each color channel.\n *\n * Available as `container.blendMode = 'darken'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'darken'\n */\nexport declare class DarkenBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is the result of subtracting the darker of the two colors from the lighter one.\n * black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'difference'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'difference'\n */\nexport declare class DifferenceBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The Divide blend mode divides the RGB channel values of the bottom layer by those of the top layer.\n * The darker the top layer, the brighter the bottom layer will appear.\n * Blending any color with black yields white, and blending with white has no effect\n *\n * Available as `container.blendMode = 'divide'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'divide'\n */\nexport declare class DivideBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is similar to difference, but with less contrast.\n * As with difference, a black layer has no effect, while a white layer inverts the other layer's color.\n *\n * Available as `container.blendMode = 'exclusion'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'exclusion'\n */\nexport declare class ExclusionBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is the result of multiply if the top color is darker, or screen if the top color is lighter.\n * This blend mode is equivalent to overlay but with the layers swapped.\n * The effect is similar to shining a harsh spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'hard-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-light'\n */\nexport declare class HardLightBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Hard defines each of the color channel values of the blend color to the RGB values of the base color.\n * If the sum of a channel is 255, it receives a value of 255; if less than 255, a value of 0.\n *\n * Available as `container.blendMode = 'hard-mix'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'hard-mix'\n */\nexport declare class HardMixBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is composed of the lightest values of each color channel.\n *\n * Available as `container.blendMode = 'lighten'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'lighten'\n */\nexport declare class LightenBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'linear-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-burn'\n */\nexport declare class LinearBurnBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Looks at the color information in each channel and brightens the base color to reflect the blend color by decreasing contrast between the two.\n *\n * Available as `container.blendMode = 'linear-dodge'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-dodge'\n */\nexport declare class LinearDodgeBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Increase or decrease brightness by burning or dodging color values, based on the blend color\n *\n * Available as `container.blendMode = 'linear-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'linear-light'\n */\nexport declare class LinearLightBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color has the luminosity of the top color, while using the hue and saturation of the bottom color.\n * This blend mode is equivalent to color, but with the layers swapped.\n *\n * Available as `container.blendMode = 'luminosity'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'luminosity'\n */\nexport declare class LuminosityBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Implements the Negation blend mode which creates an inverted effect based on the brightness values.\n *\n * Available as `container.blendMode = 'negation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'negation'\n */\nexport declare class NegationBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is the result of multiply if the bottom color is darker, or screen if the bottom color is lighter.\n * This blend mode is equivalent to hard-light but with the layers swapped.\n *\n * Available as `container.blendMode = 'overlay'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'overlay'\n */\nexport declare class OverlayBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Replaces colors based on the blend color.\n *\n * Available as `container.blendMode = 'pin-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'pin-light'\n */\nexport declare class PinLightBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color has the saturation of the top color, while using the hue and luminosity of the bottom color.\n * A pure gray backdrop, having no saturation, will have no effect.\n *\n * Available as `container.blendMode = 'saturation'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'saturation'\n */\nexport declare class SaturationBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * The final color is similar to hard-light, but softer. This blend mode behaves similar to hard-light.\n * The effect is similar to shining a diffused spotlight on the backdrop.\n *\n * Available as `container.blendMode = 'soft-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'soft-light'\n */\nexport declare class SoftLightBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Subtracts the blend from the base color using each color channel\n *\n * Available as `container.blendMode = 'subtract'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'subtract'\n */\nexport declare class SubtractBlend extends BlendModeFilter {\n\tconstructor();\n}\n/**\n * Darkens values darker than 50% gray and lightens those brighter than 50% gray, creating a dramatic effect.\n * It's essentially an extreme version of the Overlay mode, with a significant impact on midtones\n *\n * Available as `container.blendMode = 'vivid-light'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'vivid-light'\n */\nexport declare class VividLightBlend extends BlendModeFilter {\n\tconstructor();\n}\ntype LoadVideoData = VideoSourceOptions & {\n\tmime?: string;\n};\ndeclare class WorkerManagerClass {\n\tconstructor();\n\t/**\n\t * Checks if ImageBitmap is supported in the current environment.\n\t *\n\t * This method uses a dedicated worker to test ImageBitmap support\n\t * and caches the result for subsequent calls.\n\t * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise\n\t */\n\tisImageBitmapSupported(): Promise<boolean>;\n\t/**\n\t * Loads an image as an ImageBitmap using a web worker.\n\t * @param src - The source URL or path of the image to load\n\t * @param asset - Optional resolved asset containing additional texture source options\n\t * @returns Promise that resolves to the loaded ImageBitmap\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tloadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>;\n\t/**\n\t * Resets the worker manager, terminating all workers and clearing the queue.\n\t *\n\t * This method:\n\t * - Terminates all active workers\n\t * - Rejects all pending promises with an error\n\t * - Clears all internal state\n\t * - Resets initialization flags\n\t *\n\t * This should be called when the worker manager is no longer needed\n\t * to prevent memory leaks and ensure proper cleanup.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\treset(): void;\n}\n/**\n * The Culler class is responsible for managing and culling containers.\n * Culling optimizes rendering performance by skipping objects outside the visible area.\n *\n * > [!IMPORTANT] culling is not always a golden bullet, it can be more expensive than rendering\n * > objects that are not visible, so it is best used in scenarios where you have many objects\n * > that are not visible at the same time, such as in large scenes or games with many sprites.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*/\nexport declare class Culler {\n\t/**\n\t * Culls the children of a specific container based on the given view rectangle.\n\t * This determines which objects should be rendered and which can be skipped.\n\t * @param container - The container to cull. Must be a Container instance.\n\t * @param view - The view rectangle that defines the visible area\n\t * @param skipUpdateTransform - Whether to skip updating transforms for better performance\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - Recursively processes all cullable children\n\t * - Uses cullArea if defined, otherwise calculates bounds\n\t * - Performance depends on scene complexity\n\t */\n\tcull(container: Container, view: RectangleLike, skipUpdateTransform?: boolean): void;\n\t/**\n\t * A shared instance of the Culler class. Provides a global culler instance for convenience.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic shared: Culler;\n}\ndeclare class EventsTickerClass {\n\t/** The event system. */\n\tevents: EventSystem;\n\t/** The DOM element to listen to events on. */\n\tdomElement: HTMLElement;\n\t/** The frequency that fake events will be fired. */\n\tinteractionFrequency: number;\n\t/**\n\t * Initializes the event ticker.\n\t * @param events - The event system.\n\t */\n\tinit(events: EventSystem): void;\n\t/** Whether to pause the update checks or not. */\n\tget pauseUpdate(): boolean;\n\tset pauseUpdate(paused: boolean);\n\t/** Adds the ticker listener. */\n\taddTickerListener(): void;\n\t/** Removes the ticker listener. */\n\tremoveTickerListener(): void;\n\t/** Sets flag to not fire extra events when the user has already moved there mouse */\n\tpointerMoved(): void;\n\t/** Destroys the event ticker. */\n\tdestroy(): void;\n}\n/**\n * Options for AlphaFilter\n */\nexport interface AlphaFilterOptions extends FilterOptions {\n\t/**\n\t * Amount of alpha from 0 to 1, where 0 is transparent\n\t * @default 1\n\t */\n\talpha: number;\n}\n/**\n * Simplest filter - applies alpha.\n *\n * Use this instead of Container's alpha property to avoid visual layering of individual elements.\n * AlphaFilter applies alpha evenly across the entire display object and any opaque elements it contains.\n * If elements are not opaque, they will blend with each other anyway.\n *\n * Very handy if you want to use common features of all filters:\n *\n * 1. Assign a blendMode to this filter, blend all elements inside display object with background.\n *\n * 2. To use clipping in display coordinates, assign a filterArea to the same container that has this filter.\n * @example\n * import { AlphaFilter } from 'pixi.js';\n *\n * const filter = new AlphaFilter({ alpha: 0.5 });\n * sprite.filters = filter;\n *\n * // update alpha\n * filter.alpha = 0.8;\n */\nexport declare class AlphaFilter extends Filter {\n\t/**\n\t * Default options for the AlphaFilter.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tstatic defaultOptions: AlphaFilterOptions;\n\tconstructor(options?: AlphaFilterOptions);\n\t/**\n\t * The alpha value of the filter.\n\t * Controls the transparency of the filtered display object.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 1\n\t * @remarks\n\t * - 0 = fully transparent\n\t * - 1 = fully opaque\n\t * - Values are clamped between 0 and 1\n\t */\n\tget alpha(): number;\n\tset alpha(value: number);\n}\n/**\n * Configuration options for the BlurFilter.\n * Controls how the Gaussian blur effect is applied.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Higher quality values produce better blur but impact performance\n * - KernelSize affects blur precision and performance\n * - Strength values determine blur intensity\n */\nexport interface BlurFilterOptions extends FilterOptions {\n\t/**\n\t * The strength of the blur filter.\n\t * Applied to both horizontal and vertical blur if strengthX/Y not set.\n\t * @default 8\n\t */\n\tstrength?: number;\n\t/**\n\t * The horizontal strength of the blur.\n\t * Overrides strength parameter for x-axis.\n\t * @default 8\n\t */\n\tstrengthX?: number;\n\t/**\n\t * The vertical strength of the blur.\n\t * Overrides strength parameter for y-axis.\n\t * @default 8\n\t */\n\tstrengthY?: number;\n\t/**\n\t * The quality of the blur filter.\n\t * Higher values mean better quality but slower performance.\n\t * @default 4\n\t */\n\tquality?: number;\n\t/**\n\t * The kernelSize of the blur filter.\n\t * Larger values create more precise blur but impact performance.\n\t * Options: 5, 7, 9, 11, 13, 15.\n\t * @default 5\n\t */\n\tkernelSize?: number;\n}\n/**\n * The BlurFilter applies a Gaussian blur to an object.\n * The strength of the blur can be set for the x-axis and y-axis separately.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n * - Higher quality values produce better blur but impact performance\n * - Strength controls blur intensity independently for X and Y\n * - Can be optimized using quality and kernelSize settings\n * - Supports edge pixel clamping for special effects\n */\nexport declare class BlurFilter extends Filter {\n\t/**\n\t * Default blur filter options\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @remarks\n\t * - These options are used when creating a new BlurFilter without specific parameters\n\t * - Can be overridden by passing options to the constructor\n\t * - Useful for setting global defaults for all blur filters in your application\n\t */\n\tstatic defaultOptions: Partial<BlurFilterOptions>;\n\t/**\n\t * @param {filters.BlurFilterOptions} options - The options of the blur filter.\n\t */\n\tconstructor(options?: BlurFilterOptions);\n\t/** @deprecated since 8.0.0 */\n\tconstructor(strength?: number, quality?: number, resolution?: number | null, kernelSize?: number);\n\t/**\n\t * Sets the strength of both the blurX and blurY properties simultaneously.\n\t * Controls the overall intensity of the Gaussian blur effect.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 8\n\t * @throws {Error} If strengthX and strengthY are different values\n\t */\n\tget strength(): number;\n\tset strength(value: number);\n\t/**\n\t * Sets the number of passes for blur. More passes means higher quality blurring.\n\t * Controls the precision and smoothness of the blur effect at the cost of performance.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 4\n\t * @remarks Higher values produce better quality but impact performance\n\t */\n\tget quality(): number;\n\tset quality(value: number);\n\t/**\n\t * Sets the strength of horizontal blur.\n\t * Controls the blur intensity along the x-axis independently.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 8\n\t */\n\tget strengthX(): number;\n\tset strengthX(value: number);\n\t/**\n\t * Sets the strength of the vertical blur.\n\t * Controls the blur intensity along the y-axis independently.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* @default 8\n\t */\n\tget strengthY(): number;\n\tset strengthY(value: number);\n\t/**\n\t * Sets the strength of both the blurX and blurY properties simultaneously\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t */\n\tget blur(): number;\n\tset blur(value: number);\n\t/**\n\t * Sets the strength of the blurX property\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t */\n\tget blurX(): number;\n\tset blurX(value: number);\n\t/**\n\t * Sets the strength of the blurY property\n\t * @default 2\n\t * @deprecated since 8.3.0\n\t */\n\tget blurY(): number;\n\tset blurY(value: number);\n\t/**\n\t * If set to true the edge of the target will be clamped\n\t * @default false\n\t */\n\tget repeatEdgePixels(): boolean;\n\tset repeatEdgePixels(value: boolean);\n}\ninterface IGAUSSIAN_VALUES {\n\t[x: number]: number[];\n}\n/**\n * 5x4 matrix for transforming RGBA color and alpha\n */\nexport type ColorMatrix = ArrayFixed<number, 20>;\n/**\n * The ColorMatrixFilter class lets you apply color transformations to display objects using a 5x4 matrix.\n * The matrix transforms the RGBA color and alpha values of every pixel to produce a new set of values.\n *\n * The class provides convenient methods for common color adjustments like brightness, contrast, saturation,\n * and various photo filter effects.\n * @example\n *",
      "language": "unknown"
    },
    {
      "code": "*\n * Common use cases:\n * - Adjusting brightness, contrast, or saturation\n * - Applying color tints or color grading\n * - Creating photo filter effects (sepia, negative, etc.)\n * - Converting to grayscale\n * - Implementing dynamic day/night transitions\n */\nexport declare class ColorMatrixFilter extends Filter {\n\tconstructor(options?: FilterOptions);\n\t/**\n\t * Adjusts the brightness of a display object.\n\t *\n\t * The brightness adjustment works by multiplying the RGB channels by a scalar value while keeping\n\t * the alpha channel unchanged. Values below 1 darken the image, while values above 1 brighten it.\n\t * @param b - The brightness multiplier to apply. Values between 0-1 darken the image (0 being black),\n\t *           while values > 1 brighten it (2.0 would make it twice as bright)\n\t * @param multiply - When true, the new matrix is multiplied with the current one instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tbrightness(b: number, multiply: boolean): void;\n\t/**\n\t * Sets each channel on the diagonal of the color matrix to apply a color tint.\n\t *\n\t * This method provides a way to tint display objects using the color matrix filter, similar to\n\t * the tint property available on Sprites and other display objects. The tint is applied by\n\t * scaling the RGB channels of each pixel.\n\t * @param color - The color to use for tinting, this can be any valid color source.\n\t * @param multiply - When true, the new tint matrix is multiplied with the current matrix instead\n\t *                  of replacing it. This allows for combining tints with other color effects.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttint(color: ColorSource, multiply?: boolean): void;\n\t/**\n\t * Converts the display object to greyscale by applying a weighted matrix transformation.\n\t *\n\t * The greyscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n\t * effectively removing color information while preserving luminance.\n\t * @param scale - The intensity of the greyscale effect. Value between 0-1, where:\n\t *               - 0 produces black\n\t *               - 0.5 produces 50% grey\n\t *               - 1 produces white\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tgreyscale(scale: number, multiply: boolean): void;\n\t/**\n\t * Converts the display object to grayscale by applying a weighted matrix transformation.\n\t *\n\t * The grayscale effect works by setting equal RGB values for each pixel based on the scale parameter,\n\t * effectively removing color information while preserving luminance.\n\t * @param scale - The intensity of the grayscale effect. Value between 0-1, where:\n\t *               - 0 produces black\n\t *               - 0.5 produces 50% grey\n\t *               - 1 produces white\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tgrayscale(scale: number, multiply: boolean): void;\n\t/**\n\t * Converts the display object to pure black and white using a luminance-based threshold.\n\t *\n\t * This method applies a matrix transformation that removes all color information and reduces\n\t * the image to just black and white values based on the luminance of each pixel. The transformation\n\t * uses standard luminance weightings: 30% red, 60% green, and 10% blue.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tblackAndWhite(multiply: boolean): void;\n\t/**\n\t * Adjusts the hue of the display object by rotating the color values around the color wheel.\n\t *\n\t * This method uses an optimized matrix transformation that accurately rotates the RGB color space\n\t * around its luminance axis. The implementation is based on RGB cube rotation in 3D space, providing\n\t * better results than traditional matrices with magic luminance constants.\n\t * @param rotation - The angle of rotation in degrees around the color wheel:\n\t *                  - 0 = no change\n\t *                  - 90 = rotate colors 90Â° clockwise\n\t *                  - 180 = invert all colors\n\t *                  - 270 = rotate colors 90Â° counter-clockwise\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\thue(rotation: number, multiply: boolean): void;\n\t/**\n\t * Adjusts the contrast of the display object by modifying the separation between dark and bright values.\n\t *\n\t * This method applies a matrix transformation that affects the difference between dark and light areas\n\t * in the image. Increasing contrast makes shadows darker and highlights brighter, while decreasing\n\t * contrast brings shadows up and highlights down, reducing the overall dynamic range.\n\t * @param amount - The contrast adjustment value. Range is 0 to 1, where:\n\t *                - 0 represents minimum contrast (flat gray)\n\t *                - 0.5 represents normal contrast\n\t *                - 1 represents maximum contrast\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcontrast(amount: number, multiply: boolean): void;\n\t/**\n\t * Adjusts the saturation of the display object by modifying color separation.\n\t *\n\t * This method applies a matrix transformation that affects the intensity of colors.\n\t * Increasing saturation makes colors more vivid and intense, while decreasing saturation\n\t * moves colors toward grayscale.\n\t * @param amount - The saturation adjustment value. Range is -1 to 1, where:\n\t *                - -1 produces grayscale\n\t *                - 0 represents no change\n\t *                - 1 produces maximum saturation\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tsaturate(amount?: number, multiply?: boolean): void;\n\t/**\n\t * Completely removes color information from the display object, creating a grayscale version.\n\t *\n\t * This is a convenience method that calls `saturate(-1)` internally. The transformation preserves\n\t * the luminance of the original image while removing all color information.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tdesaturate(): void;\n\t/**\n\t * Creates a negative effect by inverting all colors in the display object.\n\t *\n\t * This method applies a matrix transformation that inverts the RGB values of each pixel\n\t * while preserving the alpha channel. The result is similar to a photographic negative.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tnegative(multiply: boolean): void;\n\t/**\n\t * Applies a sepia tone effect to the display object, creating a warm brown tint reminiscent of vintage photographs.\n\t *\n\t * This method applies a matrix transformation that converts colors to various shades of brown while\n\t * preserving the original luminance values.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tsepia(multiply: boolean): void;\n\t/**\n\t * Applies a Technicolor-style effect that simulates the early color motion picture process.\n\t *\n\t * This method applies a matrix transformation that recreates the distinctive look of the\n\t * Technicolor process. The effect produces highly\n\t * saturated colors with a particular emphasis on reds, greens, and blues.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttechnicolor(multiply: boolean): void;\n\t/**\n\t * Applies a vintage Polaroid camera effect to the display object.\n\t *\n\t * This method applies a matrix transformation that simulates the distinctive look of\n\t * Polaroid instant photographs, characterized by slightly enhanced contrast, subtle color shifts,\n\t * and a warm overall tone.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tpolaroid(multiply: boolean): void;\n\t/**\n\t * Swaps the red and blue color channels in the display object.\n\t *\n\t * This method applies a matrix transformation that exchanges the red and blue color values\n\t * while keeping the green channel and alpha unchanged.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\ttoBGR(multiply: boolean): void;\n\t/**\n\t * Applies a Kodachrome color effect that simulates the iconic film stock.\n\t *\n\t * This method applies a matrix transformation that recreates the distinctive look of Kodachrome film,\n\t * known for its rich, vibrant colors and excellent image preservation qualities. The effect emphasizes\n\t * reds and blues while producing deep, true blacks.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tkodachrome(multiply: boolean): void;\n\t/**\n\t * Applies a stylized brown-tinted effect to the display object.\n\t *\n\t * This method applies a matrix transformation that creates a rich, warm brown tone\n\t * with enhanced contrast and subtle color shifts.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tbrowni(multiply: boolean): void;\n\t/**\n\t * Applies a vintage photo effect that simulates old photography techniques.\n\t *\n\t * This method applies a matrix transformation that creates a nostalgic, aged look\n\t * with muted colors, enhanced warmth, and subtle vignetting.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tvintage(multiply: boolean): void;\n\t/**\n\t * We don't know exactly what it does, kind of gradient map, but funny to play with!\n\t * @param desaturation - Tone values.\n\t * @param toned - Tone values.\n\t * @param lightColor - Tone values, example: `0xFFE580`\n\t * @param darkColor - Tone values, example: `0xFFE580`\n\t * @param multiply - if true, current matrix and matrix are multiplied. If false,\n\t *  just set the current matrix with matrix\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tcolorTone(desaturation: number, toned: number, lightColor: ColorSource, darkColor: ColorSource, multiply: boolean): void;\n\t/**\n\t * Applies a night vision effect to the display object.\n\t *\n\t * This method applies a matrix transformation that simulates night vision by enhancing\n\t * certain color channels while suppressing others, creating a green-tinted effect\n\t * similar to night vision goggles.\n\t * @param intensity - The intensity of the night effect (0-1):\n\t *                   - 0 produces no effect\n\t *                   - 0.1 produces a subtle night vision effect (default)\n\t *                   - 1 produces maximum night vision effect\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tnight(intensity: number, multiply: boolean): void;\n\t/**\n\t * Predator effect\n\t *\n\t * Erase the current matrix by setting a new independent one\n\t * @param amount - how much the predator feels his future victim\n\t * @param multiply - if true, current matrix and matrix are multiplied. If false,\n\t *  just set the current matrix with matrix\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tpredator(amount: number, multiply: boolean): void;\n\t/**\n\t * Applies a psychedelic color effect that creates dramatic color shifts.\n\t *\n\t * This method applies a matrix transformation that produces vibrant colors\n\t * through channel mixing and amplification. Creates an effect reminiscent of\n\t * color distortions in psychedelic art.\n\t * @param multiply - When true, the new matrix is multiplied with the current matrix instead of replacing it.\n\t *                  This allows for cumulative effects when calling multiple color adjustments.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\tlsd(multiply: boolean): void;\n\t/**\n\t * Resets the color matrix filter to its default state.\n\t *\n\t * This method resets all color transformations by setting the matrix back to its identity state.\n\t * The identity matrix leaves colors unchanged, effectively removing all previously applied effects.\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "*/\n\treset(): void;\n\t/**\n\t * The current color transformation matrix of the filter.\n\t *\n\t * This 5x4 matrix transforms RGBA color and alpha values of each pixel. The matrix is stored\n\t * as a 20-element array in row-major order.\n\t * @type {ColorMatrix}\n\t * @default [\n\t *     1, 0, 0, 0, 0,  // Red channel\n\t *     0, 1, 0, 0, 0,  // Green channel\n\t *     0, 0, 1, 0, 0,  // Blue channel\n\t *     0, 0, 0, 1, 0   // Alpha channel\n\t * ]\n\t * @example\n\t *",
      "language": "unknown"
    },
    {
      "code": "* const colorMatrix = new ColorMatrixFilter();\n\t *\n\t * // Apply sepia at 50% strength\n\t * colorMatrix.sepia(false);\n\t * colorMatrix.alpha = 0.5;\n\t *\n\t * // Fade between effects\n\t * colorMatrix\n\t *     .saturate(1.5)      // Increase saturation\n\t *     .contrast(1.2);     // Boost contrast\n\t * colorMatrix.alpha = 0.7; // Apply at 70% strength\n\t *",
      "language": "ts"
    },
    {
      "code": "* const options: DisplacementFilterOptions = {\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * };\n *\n * const filter = new DisplacementFilter(options);\n *",
      "language": "ts"
    },
    {
      "code": "* const displacementSprite = new Sprite(texture);\n\t * const filter = new DisplacementFilter({ sprite: displacementSprite });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Uniform scaling\n\t * new DisplacementFilter({ sprite, scale: 20 });\n\t * // Separate scaling\n\t * new DisplacementFilter({ sprite, scale: { x: 10, y: 15 } });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Sprite, DisplacementFilter } from 'pixi.js';\n *\n * // Create a sprite to use as the displacement map\n * const displacementSprite = Sprite.from('displacement-map.png');\n *\n * // Create and configure the filter\n * const displacementFilter = new DisplacementFilter({\n *     sprite: displacementSprite,\n *     scale: { x: 20, y: 20 }\n * });\n *\n * // Apply to any display object\n * container.filters = [displacementFilter];\n *",
      "language": "ts"
    },
    {
      "code": "* const filter = new DisplacementFilter({ sprite });\n\t *\n\t * // Get current scale\n\t * console.log(filter.scale.x, filter.scale.y);\n\t *\n\t * // Update scale\n\t * filter.scale.x = 100;\n\t * filter.scale.y = 50;\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Basic noise effect\n * const options: NoiseFilterOptions = {\n *     noise: 0.5,\n *     seed: Math.random()\n * };\n *\n * // Create filter with options\n * const noiseFilter = new NoiseFilter(options);\n *",
      "language": "ts"
    },
    {
      "code": "* // Moderate noise effect\n\t * const noiseFilter = new NoiseFilter({ noise: 0.5 });\n\t *",
      "language": "ts"
    },
    {
      "code": "* // Using a fixed seed for reproducible noise\n\t * const noiseFilter = new NoiseFilter({ seed: 12345 });\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { NoiseFilter } from 'pixi.js';\n *\n * // Create with options\n * const filter = new NoiseFilter({\n *     noise: 0.5,    // 50% noise intensity\n *     seed: 12345    // Fixed seed for consistent noise\n * });\n *\n * // Apply to a display object\n * sprite.filters = [filter];\n *\n * // Adjust noise dynamically\n * filter.noise = 0.8;    // Increase noise\n * filter.seed = Math.random(); // New random pattern\n *",
      "language": "ts"
    },
    {
      "code": "* NoiseFilter.defaultOptions.noise = 0.7; // Change default noise to 0.7\n\t * const filter = new NoiseFilter(); // Will use noise 0.7 by default\n\t *",
      "language": "ts"
    },
    {
      "code": "* const noiseFilter = new NoiseFilter();\n\t *\n\t * // Set to subtle noise\n\t * noiseFilter.noise = 0.2;\n\t *\n\t * // Set to maximum noise\n\t * noiseFilter.noise = 1.0;\n\t *",
      "language": "ts"
    },
    {
      "code": "* const noiseFilter = new NoiseFilter();\n\t *\n\t * // Use a fixed seed for consistent noise\n\t * noiseFilter.seed = 12345;\n\t *\n\t * // Generate new random pattern\n\t * noiseFilter.seed = Math.random();\n\t *",
      "language": "ts"
    },
    {
      "code": "* import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n *",
      "language": "js"
    },
    {
      "code": "* import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n *",
      "language": "js"
    },
    {
      "code": "* {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n *",
      "language": "json"
    },
    {
      "code": "* import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n *",
      "language": "js"
    },
    {
      "code": "* import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n *",
      "language": "js"
    },
    {
      "code": "* // Basic WebGL support check\n * if (isWebGLSupported()) {\n *     console.log('WebGL is available');\n * }\n *",
      "language": "ts"
    },
    {
      "code": "* // Basic WebGPU support check\n * const hasWebGPU = await isWebGPUSupported();\n * console.log('WebGPU available:', hasWebGPU);\n *",
      "language": "ts"
    },
    {
      "code": "* import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n *",
      "language": "ts"
    }
  ],
  "headings": [],
  "url": "llms-txt#full-api-reference",
  "links": []
}